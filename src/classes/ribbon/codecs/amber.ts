/* eslint-disable */
// @ts-nocheck
import { Bits } from "./utils/bits";
import r from "./utils/msgpackr-943ed70";

import { Buffer } from "buffer/";
import { strictShallowEqual } from "fast-equals";

const k = 11;
const v = 19;

class M {
  static BagList = [
    "total mayhem",
    "classic",
    "pairs",
    "14-bag",
    "7+1-bag",
    "7+2-bag",
    "7+x-bag",
    "7-bag+oo",
    "7+1-lone-bag",
    "14+1-lone-bag",
    "7+2-lone-bag",
    "14+2-lone-bag",
    "zenith",
    "7-bag"
  ];
}

class oe {}
oe.SpinRules = [
  "none",
  "T-spins",
  "T-spins+",
  "all",
  "all+",
  "all-mini",
  "all-mini+",
  "mini-only",
  "handheld",
  "stupid"
];

function x(e) {
  const t = Object.prototype.toString.call(e);
  return x.cached[t]
    ? x.cached[t]
    : (x.cached[t] = t.substring(8, t.length - 1).toLowerCase());
}
x.cached = {};

const L = {
  minotypes: ["z", "l", "o", "s", "i", "j", "t"],
  minocolors: ["z", "l", "o", "s", "i", "j", "t", "g", "d", "gb", "gbd"],
  tetrominoes: {
    i1: {
      matrix: {
        w: 1,
        h: 1,
        dx: 0,
        dy: 1,
        data: [[[0, 0, 255]], [[0, 0, 255]], [[0, 0, 255]], [[0, 0, 255]]]
      },
      preview: { w: 1, h: 1, data: [[0, 0, 255]] },
      disallow_kick: true
    },
    i2: {
      matrix: {
        w: 2,
        h: 2,
        dx: 0,
        dy: 1,
        data: [
          [
            [0, 0, 199],
            [1, 0, 124]
          ],
          [
            [1, 0, 241],
            [1, 1, 31]
          ],
          [
            [1, 1, 124],
            [0, 1, 199]
          ],
          [
            [0, 1, 31],
            [0, 0, 241]
          ]
        ]
      },
      preview: {
        w: 2,
        h: 1,
        data: [
          [0, 0, 199],
          [1, 0, 124]
        ]
      },
      kickset_special: "i2"
    },
    i3: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [0, 1, 199],
            [1, 1, 68],
            [2, 1, 124]
          ],
          [
            [1, 0, 241],
            [1, 1, 17],
            [1, 2, 31]
          ],
          [
            [2, 1, 124],
            [1, 1, 68],
            [0, 1, 199]
          ],
          [
            [1, 2, 31],
            [1, 1, 17],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 1,
        data: [
          [0, 0, 199],
          [1, 0, 68],
          [2, 0, 124]
        ]
      },
      kickset_special: "i3"
    },
    l3: {
      matrix: {
        w: 2,
        h: 2,
        dx: 0,
        dy: 1,
        data: [
          [
            [0, 0, 241],
            [0, 1, 39],
            [1, 1, 124]
          ],
          [
            [1, 0, 124],
            [0, 0, 201],
            [0, 1, 31]
          ],
          [
            [1, 1, 31],
            [1, 0, 114],
            [0, 0, 199]
          ],
          [
            [0, 1, 199],
            [1, 1, 156],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 2,
        h: 2,
        data: [
          [0, 0, 241],
          [0, 1, 39],
          [1, 1, 124]
        ]
      },
      kickset_special: "l3"
    },
    i5: {
      matrix: {
        w: 5,
        h: 5,
        dx: 2,
        dy: 2,
        data: [
          [
            [0, 2, 199],
            [1, 2, 68],
            [2, 2, 68],
            [3, 2, 68],
            [4, 2, 124]
          ],
          [
            [2, 0, 241],
            [2, 1, 17],
            [2, 2, 17],
            [2, 3, 17],
            [2, 4, 31]
          ],
          [
            [4, 2, 124],
            [3, 2, 68],
            [2, 2, 68],
            [1, 2, 68],
            [0, 2, 199]
          ],
          [
            [2, 4, 31],
            [2, 3, 17],
            [2, 2, 17],
            [2, 1, 17],
            [2, 0, 241]
          ]
        ]
      },
      preview: {
        w: 5,
        h: 1,
        data: [
          [0, 0, 199],
          [1, 0, 68],
          [2, 0, 68],
          [3, 0, 68],
          [4, 0, 124]
        ]
      },
      kickset_special: "i5"
    },
    z: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [0, 0, 199],
            [1, 0, 114],
            [1, 1, 39],
            [2, 1, 124]
          ],
          [
            [2, 0, 241],
            [2, 1, 156],
            [1, 1, 201],
            [1, 2, 31]
          ],
          [
            [2, 2, 124],
            [1, 2, 39],
            [1, 1, 114],
            [0, 1, 199]
          ],
          [
            [0, 2, 31],
            [0, 1, 201],
            [1, 1, 156],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 2,
        data: [
          [0, 0, 199],
          [1, 0, 114],
          [1, 1, 39],
          [2, 1, 124]
        ]
      }
    },
    l: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [2, 0, 241],
            [0, 1, 199],
            [1, 1, 68],
            [2, 1, 156]
          ],
          [
            [2, 2, 124],
            [1, 0, 241],
            [1, 1, 17],
            [1, 2, 39]
          ],
          [
            [0, 2, 31],
            [2, 1, 124],
            [1, 1, 68],
            [0, 1, 201]
          ],
          [
            [0, 0, 199],
            [1, 2, 31],
            [1, 1, 17],
            [1, 0, 114]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 2,
        data: [
          [2, 0, 241],
          [0, 1, 199],
          [1, 1, 68],
          [2, 1, 156]
        ]
      }
    },
    o: {
      matrix: {
        w: 2,
        h: 2,
        dx: 0,
        dy: 1,
        data: [
          [
            [0, 0, 193],
            [1, 0, 112],
            [0, 1, 7],
            [1, 1, 28]
          ],
          [
            [1, 0, 112],
            [1, 1, 28],
            [0, 0, 193],
            [0, 1, 7]
          ],
          [
            [1, 1, 28],
            [0, 1, 7],
            [1, 0, 112],
            [0, 0, 193]
          ],
          [
            [0, 1, 7],
            [0, 0, 193],
            [1, 1, 28],
            [1, 0, 112]
          ]
        ]
      },
      preview: {
        w: 2,
        h: 2,
        data: [
          [0, 0, 193],
          [1, 0, 112],
          [0, 1, 7],
          [1, 1, 28]
        ]
      },
      disallow_kick: true
    },
    s: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [1, 0, 201],
            [2, 0, 124],
            [0, 1, 199],
            [1, 1, 156]
          ],
          [
            [2, 1, 114],
            [2, 2, 31],
            [1, 0, 241],
            [1, 1, 39]
          ],
          [
            [1, 2, 156],
            [0, 2, 199],
            [2, 1, 124],
            [1, 1, 201]
          ],
          [
            [0, 1, 39],
            [0, 0, 241],
            [1, 2, 31],
            [1, 1, 114]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 2,
        data: [
          [1, 0, 201],
          [2, 0, 124],
          [0, 1, 199],
          [1, 1, 156]
        ]
      }
    },
    i: {
      matrix: {
        w: 4,
        h: 4,
        dx: 1,
        dy: 1,
        data: [
          [
            [0, 1, 199],
            [1, 1, 68],
            [2, 1, 68],
            [3, 1, 124]
          ],
          [
            [2, 0, 241],
            [2, 1, 17],
            [2, 2, 17],
            [2, 3, 31]
          ],
          [
            [3, 2, 124],
            [2, 2, 68],
            [1, 2, 68],
            [0, 2, 199]
          ],
          [
            [1, 3, 31],
            [1, 2, 17],
            [1, 1, 17],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 4,
        h: 1,
        data: [
          [0, 0, 199],
          [1, 0, 68],
          [2, 0, 68],
          [3, 0, 124]
        ]
      },
      kickset_special: "i"
    },
    j: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [0, 0, 241],
            [0, 1, 39],
            [1, 1, 68],
            [2, 1, 124]
          ],
          [
            [2, 0, 124],
            [1, 0, 201],
            [1, 1, 17],
            [1, 2, 31]
          ],
          [
            [2, 2, 31],
            [2, 1, 114],
            [1, 1, 68],
            [0, 1, 199]
          ],
          [
            [0, 2, 199],
            [1, 2, 156],
            [1, 1, 17],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 2,
        data: [
          [0, 0, 241],
          [0, 1, 39],
          [1, 1, 68],
          [2, 1, 124]
        ]
      }
    },
    t: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [1, 0, 241],
            [0, 1, 199],
            [1, 1, 164],
            [2, 1, 124]
          ],
          [
            [2, 1, 124],
            [1, 0, 241],
            [1, 1, 41],
            [1, 2, 31]
          ],
          [
            [1, 2, 31],
            [2, 1, 124],
            [1, 1, 74],
            [0, 1, 199]
          ],
          [
            [0, 1, 199],
            [1, 2, 31],
            [1, 1, 146],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 2,
        data: [
          [1, 0, 241],
          [0, 1, 199],
          [1, 1, 164],
          [2, 1, 124]
        ]
      }
    },
    oo: {
      matrix: {
        w: 4,
        h: 4,
        dx: 1,
        dy: 1,
        data: [
          [
            [0, 1, 193],
            [1, 1, 64],
            [2, 1, 64],
            [3, 1, 112],
            [0, 2, 7],
            [1, 2, 4],
            [2, 2, 4],
            [3, 2, 28]
          ],
          [
            [2, 0, 112],
            [2, 1, 16],
            [2, 2, 16],
            [2, 3, 28],
            [1, 0, 193],
            [1, 1, 1],
            [1, 2, 1],
            [1, 3, 7]
          ],
          [
            [3, 2, 28],
            [2, 2, 68],
            [1, 2, 68],
            [0, 2, 7],
            [3, 1, 112],
            [2, 1, 64],
            [1, 1, 64],
            [0, 1, 193]
          ],
          [
            [1, 3, 7],
            [1, 2, 1],
            [1, 1, 1],
            [1, 0, 193],
            [2, 3, 28],
            [2, 2, 16],
            [2, 1, 16],
            [2, 0, 112]
          ]
        ]
      },
      preview: {
        w: 4,
        h: 2,
        data: [
          [0, 0, 193],
          [1, 0, 64],
          [2, 0, 64],
          [3, 0, 112],
          [0, 1, 7],
          [1, 1, 4],
          [2, 1, 4],
          [3, 1, 28]
        ]
      },
      kickset_special: "oo",
      weight: 1
    }
  },
  tetrominoes_color: {
    i1: "i",
    i2: "i",
    i3: "i",
    l3: "j",
    i5: "i",
    z: "z",
    l: "l",
    o: "o",
    s: "s",
    i: "i",
    j: "j",
    t: "t",
    oo: "o",
    g: "g",
    d: "d",
    gb: "gb",
    gbd: "gbd"
  },
  spinbonuses_rules: {
    none: {},
    stupid: {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    all: {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    "all+": {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    "all-mini": {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    "all-mini+": {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    "mini-only": {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    handheld: { types: ["t", "s", "z", "l", "j"], types_mini: ["t"] },
    "T-spins": { types: ["t"], types_mini: ["t"] },
    "T-spins+": { types: ["t"], types_mini: ["t"] }
  },
  kicksets: {
    SRS: {
      kicks: {
        "01": [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        10: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        12: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        21: [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        23: [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        32: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        30: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        "03": [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        "02": [
          [0, -1],
          [1, -1],
          [-1, -1],
          [1, 0],
          [-1, 0]
        ],
        13: [
          [1, 0],
          [1, -2],
          [1, -1],
          [0, -2],
          [0, -1]
        ],
        20: [
          [0, 1],
          [-1, 1],
          [1, 1],
          [-1, 0],
          [1, 0]
        ],
        31: [
          [-1, 0],
          [-1, -2],
          [-1, -1],
          [0, -2],
          [0, -1]
        ]
      },
      i_kicks: {
        "01": [
          [-2, 0],
          [1, 0],
          [-2, 1],
          [1, -2]
        ],
        10: [
          [2, 0],
          [-1, 0],
          [2, -1],
          [-1, 2]
        ],
        12: [
          [-1, 0],
          [2, 0],
          [-1, -2],
          [2, 1]
        ],
        21: [
          [1, 0],
          [-2, 0],
          [1, 2],
          [-2, -1]
        ],
        23: [
          [2, 0],
          [-1, 0],
          [2, -1],
          [-1, 2]
        ],
        32: [
          [-2, 0],
          [1, 0],
          [-2, 1],
          [1, -2]
        ],
        30: [
          [1, 0],
          [-2, 0],
          [1, 2],
          [-2, -1]
        ],
        "03": [
          [-1, 0],
          [2, 0],
          [-1, -2],
          [2, 1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i2_kicks: {
        "01": [
          [0, -1],
          [-1, 0],
          [-1, -1]
        ],
        10: [
          [0, 1],
          [1, 0],
          [1, 1]
        ],
        12: [
          [1, 0],
          [0, -1],
          [1, 0]
        ],
        21: [
          [-1, 0],
          [0, 1],
          [-1, 0]
        ],
        23: [
          [0, 1],
          [1, 0],
          [1, -1]
        ],
        32: [
          [0, -1],
          [-1, 0],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, 1],
          [-1, 2]
        ],
        "03": [
          [1, 0],
          [0, -1],
          [1, -2]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i3_kicks: {
        "01": [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1]
        ],
        10: [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1]
        ],
        12: [
          [1, 0],
          [-1, 0],
          [0, -2],
          [0, 2]
        ],
        21: [
          [-1, 0],
          [1, 0],
          [0, 2],
          [0, -2]
        ],
        23: [
          [-1, 0],
          [1, 0],
          [0, 1],
          [0, -1]
        ],
        32: [
          [1, 0],
          [-1, 0],
          [0, -1],
          [0, 1]
        ],
        30: [
          [-1, 0],
          [1, 0],
          [0, 0],
          [0, 0]
        ],
        "03": [
          [1, 0],
          [-1, 0],
          [0, 0],
          [0, 0]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      l3_kicks: {
        "01": [
          [-1, 0],
          [1, 0]
        ],
        10: [
          [1, 0],
          [-1, 0]
        ],
        12: [
          [0, -1],
          [0, 1]
        ],
        21: [
          [0, 1],
          [0, -1]
        ],
        23: [
          [1, 0],
          [-1, 0]
        ],
        32: [
          [-1, 0],
          [1, 0]
        ],
        30: [
          [0, 1],
          [0, -1]
        ],
        "03": [
          [0, -1],
          [0, 1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i5_kicks: {
        "01": [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        10: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        12: [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        21: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        23: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        32: [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        30: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        "03": [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      oo_kicks: {
        "01": [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        10: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        12: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        21: [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        23: [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        32: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        "03": [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        "02": [[0, -1]],
        13: [[1, 0]],
        20: [[0, 1]],
        31: [[-1, 0]]
      },
      additional_offsets: {},
      spawn_rotation: {},
      color_overrides: {},
      preview_overrides: {}
    },
    "SRS+": {
      kicks: {
        "01": [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        10: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        12: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        21: [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        23: [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        32: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        30: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        "03": [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        "02": [
          [0, -1],
          [1, -1],
          [-1, -1],
          [1, 0],
          [-1, 0]
        ],
        13: [
          [1, 0],
          [1, -2],
          [1, -1],
          [0, -2],
          [0, -1]
        ],
        20: [
          [0, 1],
          [-1, 1],
          [1, 1],
          [-1, 0],
          [1, 0]
        ],
        31: [
          [-1, 0],
          [-1, -2],
          [-1, -1],
          [0, -2],
          [0, -1]
        ]
      },
      i_kicks: {
        "01": [
          [1, 0],
          [-2, 0],
          [-2, 1],
          [1, -2]
        ],
        10: [
          [-1, 0],
          [2, 0],
          [-1, 2],
          [2, -1]
        ],
        12: [
          [-1, 0],
          [2, 0],
          [-1, -2],
          [2, 1]
        ],
        21: [
          [-2, 0],
          [1, 0],
          [-2, -1],
          [1, 2]
        ],
        23: [
          [2, 0],
          [-1, 0],
          [2, -1],
          [-1, 2]
        ],
        32: [
          [1, 0],
          [-2, 0],
          [1, -2],
          [-2, 1]
        ],
        30: [
          [1, 0],
          [-2, 0],
          [1, 2],
          [-2, -1]
        ],
        "03": [
          [-1, 0],
          [2, 0],
          [2, 1],
          [-1, -2]
        ],
        "02": [[0, -1]],
        13: [[1, 0]],
        20: [[0, 1]],
        31: [[-1, 0]]
      },
      i2_kicks: {
        "01": [
          [0, -1],
          [-1, 0],
          [-1, -1]
        ],
        10: [
          [0, 1],
          [1, 0],
          [1, 1]
        ],
        12: [
          [1, 0],
          [0, -1],
          [1, 0]
        ],
        21: [
          [-1, 0],
          [0, 1],
          [-1, 0]
        ],
        23: [
          [0, 1],
          [1, 0],
          [1, -1]
        ],
        32: [
          [0, -1],
          [-1, 0],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, 1],
          [-1, 2]
        ],
        "03": [
          [1, 0],
          [0, -1],
          [1, -2]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i3_kicks: {
        "01": [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1]
        ],
        10: [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1]
        ],
        12: [
          [1, 0],
          [-1, 0],
          [0, -2],
          [0, 2]
        ],
        21: [
          [-1, 0],
          [1, 0],
          [0, 2],
          [0, -2]
        ],
        23: [
          [-1, 0],
          [1, 0],
          [0, 1],
          [0, -1]
        ],
        32: [
          [1, 0],
          [-1, 0],
          [0, -1],
          [0, 1]
        ],
        30: [
          [-1, 0],
          [1, 0],
          [0, 0],
          [0, 0]
        ],
        "03": [
          [1, 0],
          [-1, 0],
          [0, 0],
          [0, 0]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      l3_kicks: {
        "01": [
          [-1, 0],
          [1, 0]
        ],
        10: [
          [1, 0],
          [-1, 0]
        ],
        12: [
          [0, -1],
          [0, 1]
        ],
        21: [
          [0, 1],
          [0, -1]
        ],
        23: [
          [1, 0],
          [-1, 0]
        ],
        32: [
          [-1, 0],
          [1, 0]
        ],
        30: [
          [0, 1],
          [0, -1]
        ],
        "03": [
          [0, -1],
          [0, 1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i5_kicks: {
        "01": [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        10: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        12: [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        21: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        23: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        32: [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        30: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        "03": [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      oo_kicks: {
        "01": [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        10: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        12: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        21: [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        23: [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        32: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        "03": [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        "02": [[0, -1]],
        13: [[1, 0]],
        20: [[0, 1]],
        31: [[-1, 0]]
      },
      additional_offsets: {},
      spawn_rotation: {},
      color_overrides: {},
      preview_overrides: {}
    },
    "SRS-X": {
      kicks: {
        "01": [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        10: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        12: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        21: [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        23: [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        32: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        30: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        "03": [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        "02": [
          [1, 0],
          [2, 0],
          [1, 1],
          [2, 1],
          [-1, 0],
          [-2, 0],
          [-1, 1],
          [-2, 1],
          [0, -1],
          [3, 0],
          [-3, 0]
        ],
        13: [
          [0, 1],
          [0, 2],
          [-1, 1],
          [-1, 2],
          [0, -1],
          [0, -2],
          [-1, -1],
          [-1, -2],
          [1, 0],
          [0, 3],
          [0, -3]
        ],
        20: [
          [-1, 0],
          [-2, 0],
          [-1, -1],
          [-2, -1],
          [1, 0],
          [2, 0],
          [1, -1],
          [2, -1],
          [0, 1],
          [-3, 0],
          [3, 0]
        ],
        31: [
          [0, 1],
          [0, 2],
          [1, 1],
          [1, 2],
          [0, -1],
          [0, -2],
          [1, -1],
          [1, -2],
          [-1, 0],
          [0, 3],
          [0, -3]
        ]
      },
      i_kicks: {
        "01": [
          [-2, 0],
          [1, 0],
          [-2, 1],
          [1, -2]
        ],
        10: [
          [2, 0],
          [-1, 0],
          [2, -1],
          [-1, 2]
        ],
        12: [
          [-1, 0],
          [2, 0],
          [-1, -2],
          [2, 1]
        ],
        21: [
          [1, 0],
          [-2, 0],
          [1, 2],
          [-2, -1]
        ],
        23: [
          [2, 0],
          [-1, 0],
          [2, -1],
          [-1, 2]
        ],
        32: [
          [-2, 0],
          [1, 0],
          [-2, 1],
          [1, -2]
        ],
        30: [
          [1, 0],
          [-2, 0],
          [1, 2],
          [-2, -1]
        ],
        "03": [
          [-1, 0],
          [2, 0],
          [-1, -2],
          [2, 1]
        ],
        "02": [
          [-1, 0],
          [-2, 0],
          [1, 0],
          [2, 0],
          [0, 1]
        ],
        13: [
          [0, 1],
          [0, 2],
          [0, -1],
          [0, -2],
          [-1, 0]
        ],
        20: [
          [1, 0],
          [2, 0],
          [-1, 0],
          [-2, 0],
          [0, -1]
        ],
        31: [
          [0, 1],
          [0, 2],
          [0, -1],
          [0, -2],
          [1, 0]
        ]
      },
      i2_kicks: {
        "01": [
          [0, -1],
          [-1, 0],
          [-1, -1]
        ],
        10: [
          [0, 1],
          [1, 0],
          [1, 1]
        ],
        12: [
          [1, 0],
          [0, -1],
          [1, 0]
        ],
        21: [
          [-1, 0],
          [0, 1],
          [-1, 0]
        ],
        23: [
          [0, 1],
          [1, 0],
          [1, -1]
        ],
        32: [
          [0, -1],
          [-1, 0],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, 1],
          [-1, 2]
        ],
        "03": [
          [1, 0],
          [0, -1],
          [1, -2]
        ],
        "02": [
          [-1, 0],
          [-2, 0],
          [1, 0],
          [2, 0],
          [0, 1]
        ],
        13: [
          [0, 1],
          [0, 2],
          [0, -1],
          [0, -2],
          [-1, 0]
        ],
        20: [
          [1, 0],
          [2, 0],
          [-1, 0],
          [-2, 0],
          [0, -1]
        ],
        31: [
          [0, 1],
          [0, 2],
          [0, -1],
          [0, -2],
          [1, 0]
        ]
      },
      i3_kicks: {
        "01": [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1]
        ],
        10: [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1]
        ],
        12: [
          [1, 0],
          [-1, 0],
          [0, -2],
          [0, 2]
        ],
        21: [
          [-1, 0],
          [1, 0],
          [0, 2],
          [0, -2]
        ],
        23: [
          [-1, 0],
          [1, 0],
          [0, 1],
          [0, -1]
        ],
        32: [
          [1, 0],
          [-1, 0],
          [0, -1],
          [0, 1]
        ],
        30: [
          [-1, 0],
          [1, 0],
          [0, 0],
          [0, 0]
        ],
        "03": [
          [1, 0],
          [-1, 0],
          [0, 0],
          [0, 0]
        ],
        "02": [
          [1, 0],
          [2, 0],
          [1, 1],
          [2, 1],
          [-1, 0],
          [-2, 0],
          [-1, 1],
          [-2, 1],
          [0, -1],
          [3, 0],
          [-3, 0]
        ],
        13: [
          [0, 1],
          [0, 2],
          [-1, 1],
          [-1, 2],
          [0, -1],
          [0, -2],
          [-1, -1],
          [-1, -2],
          [1, 0],
          [0, 3],
          [0, -3]
        ],
        20: [
          [-1, 0],
          [-2, 0],
          [-1, -1],
          [-2, -1],
          [1, 0],
          [2, 0],
          [1, -1],
          [2, -1],
          [0, 1],
          [-3, 0],
          [3, 0]
        ],
        31: [
          [0, 1],
          [0, 2],
          [1, 1],
          [1, 2],
          [0, -1],
          [0, -2],
          [1, -1],
          [1, -2],
          [-1, 0],
          [0, 3],
          [0, -3]
        ]
      },
      l3_kicks: {
        "01": [
          [-1, 0],
          [1, 0]
        ],
        10: [
          [1, 0],
          [-1, 0]
        ],
        12: [
          [0, -1],
          [0, 1]
        ],
        21: [
          [0, 1],
          [0, -1]
        ],
        23: [
          [1, 0],
          [-1, 0]
        ],
        32: [
          [-1, 0],
          [1, 0]
        ],
        30: [
          [0, 1],
          [0, -1]
        ],
        "03": [
          [0, -1],
          [0, 1]
        ],
        "02": [
          [1, 0],
          [2, 0],
          [1, 1],
          [2, 1],
          [-1, 0],
          [-2, 0],
          [-1, 1],
          [-2, 1],
          [0, -1],
          [3, 0],
          [-3, 0]
        ],
        13: [
          [0, 1],
          [0, 2],
          [-1, 1],
          [-1, 2],
          [0, -1],
          [0, -2],
          [-1, -1],
          [-1, -2],
          [1, 0],
          [0, 3],
          [0, -3]
        ],
        20: [
          [-1, 0],
          [-2, 0],
          [-1, -1],
          [-2, -1],
          [1, 0],
          [2, 0],
          [1, -1],
          [2, -1],
          [0, 1],
          [-3, 0],
          [3, 0]
        ],
        31: [
          [0, 1],
          [0, 2],
          [1, 1],
          [1, 2],
          [0, -1],
          [0, -2],
          [1, -1],
          [1, -2],
          [-1, 0],
          [0, 3],
          [0, -3]
        ]
      },
      i5_kicks: {
        "01": [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        10: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        12: [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        21: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        23: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        32: [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        30: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        "03": [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        "02": [
          [1, 0],
          [2, 0],
          [1, 1],
          [2, 1],
          [-1, 0],
          [-2, 0],
          [-1, 1],
          [-2, 1],
          [0, -1],
          [3, 0],
          [-3, 0]
        ],
        13: [
          [0, 1],
          [0, 2],
          [-1, 1],
          [-1, 2],
          [0, -1],
          [0, -2],
          [-1, -1],
          [-1, -2],
          [1, 0],
          [0, 3],
          [0, -3]
        ],
        20: [
          [-1, 0],
          [-2, 0],
          [-1, -1],
          [-2, -1],
          [1, 0],
          [2, 0],
          [1, -1],
          [2, -1],
          [0, 1],
          [-3, 0],
          [3, 0]
        ],
        31: [
          [0, 1],
          [0, 2],
          [1, 1],
          [1, 2],
          [0, -1],
          [0, -2],
          [1, -1],
          [1, -2],
          [-1, 0],
          [0, 3],
          [0, -3]
        ]
      },
      oo_kicks: {
        "01": [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        10: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        12: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        21: [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        23: [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        32: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        "03": [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        "02": [[0, -1]],
        13: [[1, 0]],
        20: [[0, 1]],
        31: [[-1, 0]]
      },
      additional_offsets: {},
      spawn_rotation: {},
      color_overrides: {},
      preview_overrides: {}
    },
    "TETRA-X": {
      kicks: {
        "01": [
          [0, 1],
          [-1, 0],
          [1, 0],
          [-1, 1],
          [1, 1],
          [0, -1],
          [-1, -1],
          [1, -1]
        ],
        10: [
          [0, 1],
          [1, 0],
          [-1, 0],
          [1, 1],
          [-1, 1],
          [0, -1],
          [1, -1],
          [-1, -1]
        ],
        12: [
          [0, 1],
          [-1, 0],
          [1, 0],
          [-1, 1],
          [1, 1],
          [0, -1],
          [-1, -1],
          [1, -1]
        ],
        21: [
          [0, 1],
          [1, 0],
          [-1, 0],
          [1, 1],
          [-1, 1],
          [0, -1],
          [1, -1],
          [-1, -1]
        ],
        23: [
          [0, 1],
          [-1, 0],
          [1, 0],
          [-1, 1],
          [1, 1],
          [0, -1],
          [-1, -1],
          [1, -1]
        ],
        32: [
          [0, 1],
          [1, 0],
          [-1, 0],
          [1, 1],
          [-1, 1],
          [0, -1],
          [1, -1],
          [-1, -1]
        ],
        30: [
          [0, 1],
          [-1, 0],
          [1, 0],
          [-1, 1],
          [1, 1],
          [0, -1],
          [-1, -1],
          [1, -1]
        ],
        "03": [
          [0, 1],
          [1, 0],
          [-1, 0],
          [1, 1],
          [-1, 1],
          [0, -1],
          [1, -1],
          [-1, -1]
        ],
        "02": [
          [0, 1],
          [0, -1],
          [-1, 0],
          [1, 0]
        ],
        13: [
          [0, 1],
          [0, -1],
          [-1, 0],
          [1, 0]
        ],
        20: [
          [0, 1],
          [0, -1],
          [-1, 0],
          [1, 0]
        ],
        31: [
          [0, 1],
          [0, -1],
          [-1, 0],
          [1, 0]
        ]
      },
      i_kicks: {
        "01": [
          [0, -1],
          [0, -2],
          [0, 1],
          [1, -1],
          [-1, -1],
          [1, -2],
          [-1, -2]
        ],
        10: [
          [0, -1],
          [0, -2],
          [0, 1],
          [-1, 0],
          [1, 0],
          [2, 0]
        ],
        12: [
          [0, -1],
          [0, -2],
          [0, 1],
          [-1, 0],
          [1, 0],
          [2, 0]
        ],
        21: [
          [0, 1],
          [0, 2],
          [0, -1],
          [-1, 1],
          [1, 1],
          [-1, 2],
          [1, 2]
        ],
        23: [
          [0, 1],
          [0, 2],
          [0, -1],
          [1, 1],
          [-1, 1],
          [1, 2],
          [-1, 2]
        ],
        32: [
          [0, -1],
          [0, -2],
          [0, 1],
          [1, 0],
          [-1, 0],
          [-2, 0]
        ],
        30: [
          [0, -1],
          [0, -2],
          [0, 1],
          [1, 0],
          [-1, 0],
          [-2, 0]
        ],
        "03": [
          [0, -1],
          [0, -2],
          [0, 1],
          [-1, -1],
          [1, -1],
          [-1, -2],
          [1, -2]
        ],
        "02": [
          [0, -1],
          [0, 1]
        ],
        13: [
          [0, -1],
          [0, 1]
        ],
        20: [
          [0, -1],
          [0, 1]
        ],
        31: [
          [0, -1],
          [0, 1]
        ]
      },
      additional_offsets: {},
      spawn_rotation: {},
      color_overrides: {
        i1: "l",
        i2: "l",
        i3: "l",
        l3: "o",
        i5: "l",
        l: "o",
        o: "s",
        s: "i",
        i: "l",
        oo: "s"
      },
      preview_overrides: {}
    },
    NRS: {
      kicks: {
        "01": [],
        10: [],
        12: [],
        21: [],
        23: [],
        32: [],
        30: [],
        "03": [],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      additional_offsets: {
        z: [
          [1, 1],
          [1, 0],
          [1, 0],
          [2, 0]
        ],
        l: [
          [1, 0],
          [1, 0],
          [1, 0],
          [1, 0]
        ],
        o: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        s: [
          [1, 1],
          [1, 0],
          [1, 0],
          [2, 0]
        ],
        i: [
          [0, 1],
          [0, 0],
          [0, 0],
          [1, 0]
        ],
        j: [
          [1, 0],
          [1, 0],
          [1, 0],
          [1, 0]
        ],
        t: [
          [1, 0],
          [1, 0],
          [1, 0],
          [1, 0]
        ]
      },
      spawn_rotation: { z: 0, l: 2, o: 0, s: 0, i: 0, j: 2, t: 2 },
      color_overrides: {},
      preview_overrides: {
        l: [
          [0, 0, 201],
          [1, 0, 68],
          [2, 0, 124],
          [0, 1, 31]
        ],
        j: [
          [0, 0, 199],
          [1, 0, 68],
          [2, 0, 114],
          [2, 1, 31]
        ],
        t: [
          [0, 0, 199],
          [1, 0, 74],
          [2, 0, 124],
          [1, 1, 31]
        ]
      }
    },
    ARS: {
      kicks: {
        "01": [
          [1, 0],
          [-1, 0]
        ],
        10: [
          [1, 0],
          [-1, 0]
        ],
        12: [
          [1, 0],
          [-1, 0]
        ],
        21: [
          [1, 0],
          [-1, 0]
        ],
        23: [
          [1, 0],
          [-1, 0]
        ],
        32: [
          [1, 0],
          [-1, 0]
        ],
        30: [
          [1, 0],
          [-1, 0]
        ],
        "03": [
          [1, 0],
          [-1, 0]
        ],
        "02": [
          [1, 0],
          [-1, 0]
        ],
        13: [
          [1, 0],
          [-1, 0]
        ],
        20: [
          [1, 0],
          [-1, 0]
        ],
        31: [
          [1, 0],
          [-1, 0]
        ]
      },
      i_kicks: {
        "01": [],
        10: [],
        12: [],
        21: [],
        23: [],
        32: [],
        30: [],
        "03": [],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      additional_offsets: {
        i1: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        z: [
          [0, 1],
          [0, 0],
          [0, 0],
          [1, 0]
        ],
        l: [
          [0, 1],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        o: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        s: [
          [0, 1],
          [-1, 0],
          [0, 0],
          [0, 0]
        ],
        i: [
          [0, 0],
          [0, 0],
          [0, -1],
          [1, 0]
        ],
        j: [
          [0, 1],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        t: [
          [0, 1],
          [0, 0],
          [0, 0],
          [0, 0]
        ]
      },
      spawn_rotation: { z: 0, l: 2, o: 0, s: 0, i: 0, j: 2, t: 2 },
      color_overrides: {
        i1: "z",
        i2: "z",
        i3: "z",
        i5: "z",
        z: "s",
        s: "t",
        i: "z",
        t: "i"
      },
      preview_overrides: {
        l: [
          [0, 0, 201],
          [1, 0, 68],
          [2, 0, 124],
          [0, 1, 31]
        ],
        j: [
          [0, 0, 199],
          [1, 0, 68],
          [2, 0, 114],
          [2, 1, 31]
        ],
        t: [
          [0, 0, 199],
          [1, 0, 74],
          [2, 0, 124],
          [1, 1, 31]
        ]
      },
      center_column: {
        pieces: ["l", "j", "t"],
        rules: [
          [-1, -1],
          [0, -1],
          [1, -1],
          [-1, 0],
          [0, 0],
          [1, 0],
          [-1, 1],
          [0, 1],
          [1, 1]
        ]
      }
    },
    ASC: {
      kicks: {
        "01": [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        10: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        12: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        21: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        23: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        32: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        30: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        "03": [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i_kicks: {
        "01": [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        10: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        12: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        21: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        23: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        32: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        30: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        "03": [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      allow_o_kick: true,
      additional_offsets: {
        i1: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        z: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        l: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        o: [
          [0, 0],
          [0, 1],
          [-1, 1],
          [-1, 0]
        ],
        s: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        i: [
          [0, 0],
          [0, -1],
          [1, -1],
          [1, 0]
        ],
        j: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        t: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ]
      },
      color_overrides: {},
      spawn_rotation: {},
      preview_overrides: {}
    },
    none: {
      kicks: {
        "01": [],
        10: [],
        12: [],
        21: [],
        23: [],
        32: [],
        30: [],
        "03": [],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      additional_offsets: {},
      color_overrides: {},
      spawn_rotation: {},
      preview_overrides: {}
    }
  },
  cornerTable: {
    z: [
      [
        [-2, -1],
        [1, -1],
        [2, 0],
        [-1, 0]
      ],
      [
        [0, -1],
        [1, -2],
        [0, 2],
        [1, 1]
      ],
      [
        [-2, 0],
        [1, 0],
        [2, 1],
        [-1, 1]
      ],
      [
        [-1, -1],
        [0, -2],
        [0, 1],
        [-1, 2]
      ]
    ],
    l: [
      [
        [-1, -1],
        [0, -1],
        [1, 1],
        [-1, 1]
      ],
      [
        [-1, -1],
        [1, -1],
        [1, 0],
        [-1, 1]
      ],
      [
        [-1, -1],
        [1, -1],
        [1, 1],
        [0, 1]
      ],
      [
        [-1, 0],
        [1, -1],
        [1, 1],
        [-1, 1]
      ]
    ],
    s: [
      [
        [-1, -1],
        [2, -1],
        [1, 0],
        [-2, 0]
      ],
      [
        [0, -2],
        [1, -1],
        [1, 2],
        [0, 1]
      ],
      [
        [-1, 0],
        [2, 0],
        [1, 1],
        [-2, 1]
      ],
      [
        [-1, -2],
        [0, -1],
        [-1, 1],
        [0, 2]
      ]
    ],
    j: [
      [
        [0, -1],
        [1, -1],
        [1, 1],
        [-1, 1]
      ],
      [
        [-1, -1],
        [1, 0],
        [1, 1],
        [-1, 1]
      ],
      [
        [-1, -1],
        [1, -1],
        [0, 1],
        [-1, 1]
      ],
      [
        [-1, -1],
        [1, -1],
        [1, 1],
        [-1, 0]
      ]
    ],
    t: [
      [
        [-1, -1, 3, 0],
        [1, -1, 0, 1],
        [1, 1, 1, 2],
        [-1, 1, 2, 3]
      ],
      [
        [-1, -1, 3, 0],
        [1, -1, 0, 1],
        [1, 1, 1, 2],
        [-1, 1, 2, 3]
      ],
      [
        [-1, -1, 3, 0],
        [1, -1, 0, 1],
        [1, 1, 1, 2],
        [-1, 1, 2, 3]
      ],
      [
        [-1, -1, 3, 0],
        [1, -1, 0, 1],
        [1, 1, 1, 2],
        [-1, 1, 2, 3]
      ]
    ]
  },
  scoring: {
    SINGLE: 100,
    DOUBLE: 300,
    TRIPLE: 500,
    QUAD: 800,
    PENTA: 1200,
    TSPIN_MINI: 100,
    TSPIN: 400,
    TSPIN_MINI_SINGLE: 200,
    TSPIN_SINGLE: 800,
    TSPIN_MINI_DOUBLE: 400,
    TSPIN_DOUBLE: 1200,
    TSPIN_MINI_TRIPLE: 800,
    TSPIN_TRIPLE: 1600,
    TSPIN_MINI_QUAD: 1600,
    TSPIN_QUAD: 2600,
    TSPIN_PENTA: 3200,
    BACKTOBACK_MULTIPLIER: 1.5,
    COMBO: 50,
    ALL_CLEAR: 3500,
    SOFTDROP: 1,
    HARDDROP: 2
  },
  garbage: {
    SINGLE: 0,
    DOUBLE: 1,
    TRIPLE: 2,
    QUAD: 4,
    PENTA: 5,
    TSPIN_MINI: 0,
    TSPIN: 0,
    TSPIN_MINI_SINGLE: 0,
    TSPIN_SINGLE: 2,
    TSPIN_MINI_DOUBLE: 1,
    TSPIN_DOUBLE: 4,
    TSPIN_MINI_TRIPLE: 2,
    TSPIN_TRIPLE: 6,
    TSPIN_MINI_QUAD: 4,
    TSPIN_QUAD: 10,
    TSPIN_PENTA: 12,
    BACKTOBACK_BONUS: 1,
    BACKTOBACK_BONUS_LOG: 0.8,
    COMBO_MINIFIER: 1,
    COMBO_MINIFIER_LOG: 1.25,
    COMBO_BONUS: 0.25,
    ALL_CLEAR: 10,
    combotable: {
      none: [0],
      "classic guideline": [0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5],
      "modern guideline": [0, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4]
    }
  },
  finesse: {
    z: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 2, 2, 2, 1, 1, 2, 3, 2, 2, 9],
      2: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      3: [9, 9, 2, 2, 2, 1, 1, 2, 3, 2, 2]
    },
    l: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 2, 2, 3, 2, 1, 2, 3, 3, 2, 9],
      2: [9, 9, 3, 4, 3, 2, 3, 4, 4, 3, 9],
      3: [9, 9, 2, 3, 2, 1, 2, 3, 3, 2, 2]
    },
    o: {
      0: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9],
      2: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9],
      3: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9]
    },
    s: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 2, 2, 2, 1, 1, 2, 3, 2, 2, 9],
      2: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      3: [9, 9, 2, 2, 2, 1, 1, 2, 3, 2, 2]
    },
    i: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 1, 9, 9],
      1: [2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 9],
      2: [9, 9, 1, 2, 1, 0, 1, 2, 1, 9, 9],
      3: [9, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2]
    },
    j: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 2, 2, 3, 2, 1, 2, 3, 3, 2, 9],
      2: [9, 9, 3, 4, 3, 2, 3, 4, 4, 3, 9],
      3: [9, 9, 2, 3, 2, 1, 2, 3, 3, 2, 2]
    },
    t: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 2, 2, 3, 2, 1, 2, 3, 3, 2, 9],
      2: [9, 9, 3, 4, 3, 2, 3, 4, 4, 3, 9],
      3: [9, 9, 2, 3, 2, 1, 2, 3, 3, 2, 2]
    }
  },
  zenithRevivePrompts: [
    ["F", "combo", 3, "Perform a 3-Combo", 2, []],
    ["F", "double", 2, "Clear 2 Doubles", 2, []],
    ["F", "quad", 1, "Clear a Quad", 1, []],
    ["F", "lines", 6, "Clear 6 Lines", 1, []],
    ["F", "osingle", 1, "Clear a Single\nusing an O-Piece", 3, []],
    ["F", "odouble", 1, "Clear a Double\nusing an O-Piece", 3, []],
    ["F", "szdouble", 1, "Clear a Double\nusing an S or Z-Piece", 3, []],
    ["F", "ljtriple", 1, "Clear a Triple\nusing an L or J-Piece", 3, []],
    [
      "F",
      "iholdlines",
      3,
      "Clear 3 lines\nwhile holding an I-Piece",
      3,
      ["nohold"]
    ],
    ["F", "hold", 8, "Use Hold 8 times", 2, ["nohold"]],
    ["F", "rotate", 20, "Rotate 20 times", 2, []],
    ["F", "singleconsecutive", 2, "Clear 2 Singles in a row", 3, []],
    ["E", "spin", 1, "Perform any Spin", 2, []],
    ["E", "tspinsingle", 1, "Clear a T-Spin Single", 2, []],
    ["E", "tspindouble", 1, "Clear a T-Spin Double", 2, []],
    ["E", "szspin", 1, "Clear an S/Z-Spin", 1, []],
    ["E", "ljspin", 1, "Clear an L/J-Spin", 1, []],
    ["E", "combo", 5, "Perform a 5-Combo", 2, []],
    ["E", "iflat", 2, "Clear 2 Lines using\nhorizontal I-Pieces", 3, []],
    ["E", "pieces", 20, "Place 20 pieces", 2, []],
    ["E", "attack", 6, "Send 6 Attack", 1, []],
    ["E", "placeoconsecutive", 2, "Place 2 O-Pieces\nin a row", 3, ["nohold"]],
    [
      "E",
      "norotateclockwise",
      12,
      "Place 12 pieces while only\nrotating counterclockwise",
      4,
      []
    ],
    [
      "E",
      "singlenocombo",
      6,
      "Clear 6 Singles without\nstarting a combo",
      3,
      []
    ],
    ["D", "double", 4, "Clear 4 Doubles", 2, []],
    [
      "D",
      "spam",
      3,
      "Place 3 pieces in a row\nwithout moving or rotating",
      4,
      []
    ],
    [
      "D",
      "noclear",
      14,
      "Place 14 pieces in a row\nwithout clearing any lines",
      4,
      []
    ],
    ["D", "szdouble", 2, "Clear 2 Doubles\nusing S or Z-Pieces", 3, []],
    ["D", "ljtriple", 2, "Clear 2 Triples\nusing L or J-Pieces", 3, []],
    ["D", "ispinclear", 1, "Clear an I-Spin", 1, []],
    [
      "D",
      "upperhalfquad",
      1,
      "Clear a Quad in the\nupper half of the board",
      4,
      []
    ],
    ["D", "rotate", 80, "Rotate 80 times", 2, []],
    ["D", "quadcombo", 1, "Clear a Quad\nwhile on a 2+-Combo", 4, []],
    [
      "D",
      "szsingle",
      2,
      "Clear 2 Singles in a row\nusing S or Z-Pieces",
      4,
      []
    ],
    ["D", "combonohold", 3, "Perform a 3-Combo\nwithout using Hold", 3, []],
    [
      "D",
      "noclearspin",
      3,
      "Perform 3 Spins\nthat don't clear any lines",
      4,
      []
    ],
    ["D", "szljspin", 2, "Perform 2\nS/Z/L/J-Spins", 3, []],
    ["C", "tspintriple", 1, "Clear a T-Spin Triple", 2, []],
    [
      "C",
      "nohold",
      25,
      "Place 25 pieces in a row\nwithout using Hold",
      4,
      ["nohold"]
    ],
    ["C", "triple", 3, "Clear 3 Triples", 2, []],
    ["C", "b2b", 4, "Reach B2B x4", 1, []],
    ["C", "quadbuckets", 2, "Clear a Quad in\n2 different columns", 3, []],
    [
      "C",
      "holdconsecutive",
      12,
      "Use Hold on\n12 pieces in a row",
      3,
      ["nohold"]
    ],
    [
      "C",
      "softdrop",
      10,
      "Place 10 pieces without\nreleasing Soft Drop",
      4,
      []
    ],
    [
      "C",
      "top3rows",
      3,
      "Have part of your stack in\nthe top 3 rows for 3 seconds",
      4,
      []
    ],
    [
      "C",
      "linesnoti",
      10,
      "Clear 10 Lines without\nclearing with T or I-pieces",
      4,
      []
    ],
    ["C", "szspintriple", 1, "Clear an S/Z-Spin Triple", 2, []],
    [
      "C",
      "odoubleconsecutive",
      2,
      "Clear 2 Doubles consecutively\nusing two O-Pieces",
      4,
      ["nohold"]
    ],
    ["C", "tspinminiclear", 4, "Clear 4 T-Spin Minis", 2, []],
    ["C", "attack", 14, "Send 14 Attack", 1, []],
    [
      "C",
      "doublespiece",
      3,
      "Clear 3 Doubles\nwith the same type of piece",
      4,
      []
    ],
    ["C", "ljgarbage", 1, "Clear Garbage\nusing a L/J-Spin", 3, []],
    ["C", "szgarbage", 1, "Clear Garbage\nusing a S/Z-Spin", 3, []],
    ["C", "columnopiece", 3, "Place 3 O-Pieces\nin column 1", 3, []],
    ["C", "spinclear", 2, "Clear 2 Spins\nin one combo", 3, []],
    [
      "C",
      "iclearspam",
      1,
      "Clear a Single with an I-Piece\nwithout moving or rotating",
      4,
      []
    ],
    ["C", "holddas", 6, "Place 6 Pieces\nwithout releasing DAS", 3, []],
    ["B", "oclear", 6, "Clear 6 Lines\nusing O-Pieces", 3, []],
    [
      "B",
      "spinbuckets",
      3,
      "Clear Spin-Clears\nwith 3 different pieces",
      3,
      []
    ],
    ["B", "quad", 4, "Clear 4 Quads", 1, []],
    [
      "B",
      "spam",
      5,
      "Place 5 pieces in a row\nwithout moving or rotating",
      4,
      []
    ],
    ["B", "ljspintriple", 1, "Clear an L/J-Spin Triple", 2, []],
    ["B", "quadconsecutive", 2, "Clear 2 Quads in a row", 2, []],
    [
      "B",
      "singlesonly",
      8,
      "Clear 8 Singles without doing\nother clears or using Hold",
      4,
      []
    ],
    [
      "B",
      "nogarbage",
      4,
      "Have no Garbage Lines on\nyour board for 4 seconds",
      4,
      []
    ],
    ["B", "rotate", 300, "Rotate 300 times", 2, []],
    ["B", "nocancel", 8, "Don't cancel any\ngarbage for 8 seconds", 3, []],
    [
      "B",
      "tspindoubleup",
      1,
      "Clear a T-Spin Double\nwith the Piece pointing up",
      4,
      []
    ],
    [
      "B",
      "oclearspam",
      1,
      "Clear a Double with an O-Piece\nwithout moving or rotating",
      4,
      []
    ],
    ["B", "tnorotate", 3, "Place 3 T-Pieces\nwithout rotating any", 3, []],
    ["B", "tspincombo", 1, "Clear a T-Spin Double\nwhile on a 2+-Combo", 3, []],
    ["A", "combo", 7, "Perform a 7-Combo", 2, []],
    ["A", "ispindouble", 1, "Clear an I-Spin Double", 2, []],
    [
      "A",
      "szspinconsecutive",
      2,
      "Clear two S/Z-Spin\nDoubles consecutively",
      3,
      []
    ],
    [
      "A",
      "ljspinconsecutive",
      2,
      "Clear two L/J-Spin\nDoubles consecutively",
      3,
      []
    ],
    ["A", "colorclear", 1, "Perform a Color Clear", 2, []],
    ["A", "lines", 40, "Clear 40 Lines", 1, []],
    ["A", "combospin", 4, "Clear 4 Spins\nin one Combo", 3, []],
    [
      "A",
      "tspindtcolumn",
      1,
      "Clear a T-Spin Double/Triple\ncentered in column 1 or 10",
      3,
      []
    ]
  ],
  zenithReviveDecks: [
    { F: 0, E: 0, D: 0, C: 0, B: 0, A: 0 },
    { F: 1, E: 0, D: 0, C: 0, B: 0, A: 0 },
    { F: 2, E: 0, D: 0, C: 0, B: 0, A: 0 },
    { F: 3, E: 0, D: 0, C: 0, B: 0, A: 0 },
    { F: 2, E: 1, D: 0, C: 0, B: 0, A: 0 },
    { F: 1, E: 2, D: 0, C: 0, B: 0, A: 0 },
    { F: 0, E: 3, D: 0, C: 0, B: 0, A: 0 },
    { F: 0, E: 2, D: 1, C: 0, B: 0, A: 0 },
    { F: 0, E: 1, D: 2, C: 0, B: 0, A: 0 },
    { F: 0, E: 0, D: 3, C: 0, B: 0, A: 0 },
    { F: 0, E: 0, D: 2, C: 1, B: 0, A: 0 },
    { F: 0, E: 0, D: 1, C: 2, B: 0, A: 0 },
    { F: 0, E: 0, D: 0, C: 3, B: 0, A: 0 },
    { F: 0, E: 0, D: 0, C: 2, B: 1, A: 0 },
    { F: 0, E: 0, D: 0, C: 1, B: 2, A: 0 },
    { F: 0, E: 0, D: 0, C: 0, B: 3, A: 0 },
    { F: 0, E: 0, D: 0, C: 0, B: 2, A: 1 },
    { F: 0, E: 0, D: 0, C: 0, B: 1, A: 2, order: ["A", "B", "A"] }
  ],
  zenithFatigue: [
    [28080, [["dim", 0.7]]],
    [28200, [["dim", 0.9]]],
    [28320, [["dim", 0.5]]],
    [28440, [["dim", 0.8]]],
    [28560, [["dim", 0.3]]],
    [28680, [["dim", 0.1]]],
    [
      28800,
      [
        ["color", 16518572],
        ["unclearable"],
        ["shake", 5],
        [
          "waterfall",
          {
            msg: 'FATIGUE SETS IN<br><span style="font-size: 0.8em;">+2 PERMANENT LINES</span>',
            fgcolor: "#FFFFFF",
            bgcolor: "#801346",
            timeout: 5e3
          }
        ]
      ]
    ],
    [28830, [["unclearable"], ["shake", 5]]],
    [28860, [["dim", 1]]],
    [31680, [["dim", 0.7]]],
    [31800, [["dim", 0.9]]],
    [31920, [["dim", 0.5]]],
    [32040, [["dim", 0.8]]],
    [32160, [["dim", 0.3]]],
    [32280, [["dim", 0.1]]],
    [
      32400,
      [
        ["color", 16518572],
        ["receivemultiplier", 0.25],
        [
          "waterfall",
          {
            msg: 'YOUR BODY GROWS WEAK<br><span style="font-size: 0.8em;">receive 25% more garbage</span>',
            fgcolor: "#FFFFFF",
            bgcolor: "#801346",
            timeout: 5e3
          }
        ]
      ]
    ],
    [32460, [["dim", 1]]],
    [35280, [["dim", 0.7]]],
    [35400, [["dim", 0.9]]],
    [35520, [["dim", 0.5]]],
    [35640, [["dim", 0.8]]],
    [35760, [["dim", 0.3]]],
    [35880, [["dim", 0.1]]],
    [
      36e3,
      [
        ["color", 16518572],
        ["unclearable"],
        ["shake", 5],
        [
          "waterfall",
          {
            msg: 'ALL SENSES BLUR TOGETHER<br><span style="font-size: 0.8em;">+3 PERMANENT LINES</span>',
            fgcolor: "#FFFFFF",
            bgcolor: "#801346",
            timeout: 5e3
          }
        ]
      ]
    ],
    [36030, [["unclearable"], ["shake", 5]]],
    [36060, [["unclearable"], ["shake", 5]]],
    [36120, [["dim", 1]]],
    [38880, [["dim", 0.7]]],
    [39e3, [["dim", 0.9]]],
    [39120, [["dim", 0.5]]],
    [39240, [["dim", 0.8]]],
    [39360, [["dim", 0.3]]],
    [39480, [["dim", 0.1]]],
    [
      39600,
      [
        ["color", 16518572],
        ["receivemultiplier", 0.25],
        [
          "waterfall",
          {
            msg: 'YOUR CONSCIOUSNESS FADES<br><span style="font-size: 0.8em;">receive 25% more garbage</span>',
            fgcolor: "#FFFFFF",
            bgcolor: "#801346",
            timeout: 5e3
          }
        ]
      ]
    ],
    [39660, [["dim", 1]]],
    [42480, [["dim", [0.7, 0.65, 0.65]]]],
    [42600, [["dim", 0.9]]],
    [42720, [["dim", [0.5, 0.45, 0.45]]]],
    [42840, [["dim", 0.8]]],
    [42960, [["dim", [0.3, 0.25, 0.25]]]],
    [43080, [["dim", [0.1, 0.05, 0.05]]]],
    [
      43200,
      [
        ["color", 16711705],
        ["unclearable"],
        ["shake", 5],
        [
          "waterfall",
          {
            msg: 'THIS IS THE END.<br><span style="font-size: 0.8em;">+5 PERMANENT LINES</span>',
            fgcolor: "#FFFFFF",
            bgcolor: "#870815",
            timeout: 1e4
          }
        ]
      ]
    ],
    [43230, [["unclearable"], ["shake", 5]]],
    [43260, [["unclearable"], ["shake", 5]]],
    [43310, [["unclearable"], ["shake", 5]]],
    [43360, [["unclearable"], ["shake", 5]]],
    [43500, [["dim", 1]]]
  ],
  zenithFatigueRevEx: [
    [20880, [["dim", [0.7, 0.6, 0.6]]]],
    [21e3, [["dim", 0.9]]],
    [21120, [["dim", [0.5, 0.4, 0.4]]]],
    [21240, [["dim", 0.8]]],
    [21360, [["dim", [0.3, 0.2, 0.2]]]],
    [21480, [["dim", [0.2, 0, 0]]]],
    [
      21600,
      [
        ["color", 16518753],
        ["gracestillmessy"],
        [
          "waterfall",
          {
            msg: 'YOUR POWER SLIPS<br><span style="font-size: 0.8em;">garbage received becomes messier</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [21660, [["dim", 1]]],
    [24480, [["dim", [0.7, 0.6, 0.6]]]],
    [24600, [["dim", 0.9]]],
    [24720, [["dim", [0.5, 0.4, 0.4]]]],
    [24840, [["dim", 0.8]]],
    [24960, [["dim", [0.3, 0.2, 0.2]]]],
    [25080, [["dim", [0.2, 0, 0]]]],
    [
      25200,
      [
        ["color", 16518753],
        ["receivemultiplier", 0.25],
        [
          "waterfall",
          {
            msg: 'WHISPERS OF DISCONTENT SPREAD<br><span style="font-size: 0.8em;">receive 25% more garbage</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [25260, [["dim", 1]]],
    [28080, [["dim", [0.7, 0.6, 0.6]]]],
    [28200, [["dim", 0.9]]],
    [28320, [["dim", [0.5, 0.4, 0.4]]]],
    [28440, [["dim", 0.8]]],
    [28560, [["dim", [0.3, 0.2, 0.2]]]],
    [28680, [["dim", [0.2, 0, 0]]]],
    [
      28800,
      [
        ["color", 16518753],
        ["unclearable"],
        ["shake", 5],
        [
          "waterfall",
          {
            msg: 'PROTESTERS LINE THE STREETS<br><span style="font-size: 0.8em;">+3 PERMANENT LINES</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [28830, [["unclearable"], ["shake", 5]]],
    [28860, [["unclearable"], ["shake", 5]]],
    [28920, [["dim", 1]]],
    [31680, [["dim", [0.7, 0.6, 0.6]]]],
    [31800, [["dim", 0.9]]],
    [31920, [["dim", [0.5, 0.4, 0.4]]]],
    [32040, [["dim", 0.8]]],
    [32160, [["dim", [0.3, 0.2, 0.2]]]],
    [32280, [["dim", [0.2, 0, 0]]]],
    [
      32400,
      [
        ["color", 16518753],
        ["receivemultiplier", 0.25],
        [
          "waterfall",
          {
            msg: 'YOUR CLOSEST ALLIES DEFECT<br><span style="font-size: 0.8em;">receive 25% more garbage</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [32460, [["dim", 1]]],
    [35280, [["dim", [0.7, 0.6, 0.6]]]],
    [35400, [["dim", 0.9]]],
    [35520, [["dim", [0.5, 0.4, 0.4]]]],
    [35640, [["dim", 0.8]]],
    [35760, [["dim", [0.3, 0.2, 0.2]]]],
    [35880, [["dim", [0.2, 0, 0]]]],
    [
      36e3,
      [
        ["color", 16518753],
        ["unclearable"],
        ["shake", 5],
        [
          "waterfall",
          {
            msg: 'PARANOIA CLOUDS YOUR JUDGEMENT<br><span style="font-size: 0.8em;">+5 PERMANENT LINES</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [36030, [["unclearable"], ["shake", 5]]],
    [36060, [["unclearable"], ["shake", 5]]],
    [36110, [["unclearable"], ["shake", 5]]],
    [36160, [["unclearable"], ["shake", 5]]],
    [36300, [["dim", 1]]],
    [38880, [["dim", [0.7, 0.6, 0.6]]]],
    [39e3, [["dim", 0.9]]],
    [39120, [["dim", [0.5, 0.4, 0.4]]]],
    [39240, [["dim", 0.8]]],
    [39360, [["dim", [0.3, 0.2, 0.2]]]],
    [39480, [["dim", [0.2, 0, 0]]]],
    [
      39600,
      [
        ["color", 16518753],
        ["maxmessy"],
        [
          "waterfall",
          {
            msg: 'THE REVOLUTION HAS BEGUN<br><span style="font-size: 0.8em;">garbage received becomes much messier</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [39660, [["dim", 1]]],
    [42e3, [["dim", [0.7, 0.6, 0.6]]]],
    [42120, [["dim", 0.9]]],
    [42240, [["dim", [0.7, 0.4, 0.4]]]],
    [42360, [["dim", 0.9]]],
    [42480, [["dim", [0.5, 0.4, 0.4]]]],
    [42600, [["dim", 0.8]]],
    [42720, [["dim", [0.5, 0.2, 0.2]]]],
    [42840, [["dim", 0.8]]],
    [42960, [["dim", [0.3, 0.1, 0.1]]]],
    [43080, [["dim", [0.2, 0, 0]]]],
    [43140, [["dim", [0, 0, 0]]]],
    [
      43200,
      [
        ["color", 16711680],
        ["unclearable"],
        ["shake", 10],
        [
          "waterfall",
          {
            msg: 'THE END OF AN ERA.<br><span style="font-size: 0.8em;">+12 PERMANENT LINES</span>',
            fgcolor: "#ff2600",
            bgcolor: "#000000",
            timeout: 15e3
          }
        ]
      ]
    ],
    [43230, [["unclearable"], ["shake", 10]]],
    [43260, [["unclearable"], ["shake", 10]]],
    [43310, [["unclearable"], ["shake", 10]]],
    [43360, [["unclearable"], ["shake", 10]]],
    [43420, [["unclearable"], ["shake", 10]]],
    [43480, [["unclearable"], ["shake", 10]]],
    [43550, [["unclearable"], ["shake", 10]]],
    [43620, [["unclearable"], ["shake", 10]]],
    [43700, [["unclearable"], ["shake", 10]]],
    [43780, [["unclearable"], ["shake", 10]]],
    [43850, [["unclearable"], ["shake", 10]]],
    [43920, [["dim", 1]]]
  ],
  majorShoutStyles: {
    globalbest: () => {
      Sl.play("confetti", { gui: true, count: 30 });
    },
    personalbest: () => {
      Sl.play("confetti", { gui: true, count: 15, hue: [30, 60] });
    },
    lg_victory: () => {
      setTimeout(() => {
        Sl.play("confetti", { gui: false, count: 15, hue: [30, 60] });
      }, 1250);
    }
  },
  globalShoutStyles: {},
  gameModes: {
    "40l": {
      version: v,
      gameid: "X-PASSTHRU",
      seed_random: false,
      anchorseed: true,
      seed: "X-PASSTHRU",
      allow180: true,
      g: 0.02,
      objective_type: "lines",
      objective_count: 40,
      handling: "X-PASSTHRU",
      countdown: "X-PASSTHRU",
      countdown_interval: "X-PASSTHRU",
      precountdown: "X-PASSTHRU",
      prestart: "X-PASSTHRU",
      mission: "X-PASSTHRU",
      zoominto: "X-PASSTHRU",
      bgmnoreset: "X-PASSTHRU",
      slot_counter1: "X-PASSTHRU",
      slot_counter2: "X-PASSTHRU",
      slot_counter3: "X-PASSTHRU",
      slot_counter4: "X-PASSTHRU",
      slot_counter5: "X-PASSTHRU",
      slot_bar2: "progress",
      can_retry: true,
      nolockout: true,
      pro: "X-PASSTHRU",
      pro_alert: "X-PASSTHRU",
      pro_retry: "X-PASSTHRU",
      stride: "X-PASSTHRU",
      no_szo: "X-PASSTHRU",
      fromretry: "X-PASSTHRU"
    },
    blitz: {
      version: v,
      gameid: "X-PASSTHRU",
      seed_random: false,
      anchorseed: true,
      seed: "X-PASSTHRU",
      allow180: true,
      objective_type: "timed",
      objective_time: 12e4,
      levels: true,
      levelspeed: 0.42,
      levelgbase: 0.65,
      gravitymay20g: false,
      handling: "X-PASSTHRU",
      countdown: "X-PASSTHRU",
      countdown_interval: "X-PASSTHRU",
      precountdown: "X-PASSTHRU",
      prestart: "X-PASSTHRU",
      mission: "X-PASSTHRU",
      zoominto: "X-PASSTHRU",
      bgmnoreset: "X-PASSTHRU",
      slot_counter1: "X-PASSTHRU",
      slot_counter2: "X-PASSTHRU",
      slot_counter3: "X-PASSTHRU",
      slot_counter4: "X-PASSTHRU",
      slot_counter5: "X-PASSTHRU",
      slot_bar2: "progress",
      can_retry: true,
      nolockout: true,
      pro: "X-PASSTHRU",
      pro_alert: "X-PASSTHRU",
      pro_retry: "X-PASSTHRU",
      stride: "X-PASSTHRU",
      no_szo: "X-PASSTHRU",
      fromretry: "X-PASSTHRU"
    }
  },
  Strings: {
    cleartypes: [
      "VOID",
      "SINGLE",
      "DOUBLE",
      "TRIPLE",
      "QUAD",
      "PENTA",
      "HEXA",
      "HEPTA",
      "OCTA",
      "ENNEA",
      "DECA",
      "HENDECA",
      "DODECA",
      "TRIADECA",
      "TESSARADECA",
      "PENTEDECA",
      "HEXADECA",
      "HEPTADECA",
      "OCTADECA",
      "ENNEADECA",
      "EICOSA",
      "KAGARIS"
    ],
    tspins: { mini: "\fc3MINI\f5 %%PIECE%%-spin", normal: "%%PIECE%%-spin" },
    extra: {
      btb: "back-to-back",
      btb_short: "BACK-TO-BACK",
      clear: "ALL\nCLEAR",
      colorclear: "COLOR\nCLEAR",
      zenlevel: "LEVEL\nCOMPLETE"
    },
    longTypeNames: {
      "40l": "40 LINES",
      blitz: "BLITZ",
      "5mblast": "5,000,000 BLAST",
      zen: "ZEN",
      custom: "CUSTOM GAME",
      league: "TETRA LEAGUE",
      zenith: "QUICK PLAY",
      zenithex: "EXPERT QUICK PLAY"
    },
    gameMissions: {
      "40l": "CLEAR 40 LINES!",
      blitz: "TWO-MINUTE BLITZ",
      "5mblast": "5,000,000 BLAST!",
      zen: "ZEN",
      "40 LINES": "CLEAR 40 LINES!",
      BLITZ: "TWO-MINUTE BLITZ",
      "5,000,000 BLAST": "5,000,000 BLAST!",
      ZEN: "ZEN"
    },
    zenithMods: {
      invisible: "Invisible",
      messy: "Messier Garbage",
      volatile: "Volatile Garbage",
      nohold: "No Hold",
      doublehole: "Double Hole Garbage",
      allspin: "All-Spin",
      gravity: "Gravity",
      expert: "Expert Mode",
      duo: "Duo",
      snowman: "Snowball Board",
      invisible_reversed: "The Exile",
      messy_reversed: "Loaded Dice",
      volatile_reversed: "Last Stand",
      nohold_reversed: "Asceticism",
      doublehole_reversed: "Damnation",
      allspin_reversed: "The Warlock",
      gravity_reversed: "Freefall",
      expert_reversed: "The Tyrant"
    },
    zenithModsShort: {
      invisible: "IN",
      messy: "MS",
      volatile: "VL",
      nohold: "NH",
      doublehole: "DH",
      allspin: "AS",
      gravity: "GV",
      expert: "EX",
      duo: "2P",
      snowman: "SNOWBALL",
      invisible_reversed: "IN-R",
      messy_reversed: "MS-R",
      volatile_reversed: "VL-R",
      nohold_reversed: "NH-R",
      doublehole_reversed: "DH-R",
      allspin_reversed: "AS-R",
      gravity_reversed: "GV-R",
      expert_reversed: "EX-R"
    }
  },
  allowedReverseCards: [
    "expert",
    "nohold",
    "messy",
    "gravity",
    "volatile",
    "doublehole",
    "invisible",
    "allspin"
  ]
};

class be {
  static FloorDistance = [
    0,
    50,
    150,
    300,
    450,
    650,
    850,
    1100,
    1350,
    1650,
    1 / 0
  ];
  static GravityBumps = [0, 0.48, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3];
  static GLockDelay = [0, 30, 29, 28, 27, 26, 24, 22, 20, 18, 16];
  static GRLockDelay = [0, 24, 22, 20, 18, 16, 15, 14, 13, 12, 11];
  static SpeedrunReq = [7, 8, 8, 9, 9, 10, 0, 0, 0, 0, 0];
  static Mods = [
    "invisible",
    "messy",
    "volatile",
    "nohold",
    "doublehole",
    "allspin",
    "gravity",
    "expert",
    "duo"
  ];
  static TargetingGraceRevEx = [
    0, 1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1
  ];
  static RevNoHoldHoleSideChangeChance = [
    0.1, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55
  ];
  static ReviveLevelIncrease = [1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3];
  static CancelingFatigueBumpCap = [
    4,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    1 / 0,
    1 / 0,
    1 / 0
  ];
}

class H {
  static DisplayCounters = {
    timer: "time",
    stopwatch: "time",
    level: "level",
    lines: "lines",
    allclears: "all clears",
    hold: "hold",
    pieces: "pieces",
    pieces_duo: "pieces",
    finesse_l: "finesse",
    finesse: "finesse",
    keys: "inputs",
    score: "score",
    spp: "score",
    garbage: "garbage",
    attack: "attack",
    attack_duo: "attack",
    vs: "VS score",
    kills: "KO's",
    kills_duo: "KO's",
    placement: "placement"
  };
  static DisplayCountersList = Object.keys(this.DisplayCounters);
}

class Ce {
  static OptionsList = {
    version: { default: k, static: true },
    gameid: { default: 0, min: 0, max: 8192, strict: true },
    seed: { default: 0 },
    seed_random: { default: false },
    score: { default: 0 },
    are: { default: 0 },
    lineclear_are: { default: 0 },
    g: { default: 0.02 },
    gincrease: { default: 0 },
    gmargin: { default: 0 },
    gravitymay20g: { default: true },
    shielded: { default: 0 },
    hasgarbage: { default: false },
    usebombs: { default: false },
    garbagespeed: { default: 20, integer: true, min: 1 },
    garbagefavor: { default: 0 },
    garbagemultiplier: { default: 1 },
    receivemultiplier: { default: 1 },
    cancelmultiplier: { default: 1 },
    garbagemargin: { default: 0 },
    garbageincrease: { default: 0 },
    garbageholesize: { default: 1 },
    garbagephase: { default: 0 },
    garbagequeue: { default: false },
    garbageentry: {
      default: "instant",
      allowed: ["instant", "continuous", "delayed"]
    },
    garbageare: { default: 5, integer: true, min: 1 },
    garbagearebump: { default: 12, integer: true, min: 0 },
    garbagecap: { default: 8 },
    garbagecapincrease: { default: 0 },
    garbagecapmargin: { default: 0 },
    garbagecapmax: { default: 40 },
    garbageabsolutecap: { default: 0 },
    garbageattackcap: { default: 0 },
    garbagetargetbonus: {
      default: "none",
      allowed: ["none", "defensive", "offensive"]
    },
    garbageblocking: {
      default: "combo blocking",
      allowed: ["none", "combo blocking", "limited blocking"]
    },
    passthrough: {
      default: "zero",
      allowed: ["zero", "limited", "consistent", "full"]
    },
    openerphase: { default: 0 },
    roundmode: { default: "down", allowed: ["down", "rng"] },
    garbagespecialbonus: { default: false },
    spinbonuses: { default: "T-spins", allowed: oe.SpinRules },
    combotable: {
      default: "multiplier",
      allowed: ["none", "multiplier", "classic guideline", "modern guideline"]
    },
    kickset: {
      default: "SRS+",
      possibles: ["none", "SRS", "SRS+", "TETRA-X", "NRS", "ARS", "ASC"]
    },
    bagtype: { default: "7-bag", allowed: M.BagList },
    messiness_change: { default: 1 },
    messiness_inner: { default: 0 },
    messiness_nosame: { default: false },
    messiness_center: { default: false },
    messiness_timeout: { default: 0 },
    b2bchaining: { default: false },
    b2bcharging: { default: false },
    b2bextras: { default: false },
    b2bcharge_at: { default: 4, integer: true, min: 0, max: 10 },
    b2bcharge_base: { default: 0, integer: true, min: 0, max: 10 },
    allclears: { default: true },
    allclear_garbage: { default: 10, integer: true, min: 0 },
    allclear_b2b: { default: 0, integer: true, min: 0 },
    allclear_b2b_sends: { default: false },
    allclear_b2b_dupes: { default: true },
    allclear_charges: { default: false },
    allow_harddrop: { default: true },
    allow180: { default: false },
    infinite_hold: { default: false },
    infinite_movement: { default: false },
    nextcount: { default: 5, integer: true, min: 1, max: 6 },
    clutch: { default: true },
    no_szo: { default: false },
    nolockout: { default: false },
    manual_allowed: { default: true },
    new_payback: { default: false },
    can_undo: { default: false },
    boardwidth: { default: 10, min: 4, max: 100 },
    boardheight: { default: 20, min: 1, max: 100 },
    boardbuffer: { default: 20, min: 0, max: 100 },
    stock: { default: 0, min: 0, max: 10 },
    infinite_stock: { default: false },
    locktime: { default: 30 },
    lockresets: { default: 15, min: 0, max: 30 },
    prestart: { default: 0 },
    precountdown: { default: 0 },
    countdown: { default: false },
    countdown_count: { default: 3 },
    countdown_interval: { default: 1e3 },
    inverted: { default: false },
    mission: { default: "" },
    mission_type: {
      default: "mission",
      allowed: ["mission", "mission_free", "mission_versus", "mission_league"]
    },
    no_mission_sound: { default: false },
    objective_type: { default: "none", allowed: ["none", "lines", "timed"] },
    objective_count: { default: 0 },
    objective_time: { default: 0 },
    objective_result: { default: "", allowed: ["", "score", "time", "lines"] },
    zoominto: {
      default: "none",
      allowed: ["none", "slow", "fast", "cinematic", "fade", "zenithduoleft"]
    },
    noextrawidth: { default: false },
    stride: { default: false },
    pro: { default: false },
    pro_alert: { default: false },
    pro_retry: { default: false },
    can_retry: { default: false },
    slot_counter1: { default: "", allowed: ["", ...H.DisplayCountersList] },
    slot_counter2: { default: "", allowed: ["", ...H.DisplayCountersList] },
    slot_counter3: { default: "", allowed: ["", ...H.DisplayCountersList] },
    slot_counter4: { default: "", allowed: ["", ...H.DisplayCountersList] },
    slot_counter5: { default: "", allowed: ["", ...H.DisplayCountersList] },
    slot_bar1: { default: "", allowed: ["", "impending", "progress"] },
    slot_bar2: { default: "", allowed: ["", "impending", "progress"] },
    absolute_lines: { default: false },
    display_zen: { default: false },
    display_username: { default: false },
    display_fire: { default: false },
    display_replay: { default: false },
    display_next: { default: true },
    display_hold: { default: true },
    display_shadow: { default: true },
    levels: { default: false },
    masterlevels: { default: false },
    startinglevel: { default: 1 },
    levelspeed: { default: 1 },
    levelstatic: { default: false },
    levelstaticspeed: { default: 10 },
    levelgbase: { default: 0.8 },
    levelgspeed: { default: 0.007 },
    minoskin: {
      default: {
        z: "tetrio",
        l: "tetrio",
        o: "tetrio",
        s: "tetrio",
        i: "tetrio",
        j: "tetrio",
        t: "tetrio",
        other: "tetrio",
        ghost: "tetrio"
      }
    },
    boardskin: { default: "generic", possibles: ["generic", "tetrio"] },
    map: { default: "" },
    handling: { default: {} },
    room_handling: { default: false },
    room_handling_arr: { default: 2 },
    room_handling_das: { default: 10 },
    room_handling_sdf: { default: 6 },
    noreplay: { default: false },
    nosound: { default: false },
    bgmnoreset: { default: false },
    neverstopbgm: { default: false },
    song: {
      default: "RANDOMcalm",
      possibles: ["none", "RANDOM", "RANDOMcalm", "RANDOMbattle"]
    },
    survivalmode: { default: "none", allowed: ["none", "layer", "timer"] },
    survival_messiness: { default: 0 },
    survival_layer_amt: { default: 10 },
    survival_layer_non: { default: false },
    survival_layer_min: { default: 0 },
    survival_timer_itv: { default: 1 },
    survival_cap: { default: 0 },
    invisible: { default: false },
    master_invisible: { default: false },
    void_holes: { default: 0, integer: true, min: 0, max: 15 },
    void_holes_hungryness: { default: 12, integer: true, min: 1 },
    tutorial: { default: false },
    usezenconfig: { default: false },
    zenlevels: { default: false },
    zenlevel: { default: 1 },
    zenprogress: { default: 0 },
    nosiren: { default: false },
    anchorseed: { default: false },
    forfeit_time: { default: 60 },
    username: { default: "" },
    latencymode: {
      default: "medium",
      allowed: ["zero", "low", "medium", "high", "xhigh"]
    },
    fulloffset: { default: 300 },
    fullinterval: { default: 300 },
    fromretry: { default: false },
    retryisclear: { default: false },
    topoutisclear: { default: false },
    zenith: { default: false },
    zenith_expert: { default: false },
    zenith_doublehole: { default: false },
    zenith_volatile: { default: false },
    zenith_gravity: { default: false },
    zenith_messy: { default: false },
    zenith_allspin: { default: false },
    zenith_duo: { default: false },
    zenith_mods: { default: [], allowed: be.Mods },
    zenith_ally: { default: [] },
    zenith_allyexpert: { default: false },
    TEMP_zenith_rng: { default: false },
    TEMP_zenith_grace: { default: "" }
  };
  static DeprecatedOptions = [
    "garbagequadbonus",
    "garbagespinbonus",
    "garbageaspinbonus"
  ];
  static localGameID = 0;
  static init() {
    this.OptionsTemplate = {};
    for (const [e, t] of Object.entries(this.OptionsList)) {
      this.OptionsTemplate[e] = t.default;
      const n = x(t.default);
      switch (n) {
        case "boolean":
        case "number":
        case "array":
        case "object":
          t.type = n;
          break;
        case "string":
          t.type = t.allowed || t.possibles ? "table" : "string";
          break;
        default:
          throw new TypeError(
            `Error while templating ${e}: typeof ${n} is not supported as default values`
          );
      }
    }
  }
  static *ValidateOptions(e) {
    const { OptionsList: n } = this;
    let s = 0;
    for (let [i, o] of Object.entries(e)) {
      if (!(i in n)) {
        if (Ce.DeprecatedOptions.includes(i)) continue;
        const e = `Unknown game option received | key: ${i} -> value: ${o} | Please report this message to the developers!`;
        if ((s++, "production" === _.mode)) {
          console.warn(e);
          continue;
        }
        throw new ReferenceError(e);
      }
      if (typeof o != typeof n[i].default)
        throw new TypeError(
          `Options "${i}" type mismatch | actual: ${typeof o} -> expected: ${typeof n[i].default} | Please report this message to the developers!`
        );
      const { integer: e, min: a, max: r, strict: l } = n[i];
      if (l && (o < a || o > r))
        throw new RangeError(
          `Options "${i}" out of range | actual: ${o} -> expected: ${a} .. ${r} | Please report this message to the developers!`
        );
      ((a || r) && (o = Math.min(r ?? 1 / 0, Math.max(a ?? -1 / 0, o))),
        e && (o = Math.floor(o)),
        (n[i].static ||
          (n[i].default !== o && !strictShallowEqual(n[i].default, o))) &&
          (yield [i, o]));
    }
    s > 0 &&
      on({
        msg: `this replay contains one or more unknown options ${s}`,
        color: "#FFD800",
        icon: "warning",
        timeout: 7500
      });
  }
}
Ce.init();

const n = class Bits {
  static MAX_BITS = Number.MAX_SAFE_INTEGER.toString(2).length;

  constructor(input) {
    if (typeof input === "number") {
      this.buffer = Buffer.alloc(Math.ceil(input / 8));
    } else {
      if (!(input instanceof Buffer)) {
        throw new TypeError(
          "Initialize by specifying a bit-length or referencing a Buffer"
        );
      }
      this.buffer = input;
    }
    this._length = 8 * this.buffer.length;
    this._offset = 0;
  }

  // ---------- Static factory methods ----------
  static alloc(size, fill, encoding) {
    return new Bits(Buffer.alloc(size, fill, encoding));
  }

  static from(data, encoding, length) {
    return new Bits(Buffer.from(data, encoding, length));
  }

  // ---------- Getters / Setters ----------
  get eof() {
    return this._offset === this._length;
  }

  get length() {
    return this._length;
  }

  get offset() {
    return this._offset;
  }

  set offset(val) {
    if (val < 0) throw new RangeError("Cannot set offset below 0");
    if (val > this._length) {
      throw new RangeError(
        `Cannot set offset to ${val}, buffer length is ${this._length}`
      );
    }
    this._offset = Math.floor(val);
    return this;
  }

  get remaining() {
    return this._length - this._offset;
  }

  // ---------- Instance methods ----------
  clear(fill = 0) {
    this.buffer.fill(fill);
    this._offset = 0;
    return this;
  }

  clearBit(pos) {
    this.insert(0, 1, pos);
    return this;
  }

  flipBit(pos) {
    const bit = 1 ^ this.peek(1, pos);
    this.modifyBit(bit, pos);
    return bit;
  }

  getBit(pos) {
    return this.peek(1, pos);
  }

  insert(value, size = 1, offset) {
    let r = typeof offset === "number" ? offset | 0 : this._offset;
    if (r + size > this._length) {
      throw new RangeError(
        `Cannot write ${size} bits, only ${this.remaining} bit(s) left`
      );
    }
    if (size > Bits.MAX_BITS) {
      throw new RangeError(
        `Cannot write ${size} bits, max is ${Bits.MAX_BITS}`
      );
    }

    let remaining = size;
    while (remaining > 0) {
      const byteIndex = r >> 3;
      const bitIndex = r & 7;
      const chunkSize = Math.min(8 - bitIndex, remaining);
      const mask = (1 << chunkSize) - 1;
      const shift = 8 - chunkSize - bitIndex;
      const chunk = ((value >>> (remaining - chunkSize)) & mask) << shift;

      this.buffer[byteIndex] =
        (this.buffer[byteIndex] & ~(mask << shift)) | chunk;

      r += chunkSize;
      remaining -= chunkSize;
    }
    return r;
  }

  modifyBit(value, pos) {
    this.insert(value, 1, pos);
    return this;
  }

  peek(size = 1, offset) {
    let r = typeof offset === "number" ? offset | 0 : this._offset;
    if (r + size > this._length) {
      throw new RangeError(
        `Cannot read ${size} bits, only ${this.remaining} bit(s) left`
      );
    }
    if (size > Bits.MAX_BITS) {
      throw new RangeError(
        `Reading ${size} bits would overflow result, max is ${Bits.MAX_BITS}`
      );
    }

    const bitIndex = r & 7;
    const firstSize = Math.min(8 - bitIndex, size);
    const mask = (1 << firstSize) - 1;

    let result = (this.buffer[r >> 3] >> (8 - firstSize - bitIndex)) & mask;
    r += firstSize;

    let remaining = size - firstSize;
    while (remaining >= 8) {
      result = (result << 8) | this.buffer[r >> 3];
      r += 8;
      remaining -= 8;
    }

    if (remaining > 0) {
      const shift = 8 - remaining;
      result =
        (result << remaining) |
        ((this.buffer[r >> 3] >> shift) & (255 >> shift));
    }

    return result;
  }

  read(size = 1) {
    const value = this.peek(size, this._offset);
    this._offset += size;
    return value;
  }

  seek(val, whence = 1) {
    switch (whence) {
      case 2: // relative
        this.offset += val;
        break;
      case 3: // from end
        this.offset = this.length - val;
        break;
      default: // absolute
        this.offset = val;
    }
    return this;
  }

  setBit(pos) {
    this.insert(1, 1, pos);
    return this;
  }

  skip(size) {
    return this.seek(size, 2);
  }

  testBit(pos) {
    return !!this.peek(1, pos);
  }

  toString(encoding = "utf8") {
    return this.buffer.toString(encoding);
  }

  write(value, size = 1) {
    this._offset = this.insert(value, size, this._offset);
    return this;
  }
};

// const n = Bits;
const ke = {
  int64AsType: "number",
  bundleStrings: false,
  sequential: false
};
const Te = new (class {
  _commands = new Map();
  _codes = new Map();
  _PACK = null;
  _UNPACK = null;
  SymCmd = Symbol("cmd");
  FLAG = {
    F_ALLOC: 1,
    F_HOOK: 2,
    F_ID: 128
  };
  SetMsgpackr(e, t) {
    {
      this._PACK = e.pack.bind(e);
      this._UNPACK = t.unpack.bind(t);
    }
  }
  GetHandlers() {
    const je = [];
    for (const e of this._commands.values()) {
      if (e.flags & this.FLAG.F_HOOK) je.push(e.name);
    }
    const Ve = this._commands.get("__pack__")?.table;
    if (Ve) {
      je.push.apply(je, Object.keys(Ve));
    }
    return je;
  }
  Add(t, n) {
    this._commands.set(t, n);
    this._codes.set(n.code, n);
    n.name = t;
    if (n.flags & this.FLAG.F_ALLOC) {
      n.buffer = Buffer.from([n.code]);
    }
    if (n.table) {
      {
        n._kv = new Map();
        n._vk = new Map();
        n.getkv = (e) => n._kv.get(e);
        n.getvk = (e) => n._vk.get(e);
      }
      for (const [e, t] of Object.entries(n.table)) {
        {
          n._kv.set(e, t);
          n._vk.set(t, e);
        }
      }
    }
  }
  Encode(t, n, s = {}) {
    const i = this._commands.get(t) ?? this._commands.get("__pack__");
    let o = i.code,
      a = 1;
    if (i.flags & this.FLAG.F_ALLOC) return i.buffer;
    if (!s.batched && (i.flags & this.FLAG.F_ID || s.id)) {
      {
        a += 3;
        o |= this.FLAG.F_ID;
      }
    }
    const r = i.encode(n, this._PACK, t),
      l = Buffer.allocUnsafe(a + r.byteLength);
    l.writeUInt8(o, 0);
    l.set(r, a);
    return l;
  }
  Decode(e) {
    const t = new n(e),
      s = t.peek(6, 2),
      i = this._codes.get(s),
      o = {
        command: i?.name
      };
    let a = 1;
    if (!i)
      throw new ReferenceError(
        `received an unknown code [0x${s.toString(16).padStart(2, "0")}]`
      );
    if (i.flags & this.FLAG.F_ALLOC) return o;
    {
      if (e[0] & this.FLAG.F_ID) {
        {
          o.id = t.peek(24, 8);
          a += 3;
        }
      }
      e = e.subarray(a);
    }
    try {
      o.data = i.decode(e, this._UNPACK);
    } catch (t) {
      throw (
        console.error(`Failed to decode command ${i.name}: ${e.toString()}`),
        t
      );
    }
    if (this.SymCmd in o.data) {
      {
        o.command = o.data[this.SymCmd];
        o.data = o.data.data;
      }
    }
    return o;
  }
})();
{
  const { F_ALLOC: t, F_HOOK: n, F_ID: s } = Te.FLAG;
  Te.Add("new", {
    code: 25,
    flags: t
  });
  Te.Add("die", {
    code: 63,
    flags: t
  });
  Te.Add("rejected", {
    code: 19,
    flags: n | t
  });
  {
    Te.Add("reload", {
      code: 33,
      flags: n | t
    });
    Te.Add("ping", {
      code: 9,
      flags: n,
      encode({ recvid: t }) {
        const n = Buffer.allocUnsafe(4);
        n.writeUInt32BE(t, 0);
        return n;
      },
      decode(e) {
        return {
          recvid: e.readUInt32BE(0)
        };
      }
    });
    Te.Add("session", {
      code: 44,
      encode({ ribbonid: t, tokenid: n }) {
        const s = Buffer.allocUnsafe(16);
        s.write(t, 0, 8, "hex");
        s.write(n, 8, 8, "hex");
        return s;
      },
      decode: (e) => ({
        ribbonid: e.toString("hex", 0, 8),
        tokenid: e.toString("hex", 8, 16)
      })
    });
    Te.Add("packets", {
      code: 7,
      encode({ packets: t }) {
        const n = t.reduce((e, t) => e + t.length, 0),
          s = Buffer.allocUnsafe(n + 4 * t.length);
        for (let e = 0, n = 0; e < t.length; e++) {
          const i = t[e];
          {
            s.writeUInt32BE(i.length, n);
            s.set(i, n + 4);
            n += i.length + 4;
          }
        }
        return s;
      },
      decode(e) {
        const t = [];
        for (let n = 0; n < e.length; ) {
          const s = e.readUInt32BE(n);
          n += 4;
          const i = e.subarray(n, n + s);
          {
            t.push(i);
            n += s;
          }
        }
        return {
          packets: t
        };
      }
    });
  }
  Te.Add("kick", {
    table: {
      outdated: 1,
      kick: 2,
      restrict: 3,
      block: 4,
      anticheat: 5,
      manual: 6,
      rename: 7
    },
    flags: n,
    code: 4,
    encode({ reason: t }) {
      let n = Buffer.allocUnsafe(1);
      const s = this.getkv(t);
      n.writeUInt8(s, 0);
      if (!s) {
        n = Buffer.concat([n, Buffer.from(t)]);
      }
      return n;
    },
    decode(e) {
      const t = e.readUInt8(0);
      let n = this.getvk(t);
      if (!n) {
        n = e.toString("utf8", 1);
      }
      return {
        reason: n
      };
    }
  });
  Te.Add("nope", {
    table: {
      "protocol violation": 0,
      "ribbon expired": 1
    },
    code: 42,
    encode({ reason: t }) {
      return Buffer.from([this.getkv(t)]);
    },
    decode(e) {
      const t = e.readUInt8(0);
      return {
        reason: this.getvk(t)
      };
    }
  });
  Te.Add("pni", {
    table: {
      background: 0,
      split: 1,
      load: 2
    },
    code: 51,
    flags: n,
    encode({ type: t, timeout: n }) {
      const s = Buffer.allocUnsafe(3);
      s.writeUInt8(this.getkv(t), 0);
      s.writeUInt16BE(n, 1);
      return s;
    },
    decode(e) {
      return {
        type: this.getvk(e.readUInt8(0)),
        timeout: e.readUInt16BE(1)
      };
    }
  });
  const h = {
    deny: 1,
    warm: 2,
    error: 4,
    announce: 5
  };
  {
    h.ok = 3;
    Te.Add("notify", {
      table: h,
      code: 49,
      flags: n | s,
      encode(t, n) {
        const s = this.getkv(t.type),
          i = Buffer.from([s]);
        switch (s) {
          case 1: {
            const n = Buffer.allocUnsafe(2 + t.msg.length);
            n.writeUInt16BE(t.timeout);
            n.write(t.msg, 2);
            return Buffer.concat([i, n]);
          }
          case 2:
          case 3:
          case 4:
          case 5:
            return Buffer.concat([i, Buffer.from(t.msg)]);
          default:
            return Buffer.concat([i, n(t)]);
        }
      },
      decode(e, t) {
        const n = e.readUInt8(0),
          s = this.getvk(n);
        switch (n) {
          case 1:
            return {
              type: s,
              timeout: e.readUInt16BE(1),
              msg: e.toString("utf8", 3)
            };
          case 2:
          case 3:
          case 4:
          case 5:
            return {
              type: s,
              msg: e.toString("utf8", 1)
            };
          default:
            return t(e.subarray(1));
        }
      }
    });
  }
  Te.Add("__pack__", {
    table: {
      "config.handling": 1,
      "channel.subscribe": 2,
      "channel.unsubscribe": 3,
      "social.presence": 16,
      "social.invite": 17,
      "social.link": 18,
      "social.online": 19,
      "social.notification": 20,
      "social.notification.ack": 21,
      "social.dm": 22,
      "social.dm.fail": 23,
      "social.relation.ack": 24,
      "social.relation.add": 25,
      "social.relation.remove": 26,
      "social.relation.update": 27,
      "social.relation.clear": 28,
      "social.party.invite": 29,
      "social.party.invite.accept": 30,
      "game.enter": 48,
      "game.replace": 49,
      "game.forfeit": 50,
      "game.ready": 51,
      "game.start": 52,
      "game.spectate": 53,
      "game.submit": 54,
      "game.advance": 55,
      "game.abort": 56,
      "game.end": 57,
      "game.score": 58,
      "game.waitstate": 59,
      "game.match": 60,
      "game.match.score": 61,
      "game.replay": 62,
      "game.replay.enter": 63,
      "game.replay.ige": 64,
      "game.replay.state": 65,
      "game.replay.board": 66,
      "game.replay.end": 67,
      "game.scope.start": 68,
      "game.scope.end": 69,
      "game.setspec": 70,
      "game.records.revolved": 71,
      "party.ready": 80,
      "party.leave": 81,
      "party.members": 83,
      "party.sync": 82,
      "staff.chat": 96,
      "staff.spam": 97,
      "staff.warn": 98,
      "staff.silence": 99,
      "staff.lift": 100,
      "staff.kickfail": 101,
      "staff.shout": 102,
      "staff.waterfall": 103,
      "staff.game.event": 104,
      "staff.xrc": 105,
      "room.create": 128,
      "room.join": 129,
      "room.leave": 130,
      "room.abort": 131,
      "room.start": 132,
      "room.kick": 133,
      "room.unban": 134,
      "room.banlist": 135,
      "room.setid": 136,
      "room.setconfig": 137,
      "room.update": 138,
      "room.update.bracket": 139,
      "room.update.host": 140,
      "room.update.auto": 141,
      "room.update.supporter": 142,
      "room.player.add": 143,
      "room.player.remove": 144,
      "room.bracket.switch": 145,
      "room.bracket.move": 146,
      "room.owner.transfer": 147,
      "room.owner.revoke": 148,
      "room.chat": 149,
      "room.chat.send": 150,
      "room.chat.clear": 151,
      "room.chat.delete": 152,
      "room.chat.gift": 153,
      "room.chat.game": 154,
      "room.call": 155,
      "league.enter": 177,
      "league.leave": 178,
      "league.match": 179,
      "league.counts": 180,
      "league.ready": 181,
      "server.maintenance": 208,
      "server.announcement": 209,
      "server.authorize": 210,
      "server.migrate": 211,
      "server.migrated": 212,
      "xrc.relog": 255
    },
    flags: s,
    code: 43,
    encode(t, n, s) {
      const i = n(t),
        o = Buffer.allocUnsafe(1 + i.length),
        a = this.getkv(s);
      o.writeUInt8(a, 0);
      o.set(i, 1);
      return o;
    },
    decode(e, t) {
      const n = e.readUInt8(0),
        s = this.getvk(n),
        i = t(e.subarray(1));
      return {
        [Te.SymCmd]: s,
        data: i
      };
    }
  });
}
class Ee {
  static TYPES = {
    Table: 0,
    Array: 1,
    Struct: 2,
    String: 3,
    Buffer: 4,
    Boolean: 5,
    Int: 6,
    UInt: 7,
    DInt: 8,
    Float: 9,
    UFloat: 10,
    Double: 11,
    Number: 12,
    Any: 13
  };
  static TYPES_INDEX = Array.from(Object.keys(this.TYPES));
  static SUPPORTED_TYPES = new Set([
    "undefined",
    "null",
    "boolean",
    "number",
    "string",
    "array"
  ]);
  static cla32(e) {
    return e >>> 0 === e
      ? Math.max(32 - Math.clz32(e), 1)
      : Math.max(32 - Math.clz32(~e) + 1, 2);
  }
  static GetIntSize(e) {
    return Math.ceil(this.cla32(e) / 4);
  }
  static DInt = class {
    constructor({ min: e, max: t }) {
      {
        this._minBits = e;
        this._maxBits = t;
        this._minSize = Math.pow(2, e);
        this._maxSize = Math.pow(2, t);
      }
    }
    get minSize() {
      return this._minSize;
    }
    get maxSize() {
      return this._maxSize;
    }
    readSize(e) {
      return e ? this._maxBits : this._minBits;
    }
    writeSize(e) {
      let t;
      switch (e) {
        case e >>> 0:
          t = this._minSize <= e;
          break;
        case e | 0:
          t = -this._minSize / 2 > e;
          break;
        default:
          throw new RangeError(
            `Float/Double is not supported for DInt: got ${e}`
          );
      }
      return {
        bit: t,
        size: t ? this._maxBits : this._minBits
      };
    }
  };
  static Number = new (class {
    TYPES = {
      NaN: 0,
      Infinity: 1,
      UInt: 2,
      Int: 3,
      Double: 4
    };
    encode(e, t) {
      const { TYPES: n } = this;
      if ("number" != typeof t)
        throw new TypeError(`Attempted to encode ${typeof t} as a number`);
      if (Number.isNaN(t)) return e.writeUInt(n.NaN, 3);
      if (!Number.isFinite(t)) {
        e.writeUInt(n.Infinity, 3);
        return e.writeBoolean(t === Number.POSITIVE_INFINITY);
      }
      switch (t) {
        case t >>> 0: {
          const s = Ee.GetIntSize(t);
          {
            e.writeUInt(n.UInt, 3);
            e.writeUInt(s - 1, 3);
            e.writeUInt(t, 4 * s);
          }
          break;
        }
        case t | 0: {
          const s = Ee.GetIntSize(t);
          {
            e.writeUInt(n.Int, 3);
            e.writeUInt(s - 1, 3);
            e.writeInt(t, 4 * s);
          }
          break;
        }
        default: {
          e.writeUInt(n.Double, 3);
          e.writeDouble(t);
        }
      }
    }
    decode(e) {
      switch (e.readUInt(3)) {
        case 0:
          return NaN;
        case 1:
          return e.readBoolean()
            ? Number.POSITIVE_INFINITY
            : Number.NEGATIVE_INFINITY;
        case 2: {
          const t = e.readUInt(3) + 1;
          return e.readUInt(4 * t);
        }
        case 3: {
          const t = e.readUInt(3) + 1;
          return e.readInt(4 * t);
        }
        case 4:
          return e.readDouble();
      }
    }
  })();
  static Table = class {
    constructor(e, t = "strict") {
      {
        this._kv = new Map();
        this._vk = new Map();
      }
      for (const [t, n] of e.entries()) {
        {
          this._kv.set(n, t + 1);
          this._vk.set(t + 1, n);
        }
      }
      {
        this._mode = t;
        this._size = Math.floor(Math.log2(this._kv.size)) + 1;
        this.has = this._kv.has.bind(this._kv);
      }
    }
    get mode() {
      return this._mode;
    }
    get size() {
      return this._size;
    }
    get struct() {
      const G = {};
      for (const [e, t] of this._kv.entries())
        G[e] = "0x" + t.toString(16).padStart(2, "0");
      return G;
    }
    getkv(e) {
      return this._kv.get(e);
    }
    getvk(e) {
      return this._vk.get(e);
    }
  };
  static Array = class {
    constructor(e = "default", { list: t, min: n, max: s } = {}) {
      this._mode = e;
      switch (e) {
        case "strict":
          this._table = new Ee.Table(t);
          break;
        case "flexible":
          throw new Error("Flexible mode is not implemented yet");
        case "default":
      }
      {
        n = n ?? 7;
        s = s ?? 15;
      }
      this._prop = new Ee.DInt({
        min: n,
        max: s
      });
    }
    get mode() {
      return this._mode;
    }
    encode(e, t) {
      e.writeDInt(t.length, this._prop);
      switch (this._mode) {
        case "strict":
          for (const n of t) e.writeTable(n, this._table);
          break;
        case "flexible":
          throw new Error("Flexible mode is not implemented yet");
        default:
          for (const n of t) e.writeAny(n, this);
      }
    }
    decode(e) {
      const t = e.readDInt(this._prop),
        n = [];
      if ("strict" === this._mode)
        for (let s = 0; s < t; s++) n.push(e.readTable(this._table));
      else for (let s = 0; s < t; s++) n.push(e.readAny(this));
      return n;
    }
  };
  static init() {
    {
      this.SUPPORTED_TYPES_TABLE = new this.Table(
        Array.from(this.SUPPORTED_TYPES.keys())
      );
      this.DEFAULT_ARRAY = new this.Array();
    }
    this.DEFAULT_PROP = new this.DInt({
      min: 8,
      max: 32
    });
  }
  constructor() {
    {
      this.ref = new Map();
      this.refid = 0;
    }
  }
  static Encoder = class t extends this {
    static TYPES = {
      BUFFER: 1,
      DOUBLE: 2,
      QWORD: 3,
      HEX: 4
    };
    constructor(e = null, t = null) {
      {
        super();
        this._buffer = [];
        this._size = 0;
        this._packr = e;
        this._packBuffer = t;
      }
    }
    get buffer() {
      return this._buffer;
    }
    get size() {
      return this._size;
    }
    get byteLength() {
      return Math.ceil(this._size / 8);
    }
    realign() {
      return (this._size += (8 - (this._size % 8)) % 8);
    }
    _insert(e, t, n = null) {
      if (n) {
        this.realign();
      }
      this._size += t;
      return this._buffer.push({
        val: e,
        size: t,
        type: n
      });
    }
    writeTable(e, t) {
      if ("strict" === t.mode) return this._insert(t.getkv(e), t.size);
      const n = t.getkv(e);
      return undefined === n
        ? (this._insert(null, t.size), this.writeAny(e))
        : this._insert(n, t.size);
    }
    writeArray(e, t = Ee.DEFAULT_ARRAY) {
      return "strict" === t.mode
        ? t.encode(this, e)
        : this.ref.has(e)
          ? (this._insert(true, 1),
            this.writeDInt(this.ref.get(e), Ee.DEFAULT_PROP))
          : (this._insert(false, 1),
            this.ref.set(e, this.refid++),
            t.encode(this, e));
    }
    writeStruct(e, t) {
      return t.encode(this, e);
    }
    writeString(n, s = true) {
      n = Buffer.from(s ? `${n}\0` : n);
      return this._insert(n, 8 * n.byteLength, t.TYPES.BUFFER);
    }
    writeBuffer(e) {
      return this._insert(e, 8 * e.byteLength, t.TYPES.BUFFER);
    }
    writeBoolean(e) {
      return this._insert(!!e, 1);
    }
    writeInt(e, t) {
      return this._insert(e, t);
    }
    writeUInt(e, t) {
      return this._insert(e, t);
    }
    writeUInt64(e) {
      return this._insert(e, 64, t.TYPES.QWORD);
    }
    writeDInt(e, t) {
      const n = t.writeSize(e);
      this._insert(n.bit, 1);
      return this._insert(e, n.size);
    }
    writeFloat(e, t, n) {
      this._insert(e < 0, 1);
      return this._insert(Math.round(e * n), t);
    }
    writeUFloat(e, t, n) {
      return this._insert(Math.round(e * n), t);
    }
    writeDouble(e) {
      return this._insert(e, 64, t.TYPES.DOUBLE);
    }
    writeNumber(e) {
      return Ee.Number.encode(this, e);
    }
    writeHex(e, n) {
      return this._insert(e, n * 8, t.TYPES.HEX);
    }
    writeAny(e, t) {
      const n = x(e);
      if (!Ee.SUPPORTED_TYPES.has(n))
        throw new TypeError(
          `Type ${n} is not implemented for NetCodec.TYPES.Any`
        );
      this.writeTable(n, Ee.SUPPORTED_TYPES_TABLE);
      switch (n) {
        case "boolean":
          this.writeBoolean(e);
          break;
        case "null":
        case "undefined":
          break;
        case "number":
          Ee.Number.encode(this, e);
          break;
        case "string":
          this.writeString(e);
          break;
        case "array":
          this.writeArray(e, t);
      }
    }
    writeByType(e, t, ...n) {
      return this[`write${Ee.TYPES_INDEX[e]}`](t, ...n);
    }
    pack(e) {
      this._packr.useBuffer(this._packBuffer);
      const n = this._packr.pack(e);
      return this._insert(n, 8 * n.byteLength, t.TYPES.BUFFER);
    }
    finalize(s = null) {
      const i = s ?? Buffer.allocUnsafe(this.byteLength),
        o = new n(i);
      for (const { val: e, size: n, type: s } of this._buffer)
        switch (s) {
          case t.TYPES.BUFFER:
            {
              o.offset += (8 - (o.offset % 8)) % 8;
              i.set(e, o.offset / 8);
              o.seek(8 * e.byteLength, 2);
            }
            break;
          case t.TYPES.DOUBLE:
            {
              o.offset += (8 - (o.offset % 8)) % 8;
              i.writeDoubleBE(e, o.offset / 8);
              o.seek(64, 2);
            }
            break;
          case t.TYPES.QWORD:
            {
              o.offset += (8 - (o.offset % 8)) % 8;
              i.writeBigUInt64BE(e, o.offset / 8);
              o.seek(64, 2);
            }
            break;
          case t.TYPES.HEX:
            {
              o.offset += (8 - (o.offset % 8)) % 8;
              i.write(e, o.offset / 8, "hex");
              o.seek(n, 2);
            }
            break;
          default:
            o.write(e, n);
        }
      return i;
    }
  };
  static Decoder = class e extends this {
    static _MAX_BITS = Math.log2(Number.MAX_SAFE_INTEGER);
    static _MAX_BITS_SIGNED = 32;
    constructor(e, t = null) {
      {
        super();
        this._bits = new n(e);
        this._unpack = t;
      }
    }
    get length() {
      return this._bits.length;
    }
    get offset() {
      return this._bits.offset;
    }
    set offset(e) {
      this._bits.offset = e;
    }
    get buffer() {
      return this._bits.buffer;
    }
    get byteOffset() {
      return Math.ceil(this.offset / 8);
    }
    realign() {
      this.offset = 8 * this.byteOffset;
    }
    _read_signed(t) {
      const n = e._MAX_BITS_SIGNED - t;
      return (this._read(t) << n) >> n;
    }
    _read(e) {
      return this._bits.read(e);
    }
    readTable(e) {
      const t = e.size;
      return 0 !== this.peek(t)
        ? e.getvk(this._read(t))
        : (this.seek(t, 2), this.readAny());
    }
    readArray(e = Ee.DEFAULT_ARRAY) {
      if ("strict" === e.mode) return e.decode(this);
      if (this._read(1)) return this.ref.get(this.readDInt(Ee.DEFAULT_PROP));
      const t = [];
      this.ref.set(this.refid++, t);
      t.push.apply(t, e.decode(this));
      return t;
    }
    readStruct(e) {
      return e.decode(this);
    }
    readString(e) {
      const t = this.byteOffset;
      let n;
      "number" == typeof e
        ? ((n = t + e), this.seek(8 * n))
        : ((n = this.buffer.indexOf(0, t)), this.seek(8 * (n + 1)));
      return this.buffer.toString("utf8", t, n);
    }
    readBuffer(e) {
      const t = this.byteOffset,
        n = t + e;
      this.seek(8 * n);
      return this.buffer.subarray(t, n);
    }
    readBoolean() {
      return !!this._read(1);
    }
    readInt(t) {
      if (t > e._MAX_BITS_SIGNED)
        throw new RangeError(
          `${t} of bits is not supported for signed values, max is ${e._MAX_BITS_SIGNED}`
        );
      return this._read_signed(t);
    }
    readUInt(t) {
      if (t > e._MAX_BITS)
        throw new RangeError(
          `${t} of bits is not supported, max is ${e._MAX_BITS}`
        );
      return this._read(t);
    }
    readUInt64() {
      const e = this.byteOffset;
      this.seek(8 * e + 64);
      return this.buffer.readBigUInt64BE(e);
    }
    readDInt(e, t = false) {
      const n = e.readSize(this._read(1));
      return t ? this._read_signed(n) : this._read(n);
    }
    readFloat(e, t) {
      return this.peek(1) ? this._read_signed(e + 1) / t : this._read(e) / t;
    }
    readUFloat(e, t) {
      return this._read(e) / t;
    }
    readDouble() {
      const e = this.byteOffset;
      this.seek(8 * e + 64);
      return this.buffer.readDoubleBE(e);
    }
    readNumber() {
      return Ee.Number.decode(this);
    }
    readHex(e) {
      const t = this.byteOffset,
        n = t + e;
      this.seek(8 * n);
      return this.buffer.toString("hex", t, n);
    }
    readAny(e) {
      switch (this.readTable(Ee.SUPPORTED_TYPES_TABLE)) {
        case "boolean":
          return this.readBoolean();
        case "null":
          return null;
        case "undefined":
          return;
        case "number":
          return Ee.Number.decode(this);
        case "string":
          return this.readString();
        case "array":
          return this.readArray(e);
      }
    }
    readByType(e, ...t) {
      return this[`read${Ee.TYPES_INDEX[e]}`](...t);
    }
    peek(e, t) {
      return this._bits.peek(e, t);
    }
    peekTable(e, t = this.offset) {
      return e.getvk(this.peek(e.size, t));
    }
    peekDInt(e, t = this.offset) {
      return this.peek(e.readSize(this.peek(1, t)), t + 1);
    }
    seek(e, t) {
      this._bits.seek(e, t);
    }
    unpack() {
      this.realign();
      return this._unpack(this.byteOffset);
    }
  };
}
class De {
  static _MAX_BUFFER = 65536;
  static BUFFER = Buffer.alloc(this._MAX_BUFFER);
  static _LIST = {};
  static get LIST() {
    return this._LIST;
  }
  static AddExtension(t, n = {}) {
    this._LIST[t.name] = t;
    if ("ownBuffer" in n) {
      t.BUFFER = Buffer.alloc(this._MAX_BUFFER);
    }
  }
  static AddTable(e, t, n) {
    this["$$" + e] = new Ee.Table(t, n);
  }
  static AddProperty(e, t) {
    this["$" + e] = new Ee.DInt(t);
  }
  static LoadExtensions(e) {
    let S = 10;
    function z(e) {
      return e.encode.call(e, new Ee.Encoder(this, e.constructor.BUFFER));
    }
    function I(e, t, n, s) {
      return e.decode(new Ee.Decoder(t, (e) => n(s + e)));
    }
    for (const t of Object.values(this._LIST)) {
      {
        t.ext_code = S++;
        e.addExtension({
          Class: t,
          type: t.ext_code,
          pack: z,
          unpack: I.bind(null, t)
        });
      }
    }
  }
}
class We extends De {
  static AddStructure(e) {
    {
      this._cstFields = new Map();
      this._fixFields = new Map();
      this._optFields = new Map();
    }
    for (const [t, { mode: n, type: s, size: i, value: o }] of Object.entries(
      e
    ))
      switch (n) {
        case "static":
          this._cstFields.set(t, o);
          break;
        case "fixed":
          this._fixFields.set(t, {
            type: s,
            size: i
          });
          break;
        case "optional":
          this._optFields.set(t, {
            type: s,
            size: i
          });
      }
    super.AddTable("prop", Array.from(this._optFields.keys()));
  }
  static encode(e, t) {
    for (const [n, { type: s, size: i }] of this._fixFields.entries())
      e.writeByType(s, t[n], i);
    for (const [n, { type: s, size: i }] of this._optFields.entries())
      if (undefined !== t[n] && !(s === Ee.TYPES.DInt && null === t[n])) {
        {
          e.writeTable(n, this.$$prop);
          e.writeByType(s, t[n], i);
        }
      }
    e.writeUInt(null, this.$$prop.size);
  }
  static decode(e) {
    const t = {},
      n = this.$$prop.size;
    for (const [n, { type: s, size: i }] of this._fixFields.entries())
      t[n] = e.readByType(s, i);
    for (let s = e.peek(n); 0 !== s; s = e.peek(n)) {
      const n = e.readTable(this.$$prop),
        { type: s, size: i } = this._optFields.get(n),
        o = e.readByType(s, i);
      t[n] = o;
    }
    for (const [e, n] of this._cstFields.entries()) t[e] = n;
    return t;
  }
}
class Oe extends De {
  static init() {
    super.AddExtension(this);
    super.AddProperty("prov", {
      min: 18,
      max: 26
    });
  }
  static decode(e) {
    return new this(e.readUInt(13), e.readDInt(this.$prov), e.unpack());
  }
  constructor(e, t, n) {
    {
      super();
      this.gameid = e;
      this.provisioned = t;
      this.frames = n.map((e) => new Re(e));
    }
  }
  encode(e) {
    const t = this.constructor,
      n = this.provisioned;
    e.writeUInt(this.gameid, 13);
    e.writeDInt(n, t.$prov);
    e.pack(this.frames);
    return e.finalize();
  }
}
class Pe extends De {
  static init() {
    super.AddExtension(this);
    super.AddProperty("long", {
      min: 16,
      max: 32
    });
  }
  static decode(e) {
    const t = [],
      n = e.readUInt(13);
    for (let s = 0; s < n; s++) {
      const n = {
        board: {}
      };
      {
        n.gameid = e.readUInt(13);
        n.board.f = e.readUInt(10);
        n.board.g = e.readDInt(this.$long);
        n.board.w = e.readUInt(Ge.MAX_WIDTH);
        n.board.h = e.readUInt(Ge.MAX_HEIGHT);
        n.board.b = e.readStruct(Ge);
        t[s] = n;
      }
    }
    return new this(t);
  }
  constructor(e) {
    {
      super();
      this.boards = e;
    }
  }
  encode(e) {
    const t = this.constructor;
    e.writeUInt(this.boards.length, 13);
    for (const {
      gameid: n,
      board: { b: s, f: i, g: o, w: a, h: r }
    } of this.boards) {
      e.writeUInt(n, 13);
      e.writeUInt(i, 10);
      e.writeDInt(o, t.$long);
      e.writeUInt(a, Ge.MAX_WIDTH);
      e.writeUInt(r, Ge.MAX_HEIGHT);
      e.writeStruct(s, Ge);
    }
    return e.finalize();
  }
}
class He extends De {
  static init() {
    {
      super.AddExtension(this);
      super.AddTable("extraStat", [
        "none",
        "revives",
        "escapeartist",
        "blockrationing_app",
        "blockrationing_final",
        "talentless"
      ]);
    }
  }
  static decode(e) {
    const t = [],
      n = e.readUInt(13);
    for (let s = 0; s < n; s++) {
      const n = {
        stats: {},
        allies: []
      };
      {
        t[s] = n;
        n.gameid = e.readUInt(13);
        n.stats.rank = e.readUInt(6);
        n.stats.altitude = e.readFloat(18, 10);
        n.stats.btb = e.readUInt(13);
        n.specCount = e.readUInt(10);
        n.speedrun = e.readBoolean();
        n.nearWR = e.readBoolean();
      }
      const i = e.readUInt(3);
      for (let t = 0; t < i; t++) n.allies.push(e.readUInt(13));
      {
        n.stats.revives = 0;
        n.stats.escapeartist = 0;
        n.stats.blockrationing_app = 0;
        n.stats.blockrationing_final = 0;
      }
      switch (e.readTable(this.$$extraStat)) {
        case "none":
          break;
        case "revives":
          n.stats.revives = e.readUInt(8);
          break;
        case "escapeartist":
          n.stats.escapeartist = e.readUInt(9);
          break;
        case "blockrationing_app":
          n.stats.blockrationing_app = e.readFloat(10, 100);
          break;
        case "blockrationing_final":
          n.stats.blockrationing_final = e.readUInt(11);
          break;
        case "talentless":
          n.talentless = true;
      }
    }
    return new this(t);
  }
  constructor(e) {
    {
      super();
      this.sb = e;
    }
  }
  encode(e) {
    const t = this.constructor;
    e.writeUInt(this.sb.length, 13);
    for (const {
      gameid: n,
      stats: s,
      allies: i,
      specCount: o,
      speedrun: a,
      nearWR: r,
      talentless: l
    } of this.sb) {
      e.writeUInt(n, 13);
      e.writeUInt(Math.floor(s.rank), 6);
      e.writeFloat(s.altitude.toFixed(2), 18, 10);
      e.writeUInt(s.btb, 13);
      e.writeUInt(o, 10);
      e.writeBoolean(a);
      e.writeBoolean(r);
      if (i) {
        e.writeUInt(i.length, 3);
        for (const t of i) e.writeUInt(t, 13);
      } else e.writeUInt(0, 3);
      let c = "none";
      if (s.revives) {
        c = "revives";
      }
      if (s.escapeartist) {
        c = "escapeartist";
      }
      if (s.blockrationing_app) {
        c = "blockrationing_app";
      }
      if (s.blockrationing_final) {
        c = "blockrationing_final";
      }
      if (l) {
        c = "talentless";
      }
      e.writeTable(c, t.$$extraStat);
      switch (c) {
        case "none":
        case "talentless":
          break;
        case "revives":
          e.writeUInt(s.revives, 8);
          break;
        case "escapeartist":
          e.writeUInt(s.escapeartist, 9);
          break;
        case "blockrationing_app":
          e.writeFloat(s.blockrationing_app.toFixed(3), 10, 100);
          break;
        case "blockrationing_final":
          e.writeUInt(s.blockrationing_final, 11);
      }
    }
    return e.finalize();
  }
}
class Re extends De {
  static init() {
    super.AddExtension(this, {
      ownBuffer: true
    });
    {
      super.AddProperty("frame", {
        min: 18,
        max: 26
      });
      super.AddTable("type", [
        "keydown",
        "keyup",
        "start",
        "full",
        "end",
        "ige",
        "strategy",
        "manual_target"
      ]);
      super.AddTable("key", [
        "moveLeft",
        "moveRight",
        "rotate180",
        "rotateCCW",
        "rotateCW",
        "softDrop",
        "hardDrop",
        "undo",
        "redo",
        "hold",
        "retry",
        "exit"
      ]);
    }
  }
  static decode(e) {
    const t = {};
    t.type = e.readTable(this.$$type);
    t.frame = e.readDInt(this.$frame);
    switch (t.type) {
      case "keydown":
      case "keyup": {
        const n = e.readTable(this.$$key),
          s = e.readBoolean(),
          i = {
            key: n,
            subframe: e.readFloat(4, 10)
          };
        {
          if (s) {
            i.hoisted = true;
          }
          t.data = i;
        }
        break;
      }
      case "start":
        t.data = {};
        break;
      case "full":
        t.data = e.readStruct($e);
        break;
      case "end":
        t.data = e.readStruct(nt);
        break;
      case "ige":
        t.data = e.readStruct(je);
        break;
      case "strategy":
        t.data = e.readUInt(3);
        break;
      case "manual_target":
        t.data = e.readUInt(13);
        break;
      default:
        t.data = e.unpack();
    }
    return new this(t);
  }
  constructor(e) {
    {
      super();
      this.type = e.type;
      this.frame = e.frame;
      this.data = e.data;
    }
  }
  encode(e) {
    const t = this.constructor;
    e.writeTable(this.type, t.$$type);
    e.writeDInt(this.frame, t.$frame);
    switch (this.type) {
      case "keydown":
      case "keyup": {
        const n = this.data.hoisted,
          s = this.data.subframe;
        e.writeTable(this.data.key, t.$$key);
        e.writeBoolean(n);
        e.writeFloat(s, 4, 10);
        return e.finalize();
      }
      case "start":
        return e.finalize();
      case "full": {
        e.writeStruct(this.data, $e);
        return e.finalize();
      }
      case "end": {
        e.writeStruct(this.data, nt);
        return e.finalize();
      }
      case "ige": {
        e.writeStruct(this.data, je);
        return e.finalize();
      }
      case "strategy": {
        e.writeUInt(this.data, 3);
        return e.finalize();
      }
      case "manual_target": {
        e.writeUInt(this.data, 13);
        return e.finalize();
      }
      default: {
        console.warn(
          `Fallback to packer ${this.type} -> ${JSON.stringify(this.data)}`
        );
        e.pack(this.data);
        return e.finalize();
      }
    }
  }
}
class Ne extends De {
  static init() {
    super.AddExtension(this);
  }
  static decode(e) {
    const t = [],
      n = e.readUInt(13);
    for (let s = 0; s < n; s++) {
      const n = {};
      {
        n.userid = e.readHex(12);
        n.gameid = e.readUInt(13);
        n.alive = e.readBoolean();
        n.naturalorder = e.readUInt(13);
        n.options = e.readStruct(et);
        t.push(n);
      }
    }
    return t;
  }
  constructor(e) {
    {
      super();
      this.players = e;
    }
  }
  encode(e) {
    e.writeUInt(this.players.length, 13);
    for (const {
      gameid: t,
      userid: n,
      alive: s,
      naturalorder: i,
      options: o
    } of this.players) {
      e.writeHex(n, 12);
      e.writeUInt(t, 13);
      e.writeBoolean(s);
      e.writeUInt(i, 13);
      e.writeStruct(o, et);
    }
    return e.finalize();
  }
}
class $e extends De {
  static init() {
    {
      super.AddTable(
        "piece",
        [null, ...Object.keys(L.tetrominoes)],
        "flexible"
      );
      super.AddTable("ixs", ["off", "hold", "tap"]);
    }
  }
  static encode(e, t) {
    const n = t.game.board,
      s = t.game.bag,
      i = t.game.hold,
      o = t.game.g,
      a = t.game.controlling,
      r = t.game.falling,
      l = t.game.handling;
    e.writeUInt(s.length, 12);
    for (const t of s) e.writeTable(t, this.$$piece);
    {
      e.writeStruct(n, Ge);
      e.writeBoolean(i.locked);
      e.writeTable(i.piece, this.$$piece);
      e.writeDouble(o);
      e.writeBoolean(a.inputSoftdrop);
      e.writeBoolean(-1 === a.lastshift);
      e.writeBoolean(a.lShift.held);
      e.writeBoolean(a.rShift.held);
      e.writeUInt(t.diyusi, 4);
      e.writeDouble(a.lShift.arr);
      e.writeDouble(a.rShift.arr);
      e.writeDouble(a.lShift.das);
      e.writeDouble(a.rShift.das);
      e.writeStruct(r, Ue);
      e.writeFloat(l.arr, 6, 10);
      e.writeUInt(l.sdf, 6);
      e.writeBoolean(l.safelock);
      e.writeBoolean(l.cancel);
      e.writeBoolean(l.may20g);
      e.writeBoolean(t.game.playing);
      e.writeFloat(l.das, 8, 10);
      e.writeFloat(l.dcd, 8, 10);
      e.writeTable(l.irs, this.$$ixs);
      e.writeTable(l.ihs, this.$$ixs);
      e.writeStruct(t.stats, Xe);
    }
  }
  static decode(e) {
    const t = {},
      n = {
        bag: [],
        controlling: {
          lShift: {
            dir: -1
          },
          rShift: {
            dir: 1
          }
        },
        handling: {}
      },
      s = n.controlling,
      i = n.handling,
      o = e.readUInt(12);
    for (let t = 0; t < o; t++) n.bag.push(e.readTable(this.$$piece));
    n.board = e.readStruct(Ge);
    n.hold = {
      locked: e.readBoolean(),
      piece: e.readTable(this.$$piece)
    };
    n.g = e.readDouble();
    s.inputSoftdrop = e.readBoolean();
    s.lastshift = e.readBoolean() ? -1 : 1;
    s.lShift.held = e.readBoolean();
    s.rShift.held = e.readBoolean();
    t.diyusi = e.readUInt(4);
    s.lShift.arr = e.readDouble();
    s.rShift.arr = e.readDouble();
    s.lShift.das = e.readDouble();
    s.rShift.das = e.readDouble();
    n.falling = e.readStruct(Ue);
    i.arr = e.readFloat(6, 10);
    i.sdf = e.readUInt(6);
    i.safelock = e.readBoolean();
    i.cancel = e.readBoolean();
    i.may20g = e.readBoolean();
    n.playing = e.readBoolean();
    i.das = e.readFloat(8, 10);
    i.dcd = e.readFloat(8, 10);
    i.irs = e.readTable(this.$$ixs);
    i.ihs = e.readTable(this.$$ixs);
    t.stats = e.readStruct(Xe);
    t.game = n;
    return t;
  }
}
class Ge extends De {
  static MAX_WIDTH = Math.log2(512);
  static MAX_HEIGHT = Math.log2(512);
  static init() {
    super.AddTable("blk", [false, null, ...L.minocolors]);
  }
  static encode(e, t) {
    const n = t[0]?.length ?? 0,
      s = t.length;
    if (!n) return e.writeUInt(0, this.MAX_WIDTH);
    {
      e.writeUInt(n, this.MAX_WIDTH);
      e.writeUInt(s, this.MAX_HEIGHT);
    }
    for (const n of t)
      if (n.some((e) => null !== e))
        for (const t of n) e.writeTable(t, this.$$blk);
      else e.writeTable(false, this.$$blk);
  }
  static decode(e) {
    const t = [],
      n = e.readUInt(this.MAX_WIDTH);
    if (!n) return t;
    const s = e.readUInt(this.MAX_HEIGHT);
    for (let i = 0; i < s; i++)
      if (false !== e.peekTable(this.$$blk)) {
        t[i] = [];
        for (let s = 0; s < n; s++) t[i][s] = e.readTable(this.$$blk);
      } else {
        e.seek(4, 2);
        t[i] = new Array(n).fill(null);
      }
    return t;
  }
}
class Ue extends De {
  static init() {
    super.AddTable("piece", [null, ...Object.keys(L.tetrominoes)], "flexible");
  }
  static encode(e, t) {
    e.writeTable(t.type, this.$$piece);
    e.writeInt(t.x, Ge.MAX_WIDTH);
    e.writeUInt(t.r, 2);
    e.writeUInt(t.hy, Ge.MAX_HEIGHT);
    e.writeUInt(t.irs, 2);
    e.writeUInt(t.kick, 5);
    e.writeUInt(t.keys, 16);
    e.writeUInt(t.flags, 15);
    e.writeUInt(t.safelock, 3);
    e.writeUInt(t.lockresets, 5);
    e.writeUInt(t.rotresets, 6);
    e.writeBoolean(t.skip.length);
    if (t.skip.length) {
      for (const n of t.skip) e.writeUInt(n + 1, 7);
      e.writeUInt(0, 7);
    }
    {
      e.writeDouble(t.y);
      e.writeDouble(t.locking);
    }
  }
  static decode(e) {
    const t = {};
    t.type = e.readTable(this.$$piece);
    t.x = e.readInt(Ge.MAX_WIDTH);
    t.r = e.readUInt(2);
    t.hy = e.readUInt(Ge.MAX_HEIGHT);
    t.irs = e.readUInt(2);
    t.kick = e.readUInt(5);
    t.keys = e.readUInt(16);
    t.flags = e.readUInt(15);
    t.safelock = e.readUInt(3);
    t.lockresets = e.readUInt(5);
    t.rotresets = e.readUInt(6);
    t.skip = [];
    if (e.readBoolean()) {
      const n = 7;
      for (let s = e.peek(n); 0 !== s; s = e.peek(n))
        t.skip.push(e.readUInt(n) - 1);
      e.seek(n, 2);
    }
    t.y = e.readDouble();
    t.locking = e.readDouble();
    return t;
  }
}
class Xe extends De {
  static init() {
    super.AddTable("piece", [...Object.keys(L.tetrominoes)], "flexible");
    super.AddProperty("short", {
      min: 8,
      max: 16
    });
    {
      super.AddProperty("long", {
        min: 16,
        max: 32
      });
      this._clears = [
        "singles",
        "doubles",
        "triples",
        "quads",
        "pentas",
        "realtspins",
        "minitspins",
        "minitspinsingles",
        "tspinsingles",
        "minitspindoubles",
        "tspindoubles",
        "minitspintriples",
        "tspintriples",
        "minitspinquads",
        "tspinquads",
        "tspinpentas",
        "allclear"
      ];
    }
  }
  static encode(e, t) {
    const n = t.garbage,
      s = t.clears,
      i = t.finesse;
    {
      e.writeDInt(t.lines, this.$short);
      e.writeDInt(t.level_lines, this.$short);
      e.writeDInt(t.level_lines_needed, this.$short);
      e.writeDInt(t.inputs, this.$long);
      e.writeDInt(t.holds, this.$long);
      e.writeDInt(t.score, this.$long);
      e.writeUInt(t.level, 8);
      e.writeDInt(t.combo, this.$long);
      e.writeDInt(t.topcombo, this.$long);
      e.writeUInt(t.combopower, 3);
      e.writeDInt(t.btb, this.$short);
      e.writeDInt(t.topbtb, this.$short);
      e.writeUInt(t.btbpower, 8);
      e.writeDInt(t.tspins, this.$long);
      e.writeDInt(t.piecesplaced, this.$long);
    }
    for (const t of this._clears) e.writeDInt(s[t], this.$short);
    {
      e.writeDInt(n.sent, this.$long);
      e.writeDInt(n.sent_nomult, this.$long);
      e.writeDInt(n.maxspike, this.$long);
      e.writeDInt(n.maxspike_nomult, this.$long);
      e.writeDInt(n.received, this.$long);
      e.writeDInt(n.attack, this.$long);
      e.writeDInt(n.cleared, this.$long);
      e.writeDInt(t.kills, this.$short);
      e.writeDInt(i.combo, this.$long);
      e.writeDInt(i.faults, this.$long);
      e.writeDInt(i.perfectpieces, this.$long);
      e.writeStruct(t.zenith, qe);
    }
  }
  static decode(e) {
    const t = {
      zenlevel: 1,
      zenprogress: 0,
      clears: {},
      garbage: {},
      finesse: {}
    };
    {
      t.lines = e.readDInt(this.$short);
      t.level_lines = e.readDInt(this.$short);
      t.level_lines_needed = e.readDInt(this.$short);
      t.inputs = e.readDInt(this.$long);
      t.holds = e.readDInt(this.$long);
      t.score = e.readDInt(this.$long);
      t.level = e.readUInt(8);
      t.combo = e.readDInt(this.$long);
      t.topcombo = e.readDInt(this.$long);
      t.combopower = e.readUInt(3);
      t.btb = e.readDInt(this.$short);
      t.topbtb = e.readDInt(this.$short);
      t.btbpower = e.readUInt(8);
      t.tspins = e.readDInt(this.$long);
      t.piecesplaced = e.readDInt(this.$long);
    }
    for (const n of this._clears) t.clears[n] = e.readDInt(this.$short);
    t.garbage.sent = e.readDInt(this.$long);
    t.garbage.sent_nomult = e.readDInt(this.$long);
    t.garbage.maxspike = e.readDInt(this.$long);
    t.garbage.maxspike_nomult = e.readDInt(this.$long);
    t.garbage.received = e.readDInt(this.$long);
    t.garbage.attack = e.readDInt(this.$long);
    t.garbage.cleared = e.readDInt(this.$long);
    t.kills = e.readDInt(this.$short);
    t.finesse.combo = e.readDInt(this.$long);
    t.finesse.faults = e.readDInt(this.$long);
    t.finesse.perfectpieces = e.readDInt(this.$long);
    t.zenith = e.readStruct(qe);
    return t;
  }
}
class qe extends De {
  static init() {
    super.AddProperty("long", {
      min: 16,
      max: 32
    });
  }
  static encode(e, t) {
    {
      e.writeDouble(t.altitude);
      e.writeDouble(t.rank);
      e.writeDouble(t.peakrank);
      e.writeDouble(t.avgrankpts);
      e.writeDouble(t.totalbonus);
      e.writeFloat(t.targetingfactor, 16, 100);
      e.writeFloat(t.targetinggrace, 16, 100);
      e.writeUInt(t.floor, 4);
      e.writeUInt(t.revives, 8);
      e.writeUInt(t.revivesTotal, 8);
      e.writeBoolean(t.speedrun);
      e.writeBoolean(t.speedrun_seen);
    }
    for (let n = 0; n < 9; n++) e.writeDInt(t.splits[n], this.$long);
  }
  static decode(e) {
    const t = {};
    {
      t.altitude = e.readDouble();
      t.rank = e.readDouble();
      t.peakrank = e.readDouble();
      t.avgrankpts = e.readDouble();
      t.totalbonus = e.readDouble();
      t.targetingfactor = e.readFloat(16, 100);
      t.targetinggrace = e.readFloat(16, 100);
      t.floor = e.readUInt(4);
      t.revives = e.readUInt(8);
      t.revivesTotal = e.readUInt(8);
      t.revivesMaxOfBoth = Math.max(t.revives, t.revivesTotal - t.revives);
      t.speedrun = e.readBoolean();
      t.speedrun_seen = e.readBoolean();
      t.splits = [];
    }
    for (let n = 0; n < 9; n++) t.splits[n] = e.readDInt(this.$long);
    return t;
  }
}
class je extends De {
  static init() {
    {
      super.AddProperty("byte", {
        min: 8,
        max: 24
      });
      super.AddTable("type", [
        "interaction",
        "interaction_confirm",
        "target",
        "targeted",
        "allow_targeting",
        "kev",
        "custom"
      ]);
      super.AddTable("int_type", [
        "garbage",
        "zenith.climb_pts",
        "zenith.bonus",
        "zenith.incapacitated",
        "zenith.revive"
      ]);
    }
  }
  static encode(e, t) {
    const n = t.frame,
      s = t.type,
      i = t.data;
    e.writeDInt(t.id, this.$byte);
    e.writeDInt(n, this.$byte);
    e.writeTable(s, this.$$type);
    switch (s) {
      case "interaction":
        return e.writeStruct(i, Ve);
      case "interaction_confirm": {
        e.writeTable(i.type, this.$$int_type);
        switch (i.type) {
          case "garbage":
            return e.writeStruct(i, Ve);
          case "zenith.climb_pts":
          case "zenith.bonus": {
            e.writeUInt(i.gameid, 13);
            e.writeDInt(i.frame, this.$byte);
            return e.writeDouble(i.amt);
          }
          case "zenith.incapacitated":
          case "zenith.revive": {
            e.writeUInt(i.gameid, 13);
            return e.writeDInt(i.frame, this.$byte);
          }
          default:
            throw new Error(`Unknown interaction type received: ${i.type}`);
        }
      }
      case "target":
        e.writeUInt(i.targets.length, 13);
        for (const t of i.targets) e.writeUInt(t, 13);
        break;
      case "targeted":
        {
          e.writeBoolean(i.value);
          e.writeUInt(i.gameid, 13);
          e.writeDInt(i.frame, this.$byte);
        }
        break;
      case "allow_targeting":
        e.writeBoolean(i.value);
        break;
      case "kev":
        {
          e.writeUInt(i.victim.gameid, 13);
          e.writeUInt(i.killer.gameid, 13);
          e.writeDInt(i.frame, this.$byte);
          e.writeUInt(i.fire, 10);
        }
        break;
      case "custom":
        return e.writeStruct(i, Qe);
    }
  }
  static decode(e) {
    const t = {};
    {
      t.id = e.readDInt(this.$byte);
      t.frame = e.readDInt(this.$byte);
      t.type = e.readTable(this.$$type);
    }
    e: switch (t.type) {
      case "interaction":
        t.data = e.readStruct(Ve);
        break;
      case "interaction_confirm": {
        const n = e.readTable(this.$$int_type);
        switch (n) {
          case "garbage":
            t.data = e.readStruct(Ve);
            break e;
          case "zenith.climb_pts":
          case "zenith.bonus":
            t.data = {
              type: n,
              gameid: e.readUInt(13),
              frame: e.readDInt(this.$byte),
              amt: e.readDouble()
            };
            break e;
          case "zenith.incapacitated":
          case "zenith.revive":
            t.data = {
              type: n,
              gameid: e.readUInt(13),
              frame: e.readDInt(this.$byte)
            };
            break e;
        }
        break;
      }
      case "target": {
        const n = [],
          s = e.readUInt(13);
        for (let t = 0; t < s; t++) n.push(e.readUInt(13));
        t.data = {
          targets: n
        };
        break;
      }
      case "targeted":
        t.data = {
          value: e.readBoolean(),
          gameid: e.readUInt(13),
          frame: e.readDInt(this.$byte)
        };
        break;
      case "allow_targeting":
        t.data = {
          value: e.readBoolean()
        };
        break;
      case "kev":
        t.data = {
          victim: {
            gameid: e.readUInt(13)
          },
          killer: {
            gameid: e.readUInt(13)
          },
          frame: e.readDInt(this.$byte),
          fire: e.readUInt(10)
        };
        break;
      case "custom":
        t.data = e.readStruct(Qe);
    }
    return t;
  }
}
class Ve extends We {
  static init() {
    const Nc = "3|4|5|2|0|1".split("|");
    let $c = 0;
    while (true) {
      switch (Nc[$c++]) {
        case "0":
          super.AddTable("position", [
            "aboveStack",
            "aboveUnclearable",
            "abovePerma",
            "bottom"
          ]);
          continue;
        case "1":
          const M = {
            type: {
              mode: "fixed",
              type: Ee.TYPES.Table,
              size: this.$$type
            },
            amt: {
              mode: "fixed",
              type: Ee.TYPES.DInt,
              size: this.$byte
            },
            username: {
              mode: "optional",
              type: Ee.TYPES.String,
              size: true
            },
            gameid: {
              mode: "optional",
              type: Ee.TYPES.UInt,
              size: 13
            },
            position: {
              mode: "optional",
              type: Ee.TYPES.Table,
              size: this.$$position
            },
            frame: {
              mode: "optional",
              type: Ee.TYPES.DInt,
              size: this.$byte
            },
            cid: {
              mode: "optional",
              type: Ee.TYPES.DInt,
              size: this.$byte
            },
            iid: {
              mode: "optional",
              type: Ee.TYPES.DInt,
              size: this.$byte
            },
            ackiid: {
              mode: "optional",
              type: Ee.TYPES.DInt,
              size: this.$byte
            },
            pos: {
              mode: "optional",
              type: Ee.TYPES.Table,
              size: this.$$blk
            },
            neg: {
              mode: "optional",
              type: Ee.TYPES.Table,
              size: this.$$blk
            },
            color: {
              mode: "optional",
              type: Ee.TYPES.UInt,
              size: 24
            },
            column: {
              mode: "optional",
              type: Ee.TYPES.UInt,
              size: Ge.MAX_WIDTH
            },
            delay: {
              mode: "optional",
              type: Ee.TYPES.UInt,
              size: 16
            },
            queued: {
              mode: "optional",
              type: Ee.TYPES.Boolean
            },
            hardened: {
              mode: "optional",
              type: Ee.TYPES.Boolean
            },
            size: {
              mode: "optional",
              type: Ee.TYPES.UInt,
              size: Ge.MAX_WIDTH
            },
            zthalt: {
              mode: "optional",
              type: Ee.TYPES.Double
            },
            actor_neg: {
              mode: "optional",
              type: Ee.TYPES.String
            },
            actor_pos: {
              mode: "optional",
              type: Ee.TYPES.String
            },
            anchor: {
              mode: "optional",
              type: Ee.TYPES.String
            },
            actor_neg_data_type: {
              mode: "optional",
              type: Ee.TYPES.Table,
              size: this.$$actorType
            },
            actor_neg_data_amt: {
              mode: "optional",
              type: Ee.TYPES.Any
            },
            actor_pos_data_type: {
              mode: "optional",
              type: Ee.TYPES.Table,
              size: this.$$actorType
            },
            actor_pos_data_amt: {
              mode: "optional",
              type: Ee.TYPES.Any
            }
          };
          {
            M.x = {
              mode: "optional",
              type: Ee.TYPES.Int,
              size: Ge.MAX_WIDTH
            };
            M.y = {
              mode: "optional",
              type: Ee.TYPES.UInt,
              size: Ge.MAX_HEIGHT
            };
            super.AddStructure(M);
          }
          continue;
        case "2":
          super.AddTable("blk", [null, ...L.minocolors]);
          continue;
        case "3":
          super.AddProperty("byte", {
            min: 8,
            max: 24
          });
          continue;
        case "4":
          super.AddTable("type", ["garbage", "corruption"]);
          continue;
        case "5":
          super.AddTable("actorType", ["none", "clears", "time", "line"]);
          continue;
      }
      break;
    }
  }
}
class Ye extends We {
  static init() {
    const sa = "1|3|4|0|2|5".split("|");
    let ia = 0;
    while (true) {
      switch (sa[ia++]) {
        case "0":
          super.AddTable("blk", [null, ...L.minocolors]);
          continue;
        case "1":
          super.AddTable("action", ["add", "remove"]);
          continue;
        case "2":
          super.AddProperty("byte", {
            min: 8,
            max: 32
          });
          continue;
        case "3":
          super.AddTable("position", [
            "aboveStack",
            "aboveUnclearable",
            "abovePerma",
            "bottom"
          ]);
          continue;
        case "4":
          super.AddTable("actorType", ["none", "clears", "time", "line"]);
          continue;
        case "5":
          super.AddStructure({
            action: {
              mode: "fixed",
              type: Ee.TYPES.Table,
              size: this.$$action
            },
            amt: {
              mode: "fixed",
              type: Ee.TYPES.DInt,
              size: this.$byte
            },
            size: {
              mode: "fixed",
              type: Ee.TYPES.UInt,
              size: Ge.MAX_WIDTH
            },
            pos: {
              mode: "optional",
              type: Ee.TYPES.Table,
              size: this.$$blk
            },
            neg: {
              mode: "optional",
              type: Ee.TYPES.Table,
              size: this.$$blk
            },
            position: {
              mode: "optional",
              type: Ee.TYPES.Table,
              size: this.$$position
            },
            column: {
              mode: "optional",
              type: Ee.TYPES.UInt,
              size: Ge.MAX_WIDTH
            },
            slow: {
              mode: "optional",
              type: Ee.TYPES.UInt,
              size: 16
            },
            effect: {
              mode: "optional",
              type: Ee.TYPES.String
            },
            actor_neg: {
              mode: "optional",
              type: Ee.TYPES.String
            },
            actor_pos: {
              mode: "optional",
              type: Ee.TYPES.String
            },
            anchor: {
              mode: "optional",
              type: Ee.TYPES.String
            },
            actor_neg_data_type: {
              mode: "optional",
              type: Ee.TYPES.Table,
              size: this.$$actorType
            },
            actor_neg_data_amt: {
              mode: "optional",
              type: Ee.TYPES.Any
            },
            actor_pos_data_type: {
              mode: "optional",
              type: Ee.TYPES.Table,
              size: this.$$actorType
            },
            actor_pos_data_amt: {
              mode: "optional",
              type: Ee.TYPES.Any
            }
          });
          continue;
      }
      break;
    }
  }
}
class Qe extends De {
  static init() {
    super.AddTable("type", [
      "garbage",
      "map",
      "queue",
      "piece",
      "lines",
      "boardsize",
      "boardresize",
      "holderstate",
      "setoptions",
      "constants",
      "tetrominoes"
    ]);
  }
  static encode(e, { type: t, data: n }) {
    e.writeTable(t, this.$$type);
    switch (t) {
      case "garbage":
        return e.writeStruct(n, Ve);
      case "map": {
        e.writeStruct(n.map, Ze);
        e.writeUInt(n.w, Ge.MAX_WIDTH);
        return e.writeUInt(n.h, Ge.MAX_HEIGHT);
      }
      case "queue": {
        e.writeBoolean(n.start);
        return e.writeString(n.queue.toString());
      }
      case "piece":
        return e.writeString(n.piece);
      case "lines":
        return e.writeStruct(n, Ye);
      case "boardsize":
      case "boardresize": {
        e.writeUInt(n.w, Ge.MAX_WIDTH);
        return e.writeUInt(n.h, Ge.MAX_HEIGHT);
      }
      case "holderstate":
      case "constants":
        return e.pack(n);
      case "setoptions":
        return e.writeStruct(n.options, et);
      case "tetrominoes":
        return e.writeStruct(n, Je);
    }
  }
  static decode(e) {
    const t = {};
    t.type = e.readTable(this.$$type);
    t.data = {};
    switch (t.type) {
      case "garbage":
        t.data = e.readStruct(Ve);
        break;
      case "map":
        {
          t.data.map = e.readStruct(Ze);
          t.data.w = e.readUInt(Ge.MAX_WIDTH);
          t.data.h = e.readUInt(Ge.MAX_HEIGHT);
        }
        break;
      case "queue":
        {
          t.data.start = e.readBoolean();
          t.data.queue = e.readString().split(",");
        }
        break;
      case "piece":
        t.data.piece = e.readString();
        break;
      case "lines":
        t.data = e.readStruct(Ye);
        break;
      case "boardsize":
      case "boardresize":
        {
          t.data.w = e.readUInt(Ge.MAX_WIDTH);
          t.data.h = e.readUInt(Ge.MAX_HEIGHT);
        }
        break;
      case "holderstate":
      case "constants":
        t.data = e.unpack();
        break;
      case "setoptions":
        t.data.options = e.readStruct(et);
        break;
      case "tetrominoes":
        t.data = e.readStruct(Je);
    }
    return t;
  }
}
class Ze extends De {
  static init() {
    super.AddTable(
      "letters",
      ["?", ",", "_", "#", "@", "z", "l", "o", "s", "i", "j", "t", "g", "d"],
      "flexible"
    );
    super.AddProperty("word", {
      min: 16,
      max: 32
    });
  }
  static encode(e, t) {
    const n = t.split("");
    e.writeDInt(n.length, this.$word);
    for (const t of n) e.writeTable(t, this.$$letters);
  }
  static decode(e) {
    let t = "";
    const n = e.readDInt(this.$word);
    for (let s = 0; s < n; s++) {
      t += e.readTable(this.$$letters);
    }
    return t;
  }
}
class Je extends De {
  static init() {
    const at = "3|1|4|2|0".split("|");
    let rt = 0;
    while (true) {
      switch (at[rt++]) {
        case "0":
          super.AddTable("special", ["i", "i2", "i3", "l3", "i5", "oo"]);
          continue;
        case "1":
          super.AddTable(
            "spinbonus",
            [...Object.keys(L.spinbonuses_rules)],
            "flexible"
          );
          continue;
        case "2":
          super.AddTable("kicksets", [...Object.keys(L.kicksets)], "flexible");
          continue;
        case "3":
          super.AddProperty("tiny", {
            min: 3,
            max: 7
          });
          continue;
        case "4":
          super.AddTable("colors", [...L.minocolors]);
          continue;
      }
      break;
    }
  }
  static encode(e, t) {
    const n = t.tetrominoes,
      s = t.minotypes,
      i = t.tetrominoes_color,
      o = Object.keys(n);
    e.writeUInt(o.length, 8);
    for (const t of o) e.writeString(t);
    for (const [t, o] of Object.entries(n)) {
      const { matrix: n, preview: a } = o;
      {
        e.writeDInt(n.w, this.$tiny);
        e.writeDInt(n.h, this.$tiny);
        e.writeUInt(n.dx, 5);
        e.writeUInt(n.dy, 5);
        e.writeDInt(n.data[0].length, this.$tiny);
      }
      const [r, l] = [Ee.cla32(n.w - 1), Ee.cla32(n.h - 1)];
      for (const t of n.data)
        for (const [n, s] of t) {
          e.writeUInt(n, r);
          e.writeUInt(s, l);
        }
      {
        e.writeDInt(a.w, this.$tiny);
        e.writeDInt(a.h, this.$tiny);
      }
      for (const [t, n] of a.data) {
        e.writeUInt(t, r);
        e.writeUInt(n, l);
      }
      {
        e.writeBoolean(undefined !== o.weight);
        e.writeBoolean(o.spinbonus_override);
        e.writeBoolean(o.kickset_override);
        e.writeBoolean(o.kickset_special);
        e.writeBoolean(s.includes(t));
        e.writeTable(i[t], this.$$colors);
        if (undefined !== o.weight) {
          e.writeDInt(o.weight, this.$tiny);
        }
        if (o.spinbonus_override) {
          {
            e.writeTable(o.spinbonus_override.rule, this.$$spinbonus);
            e.writeBoolean(o.spinbonus_override.mini);
          }
        }
        if (o.kickset_override) {
          e.writeTable(o.kickset_override, this.$$kicksets);
        }
        if (o.kickset_special) {
          e.writeTable(o.kickset_special, this.$$special);
        }
      }
    }
  }
  static decode(e) {
    const t = {},
      n = [],
      s = {},
      i = e.readUInt(8),
      o = [];
    for (let n = 0; n < i; n++) {
      const n = e.readString();
      {
        t[n] = {
          matrix: {},
          preview: {}
        };
        o.push(n);
      }
    }
    for (const i of o) {
      const o = t[i],
        { matrix: a, preview: r } = o;
      {
        a.w = e.readDInt(this.$tiny);
        a.h = e.readDInt(this.$tiny);
        a.dx = e.readUInt(5);
        a.dy = e.readUInt(5);
      }
      const l = e.readDInt(this.$tiny),
        [c, p] = [Ee.cla32(a.w - 1), Ee.cla32(a.h - 1)];
      a.data = [];
      for (let t = 0; t < 4; t++) {
        a.data[t] = [];
        for (let n = 0; n < l; n++) {
          const [s, i] = [e.readUInt(c), e.readUInt(p)];
          a.data[t][n] = [s, i];
        }
      }
      {
        r.w = e.readDInt(this.$tiny);
        r.h = e.readDInt(this.$tiny);
        r.data = [];
      }
      for (let t = 0; t < l; t++) {
        const [n, s] = [e.readUInt(c), e.readUInt(p)];
        r.data[t] = [n, s];
      }
      const h = e.readBoolean(),
        d = e.readBoolean(),
        u = e.readBoolean(),
        _ = e.readBoolean(),
        m = e.readBoolean();
      {
        s[i] = e.readTable(this.$$colors);
        if (h) {
          o.weight = e.readDInt(this.$tiny);
        }
        if (d) {
          o.spinbonus_override = {
            rule: e.readTable(this.$$spinbonus),
            mini: e.readBoolean()
          };
        }
        if (u) {
          o.kickset_override = e.readTable(this.$$kicksets);
        }
        if (_) {
          o.kickset_special = e.readTable(this.$$special);
        }
        if (m) {
          n.push(i);
        }
      }
    }
    return {
      minotypes: n,
      tetrominoes: t,
      tetrominoes_color: s
    };
  }
}
class et extends De {
  static TypeOrders = [
    "boolean",
    "number",
    "table",
    "object",
    "array",
    "string"
  ];
  static OptsBook = Ce.OptionsList;
  static init() {
    {
      super.AddTable("options", Object.keys(this.OptsBook));
      super.AddTable(
        "minoskin",
        ["i", "j", "l", "o", "s", "t", "z", "ghost", "other"],
        "flexible"
      );
      super.AddTable(
        "skins",
        ["tetrio", "_bombs", "connected_test"],
        "flexible"
      );
      super.AddTable("ixs", ["off", "hold", "tap"]);
    }
    for (const [e, t] of Object.entries(this.OptsBook)) {
      if (t.allowed) super.AddTable("_" + e, t.allowed);
      else if (t.possibles) {
        super.AddTable("_" + e, t.possibles, "flexible");
      }
    }
  }
  static *ParseOptions(e) {
    const { TypeOrders: t, OptsBook: n } = this,
      s = Object.keys(e);
    for (const i of t)
      for (const t of s) {
        const s = n[t];
        if (s.type !== i) continue;
        const o = e[t];
        yield [t, o, s];
      }
  }
  static encode(e, t) {
    for (const [n, s, i] of this.ParseOptions(t)) {
      e.writeTable(n, this.$$options);
      switch (i.type) {
        case "object":
          if ("handling" === n) {
            e.writeFloat(s.arr, 6, 10);
            e.writeUInt(s.sdf, 6);
            e.writeBoolean(s.safelock);
            e.writeBoolean(s.cancel);
            e.writeBoolean(s.may20g);
            e.writeFloat(s.das, 8, 10);
            e.writeFloat(s.dcd, 8, 10);
            e.writeTable(s.irs, this.$$ixs);
            e.writeTable(s.ihs, this.$$ixs);
          } else if ("minoskin" === n) {
            e.writeUInt(Object.keys(s).length, 8);
            for (const [t, n] of Object.entries(s)) {
              e.writeTable(t, this.$$minoskin);
              e.writeTable(n, this.$$skins);
            }
          }
          break;
        case "array":
          e.writeArray(s);
          break;
        case "boolean":
          e.writeBoolean(s);
          break;
        case "table":
          e.writeTable(s, this[`$$_${n}`], i.mode);
          break;
        case "number":
          e.writeNumber(s);
          break;
        case "string":
          e.writeString(s);
          break;
        default:
          throw new TypeError(
            `Unknown type for key: ${n} value: ${s} | got -> ${i.type}`
          );
      }
    }
    e.writeTable(null, this.$$options);
  }
  static decode(e) {
    const t = this.$$options.size,
      n = this.OptsBook,
      s = {};
    let i = null,
      o = null;
    for (let a = e.peek(t); 0 !== a; a = e.peek(t)) {
      const t = e.readTable(this.$$options),
        a = n[t]?.type;
      switch (a) {
        case "object":
          if ("handling" === t) {
            const n = {};
            {
              n.arr = e.readFloat(6, 10);
              n.sdf = e.readUInt(6);
              n.safelock = e.readBoolean();
              n.cancel = e.readBoolean();
              n.may20g = e.readBoolean();
              n.das = e.readFloat(8, 10);
              n.dcd = e.readFloat(8, 10);
              n.irs = e.readTable(this.$$ixs);
              n.ihs = e.readTable(this.$$ixs);
              s[t] = n;
            }
          } else if ("minoskin" === t) {
            const n = {},
              i = e.readUInt(8);
            s[t] = n;
            for (let t = 0; t < i; t++) {
              const t = e.readTable(this.$$minoskin),
                s = e.readTable(this.$$skins);
              n[t] = s;
            }
          }
          break;
        case "array":
          s[t] = e.readArray();
          break;
        case "boolean":
          s[t] = e.readBoolean();
          break;
        case "table":
          s[t] = e.readTable(this[`$$_${t}`]);
          break;
        case "number":
          s[t] = e.readNumber();
          break;
        case "string":
          s[t] = e.readString();
          break;
        default:
          throw (
            console.error("Options dump: ", s),
            new TypeError(
              `Unknown type for key: ${t} | got -> ${a}\nLast Key: ${i}\nLast Value: ${o}\n`
            )
          );
      }
      {
        i = t;
        o = s[t];
      }
    }
    e.seek(t, 2);
    return s;
  }
}
class tt extends et {
  static *ParseOptions(e) {
    for (const [n, s, i] of super.ParseOptions(e))
      if (
        i.default !== s &&
        !("object" === i.type && strictShallowEqual(i.default, s))
      ) {
        yield [n, s, i];
      }
  }
}
class nt extends De {
  static init() {
    {
      super.AddExtension(this, {
        ownBuffer: true
      });
      super.AddTable("gor", [
        null,
        "topout",
        "garbagesmash",
        "zenith",
        "clear",
        "topout_clear",
        "winner",
        "forfeit",
        "retry",
        "drop",
        "dropnow",
        "disconnect"
      ]);
    }
  }
  static encode(e, t) {
    const n = t.successful,
      s = t.gameoverreason,
      i = t.killer.gameid,
      o = "spark" === t.killer.type,
      a = t.killer.username ?? "",
      { apm: r, pps: l, vsscore: c } = t.aggregatestats,
      { game: p, stats: h, diyusi: d } = t;
    {
      e.writeBoolean(n);
      e.writeTable(s, this.$$gor);
      e.writeUInt(i, 13);
      e.writeBoolean(o, 1);
      e.writeString(a);
      e.writeStruct(t.options, tt);
      e.writeDouble(r);
      e.writeDouble(l);
      e.writeDouble(c);
      e.writeStruct(
        {
          game: p,
          stats: h,
          diyusi: d
        },
        $e
      );
    }
  }
  static decode(e) {
    const t = {
      killer: {},
      aggregatestats: {}
    };
    t.successful = e.readBoolean();
    t.gameoverreason = e.readTable(this.$$gor);
    t.killer.gameid = e.readUInt(13);
    t.killer.type = e.readBoolean() ? "spark" : "sizzle";
    t.killer.username = e.readString();
    t.options = e.readStruct(tt);
    t.aggregatestats.apm = e.readDouble();
    t.aggregatestats.pps = e.readDouble();
    t.aggregatestats.vsscore = e.readDouble();
    Object.assign(t, e.readStruct($e));
    return t;
  }
}
Ee.init();
Oe.init();
Pe.init();
He.init();
Re.init();
Ne.init();
$e.init();
Ge.init();
Ue.init();
Xe.init();
qe.init();
je.init();
Ve.init();
Ye.init();
Qe.init();
Je.init();
Ze.init();
et.init();
nt.init();
De.LoadExtensions(r);
Te.SetMsgpackr(new r.Packr(ke), new r.Unpackr(ke));
export { Te as Codec };
