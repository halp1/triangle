/* eslint-disable */
// @ts-nocheck
import msgpackr from "./msgpackr-943ed70";

import { Buffer } from "buffer/";
import { strictShallowEqual } from "fast-equals";

const r = msgpackr();

const x = 11;
const y = 19;

class I {
  static BagList = [
    "total mayhem",
    "classic",
    "pairs",
    "14-bag",
    "7+1-bag",
    "7+2-bag",
    "7+x-bag",
    "7-bag+oo",
    "7+1-lone-bag",
    "14+1-lone-bag",
    "7+2-lone-bag",
    "14+2-lone-bag",
    "zenith",
    "7-bag"
  ];
}

class se {}
se.SpinRules = [
  "none",
  "T-spins",
  "T-spins+",
  "all",
  "all+",
  "all-mini",
  "all-mini+",
  "mini-only",
  "handheld",
  "stupid"
];

function b(e) {
  const t = Object.prototype.toString.call(e);
  return b.cached[t]
    ? b.cached[t]
    : (b.cached[t] = t.substring(8, t.length - 1).toLowerCase());
}
b.cached = {};

const w = {
  minotypes: ["z", "l", "o", "s", "i", "j", "t"],
  minocolors: ["z", "l", "o", "s", "i", "j", "t", "g", "d", "gb", "gbd"],
  tetrominoes: {
    i1: {
      matrix: {
        w: 1,
        h: 1,
        dx: 0,
        dy: 1,
        data: [[[0, 0, 255]], [[0, 0, 255]], [[0, 0, 255]], [[0, 0, 255]]]
      },
      preview: { w: 1, h: 1, data: [[0, 0, 255]] },
      disallow_kick: true
    },
    i2: {
      matrix: {
        w: 2,
        h: 2,
        dx: 0,
        dy: 1,
        data: [
          [
            [0, 0, 199],
            [1, 0, 124]
          ],
          [
            [1, 0, 241],
            [1, 1, 31]
          ],
          [
            [1, 1, 124],
            [0, 1, 199]
          ],
          [
            [0, 1, 31],
            [0, 0, 241]
          ]
        ]
      },
      preview: {
        w: 2,
        h: 1,
        data: [
          [0, 0, 199],
          [1, 0, 124]
        ]
      },
      kickset_special: "i2"
    },
    i3: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [0, 1, 199],
            [1, 1, 68],
            [2, 1, 124]
          ],
          [
            [1, 0, 241],
            [1, 1, 17],
            [1, 2, 31]
          ],
          [
            [2, 1, 124],
            [1, 1, 68],
            [0, 1, 199]
          ],
          [
            [1, 2, 31],
            [1, 1, 17],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 1,
        data: [
          [0, 0, 199],
          [1, 0, 68],
          [2, 0, 124]
        ]
      },
      kickset_special: "i3"
    },
    l3: {
      matrix: {
        w: 2,
        h: 2,
        dx: 0,
        dy: 1,
        data: [
          [
            [0, 0, 241],
            [0, 1, 39],
            [1, 1, 124]
          ],
          [
            [1, 0, 124],
            [0, 0, 201],
            [0, 1, 31]
          ],
          [
            [1, 1, 31],
            [1, 0, 114],
            [0, 0, 199]
          ],
          [
            [0, 1, 199],
            [1, 1, 156],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 2,
        h: 2,
        data: [
          [0, 0, 241],
          [0, 1, 39],
          [1, 1, 124]
        ]
      },
      kickset_special: "l3"
    },
    i5: {
      matrix: {
        w: 5,
        h: 5,
        dx: 2,
        dy: 2,
        data: [
          [
            [0, 2, 199],
            [1, 2, 68],
            [2, 2, 68],
            [3, 2, 68],
            [4, 2, 124]
          ],
          [
            [2, 0, 241],
            [2, 1, 17],
            [2, 2, 17],
            [2, 3, 17],
            [2, 4, 31]
          ],
          [
            [4, 2, 124],
            [3, 2, 68],
            [2, 2, 68],
            [1, 2, 68],
            [0, 2, 199]
          ],
          [
            [2, 4, 31],
            [2, 3, 17],
            [2, 2, 17],
            [2, 1, 17],
            [2, 0, 241]
          ]
        ]
      },
      preview: {
        w: 5,
        h: 1,
        data: [
          [0, 0, 199],
          [1, 0, 68],
          [2, 0, 68],
          [3, 0, 68],
          [4, 0, 124]
        ]
      },
      kickset_special: "i5"
    },
    z: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [0, 0, 199],
            [1, 0, 114],
            [1, 1, 39],
            [2, 1, 124]
          ],
          [
            [2, 0, 241],
            [2, 1, 156],
            [1, 1, 201],
            [1, 2, 31]
          ],
          [
            [2, 2, 124],
            [1, 2, 39],
            [1, 1, 114],
            [0, 1, 199]
          ],
          [
            [0, 2, 31],
            [0, 1, 201],
            [1, 1, 156],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 2,
        data: [
          [0, 0, 199],
          [1, 0, 114],
          [1, 1, 39],
          [2, 1, 124]
        ]
      }
    },
    l: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [2, 0, 241],
            [0, 1, 199],
            [1, 1, 68],
            [2, 1, 156]
          ],
          [
            [2, 2, 124],
            [1, 0, 241],
            [1, 1, 17],
            [1, 2, 39]
          ],
          [
            [0, 2, 31],
            [2, 1, 124],
            [1, 1, 68],
            [0, 1, 201]
          ],
          [
            [0, 0, 199],
            [1, 2, 31],
            [1, 1, 17],
            [1, 0, 114]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 2,
        data: [
          [2, 0, 241],
          [0, 1, 199],
          [1, 1, 68],
          [2, 1, 156]
        ]
      }
    },
    o: {
      matrix: {
        w: 2,
        h: 2,
        dx: 0,
        dy: 1,
        data: [
          [
            [0, 0, 193],
            [1, 0, 112],
            [0, 1, 7],
            [1, 1, 28]
          ],
          [
            [1, 0, 112],
            [1, 1, 28],
            [0, 0, 193],
            [0, 1, 7]
          ],
          [
            [1, 1, 28],
            [0, 1, 7],
            [1, 0, 112],
            [0, 0, 193]
          ],
          [
            [0, 1, 7],
            [0, 0, 193],
            [1, 1, 28],
            [1, 0, 112]
          ]
        ]
      },
      preview: {
        w: 2,
        h: 2,
        data: [
          [0, 0, 193],
          [1, 0, 112],
          [0, 1, 7],
          [1, 1, 28]
        ]
      },
      disallow_kick: true
    },
    s: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [1, 0, 201],
            [2, 0, 124],
            [0, 1, 199],
            [1, 1, 156]
          ],
          [
            [2, 1, 114],
            [2, 2, 31],
            [1, 0, 241],
            [1, 1, 39]
          ],
          [
            [1, 2, 156],
            [0, 2, 199],
            [2, 1, 124],
            [1, 1, 201]
          ],
          [
            [0, 1, 39],
            [0, 0, 241],
            [1, 2, 31],
            [1, 1, 114]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 2,
        data: [
          [1, 0, 201],
          [2, 0, 124],
          [0, 1, 199],
          [1, 1, 156]
        ]
      }
    },
    i: {
      matrix: {
        w: 4,
        h: 4,
        dx: 1,
        dy: 1,
        data: [
          [
            [0, 1, 199],
            [1, 1, 68],
            [2, 1, 68],
            [3, 1, 124]
          ],
          [
            [2, 0, 241],
            [2, 1, 17],
            [2, 2, 17],
            [2, 3, 31]
          ],
          [
            [3, 2, 124],
            [2, 2, 68],
            [1, 2, 68],
            [0, 2, 199]
          ],
          [
            [1, 3, 31],
            [1, 2, 17],
            [1, 1, 17],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 4,
        h: 1,
        data: [
          [0, 0, 199],
          [1, 0, 68],
          [2, 0, 68],
          [3, 0, 124]
        ]
      },
      kickset_special: "i"
    },
    j: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [0, 0, 241],
            [0, 1, 39],
            [1, 1, 68],
            [2, 1, 124]
          ],
          [
            [2, 0, 124],
            [1, 0, 201],
            [1, 1, 17],
            [1, 2, 31]
          ],
          [
            [2, 2, 31],
            [2, 1, 114],
            [1, 1, 68],
            [0, 1, 199]
          ],
          [
            [0, 2, 199],
            [1, 2, 156],
            [1, 1, 17],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 2,
        data: [
          [0, 0, 241],
          [0, 1, 39],
          [1, 1, 68],
          [2, 1, 124]
        ]
      }
    },
    t: {
      matrix: {
        w: 3,
        h: 3,
        dx: 1,
        dy: 1,
        data: [
          [
            [1, 0, 241],
            [0, 1, 199],
            [1, 1, 164],
            [2, 1, 124]
          ],
          [
            [2, 1, 124],
            [1, 0, 241],
            [1, 1, 41],
            [1, 2, 31]
          ],
          [
            [1, 2, 31],
            [2, 1, 124],
            [1, 1, 74],
            [0, 1, 199]
          ],
          [
            [0, 1, 199],
            [1, 2, 31],
            [1, 1, 146],
            [1, 0, 241]
          ]
        ]
      },
      preview: {
        w: 3,
        h: 2,
        data: [
          [1, 0, 241],
          [0, 1, 199],
          [1, 1, 164],
          [2, 1, 124]
        ]
      }
    },
    oo: {
      matrix: {
        w: 4,
        h: 4,
        dx: 1,
        dy: 1,
        data: [
          [
            [0, 1, 193],
            [1, 1, 64],
            [2, 1, 64],
            [3, 1, 112],
            [0, 2, 7],
            [1, 2, 4],
            [2, 2, 4],
            [3, 2, 28]
          ],
          [
            [2, 0, 112],
            [2, 1, 16],
            [2, 2, 16],
            [2, 3, 28],
            [1, 0, 193],
            [1, 1, 1],
            [1, 2, 1],
            [1, 3, 7]
          ],
          [
            [3, 2, 28],
            [2, 2, 68],
            [1, 2, 68],
            [0, 2, 7],
            [3, 1, 112],
            [2, 1, 64],
            [1, 1, 64],
            [0, 1, 193]
          ],
          [
            [1, 3, 7],
            [1, 2, 1],
            [1, 1, 1],
            [1, 0, 193],
            [2, 3, 28],
            [2, 2, 16],
            [2, 1, 16],
            [2, 0, 112]
          ]
        ]
      },
      preview: {
        w: 4,
        h: 2,
        data: [
          [0, 0, 193],
          [1, 0, 64],
          [2, 0, 64],
          [3, 0, 112],
          [0, 1, 7],
          [1, 1, 4],
          [2, 1, 4],
          [3, 1, 28]
        ]
      },
      kickset_special: "oo",
      weight: 1
    }
  },
  tetrominoes_color: {
    i1: "i",
    i2: "i",
    i3: "i",
    l3: "j",
    i5: "i",
    z: "z",
    l: "l",
    o: "o",
    s: "s",
    i: "i",
    j: "j",
    t: "t",
    oo: "o",
    g: "g",
    d: "d",
    gb: "gb",
    gbd: "gbd"
  },
  spinbonuses_rules: {
    none: {},
    stupid: {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    all: {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    "all+": {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    "all-mini": {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    "all-mini+": {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    "mini-only": {
      types: [
        "i1",
        "i2",
        "i3",
        "l3",
        "i5",
        "z",
        "l",
        "o",
        "s",
        "i",
        "j",
        "t",
        "oo"
      ],
      types_mini: ["t"]
    },
    handheld: { types: ["t", "s", "z", "l", "j"], types_mini: ["t"] },
    "T-spins": { types: ["t"], types_mini: ["t"] },
    "T-spins+": { types: ["t"], types_mini: ["t"] }
  },
  kicksets: {
    SRS: {
      kicks: {
        "01": [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        10: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        12: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        21: [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        23: [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        32: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        30: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        "03": [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        "02": [
          [0, -1],
          [1, -1],
          [-1, -1],
          [1, 0],
          [-1, 0]
        ],
        13: [
          [1, 0],
          [1, -2],
          [1, -1],
          [0, -2],
          [0, -1]
        ],
        20: [
          [0, 1],
          [-1, 1],
          [1, 1],
          [-1, 0],
          [1, 0]
        ],
        31: [
          [-1, 0],
          [-1, -2],
          [-1, -1],
          [0, -2],
          [0, -1]
        ]
      },
      i_kicks: {
        "01": [
          [-2, 0],
          [1, 0],
          [-2, 1],
          [1, -2]
        ],
        10: [
          [2, 0],
          [-1, 0],
          [2, -1],
          [-1, 2]
        ],
        12: [
          [-1, 0],
          [2, 0],
          [-1, -2],
          [2, 1]
        ],
        21: [
          [1, 0],
          [-2, 0],
          [1, 2],
          [-2, -1]
        ],
        23: [
          [2, 0],
          [-1, 0],
          [2, -1],
          [-1, 2]
        ],
        32: [
          [-2, 0],
          [1, 0],
          [-2, 1],
          [1, -2]
        ],
        30: [
          [1, 0],
          [-2, 0],
          [1, 2],
          [-2, -1]
        ],
        "03": [
          [-1, 0],
          [2, 0],
          [-1, -2],
          [2, 1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i2_kicks: {
        "01": [
          [0, -1],
          [-1, 0],
          [-1, -1]
        ],
        10: [
          [0, 1],
          [1, 0],
          [1, 1]
        ],
        12: [
          [1, 0],
          [0, -1],
          [1, 0]
        ],
        21: [
          [-1, 0],
          [0, 1],
          [-1, 0]
        ],
        23: [
          [0, 1],
          [1, 0],
          [1, -1]
        ],
        32: [
          [0, -1],
          [-1, 0],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, 1],
          [-1, 2]
        ],
        "03": [
          [1, 0],
          [0, -1],
          [1, -2]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i3_kicks: {
        "01": [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1]
        ],
        10: [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1]
        ],
        12: [
          [1, 0],
          [-1, 0],
          [0, -2],
          [0, 2]
        ],
        21: [
          [-1, 0],
          [1, 0],
          [0, 2],
          [0, -2]
        ],
        23: [
          [-1, 0],
          [1, 0],
          [0, 1],
          [0, -1]
        ],
        32: [
          [1, 0],
          [-1, 0],
          [0, -1],
          [0, 1]
        ],
        30: [
          [-1, 0],
          [1, 0],
          [0, 0],
          [0, 0]
        ],
        "03": [
          [1, 0],
          [-1, 0],
          [0, 0],
          [0, 0]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      l3_kicks: {
        "01": [
          [-1, 0],
          [1, 0]
        ],
        10: [
          [1, 0],
          [-1, 0]
        ],
        12: [
          [0, -1],
          [0, 1]
        ],
        21: [
          [0, 1],
          [0, -1]
        ],
        23: [
          [1, 0],
          [-1, 0]
        ],
        32: [
          [-1, 0],
          [1, 0]
        ],
        30: [
          [0, 1],
          [0, -1]
        ],
        "03": [
          [0, -1],
          [0, 1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i5_kicks: {
        "01": [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        10: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        12: [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        21: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        23: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        32: [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        30: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        "03": [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      oo_kicks: {
        "01": [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        10: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        12: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        21: [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        23: [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        32: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        "03": [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        "02": [[0, -1]],
        13: [[1, 0]],
        20: [[0, 1]],
        31: [[-1, 0]]
      },
      additional_offsets: {},
      spawn_rotation: {},
      color_overrides: {},
      preview_overrides: {}
    },
    "SRS+": {
      kicks: {
        "01": [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        10: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        12: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        21: [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        23: [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        32: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        30: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        "03": [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        "02": [
          [0, -1],
          [1, -1],
          [-1, -1],
          [1, 0],
          [-1, 0]
        ],
        13: [
          [1, 0],
          [1, -2],
          [1, -1],
          [0, -2],
          [0, -1]
        ],
        20: [
          [0, 1],
          [-1, 1],
          [1, 1],
          [-1, 0],
          [1, 0]
        ],
        31: [
          [-1, 0],
          [-1, -2],
          [-1, -1],
          [0, -2],
          [0, -1]
        ]
      },
      i_kicks: {
        "01": [
          [1, 0],
          [-2, 0],
          [-2, 1],
          [1, -2]
        ],
        10: [
          [-1, 0],
          [2, 0],
          [-1, 2],
          [2, -1]
        ],
        12: [
          [-1, 0],
          [2, 0],
          [-1, -2],
          [2, 1]
        ],
        21: [
          [-2, 0],
          [1, 0],
          [-2, -1],
          [1, 2]
        ],
        23: [
          [2, 0],
          [-1, 0],
          [2, -1],
          [-1, 2]
        ],
        32: [
          [1, 0],
          [-2, 0],
          [1, -2],
          [-2, 1]
        ],
        30: [
          [1, 0],
          [-2, 0],
          [1, 2],
          [-2, -1]
        ],
        "03": [
          [-1, 0],
          [2, 0],
          [2, 1],
          [-1, -2]
        ],
        "02": [[0, -1]],
        13: [[1, 0]],
        20: [[0, 1]],
        31: [[-1, 0]]
      },
      i2_kicks: {
        "01": [
          [0, -1],
          [-1, 0],
          [-1, -1]
        ],
        10: [
          [0, 1],
          [1, 0],
          [1, 1]
        ],
        12: [
          [1, 0],
          [0, -1],
          [1, 0]
        ],
        21: [
          [-1, 0],
          [0, 1],
          [-1, 0]
        ],
        23: [
          [0, 1],
          [1, 0],
          [1, -1]
        ],
        32: [
          [0, -1],
          [-1, 0],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, 1],
          [-1, 2]
        ],
        "03": [
          [1, 0],
          [0, -1],
          [1, -2]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i3_kicks: {
        "01": [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1]
        ],
        10: [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1]
        ],
        12: [
          [1, 0],
          [-1, 0],
          [0, -2],
          [0, 2]
        ],
        21: [
          [-1, 0],
          [1, 0],
          [0, 2],
          [0, -2]
        ],
        23: [
          [-1, 0],
          [1, 0],
          [0, 1],
          [0, -1]
        ],
        32: [
          [1, 0],
          [-1, 0],
          [0, -1],
          [0, 1]
        ],
        30: [
          [-1, 0],
          [1, 0],
          [0, 0],
          [0, 0]
        ],
        "03": [
          [1, 0],
          [-1, 0],
          [0, 0],
          [0, 0]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      l3_kicks: {
        "01": [
          [-1, 0],
          [1, 0]
        ],
        10: [
          [1, 0],
          [-1, 0]
        ],
        12: [
          [0, -1],
          [0, 1]
        ],
        21: [
          [0, 1],
          [0, -1]
        ],
        23: [
          [1, 0],
          [-1, 0]
        ],
        32: [
          [-1, 0],
          [1, 0]
        ],
        30: [
          [0, 1],
          [0, -1]
        ],
        "03": [
          [0, -1],
          [0, 1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i5_kicks: {
        "01": [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        10: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        12: [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        21: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        23: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        32: [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        30: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        "03": [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      oo_kicks: {
        "01": [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        10: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        12: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        21: [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        23: [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        32: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        "03": [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        "02": [[0, -1]],
        13: [[1, 0]],
        20: [[0, 1]],
        31: [[-1, 0]]
      },
      additional_offsets: {},
      spawn_rotation: {},
      color_overrides: {},
      preview_overrides: {}
    },
    "SRS-X": {
      kicks: {
        "01": [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        10: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        12: [
          [1, 0],
          [1, 1],
          [0, -2],
          [1, -2]
        ],
        21: [
          [-1, 0],
          [-1, -1],
          [0, 2],
          [-1, 2]
        ],
        23: [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        32: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        30: [
          [-1, 0],
          [-1, 1],
          [0, -2],
          [-1, -2]
        ],
        "03": [
          [1, 0],
          [1, -1],
          [0, 2],
          [1, 2]
        ],
        "02": [
          [1, 0],
          [2, 0],
          [1, 1],
          [2, 1],
          [-1, 0],
          [-2, 0],
          [-1, 1],
          [-2, 1],
          [0, -1],
          [3, 0],
          [-3, 0]
        ],
        13: [
          [0, 1],
          [0, 2],
          [-1, 1],
          [-1, 2],
          [0, -1],
          [0, -2],
          [-1, -1],
          [-1, -2],
          [1, 0],
          [0, 3],
          [0, -3]
        ],
        20: [
          [-1, 0],
          [-2, 0],
          [-1, -1],
          [-2, -1],
          [1, 0],
          [2, 0],
          [1, -1],
          [2, -1],
          [0, 1],
          [-3, 0],
          [3, 0]
        ],
        31: [
          [0, 1],
          [0, 2],
          [1, 1],
          [1, 2],
          [0, -1],
          [0, -2],
          [1, -1],
          [1, -2],
          [-1, 0],
          [0, 3],
          [0, -3]
        ]
      },
      i_kicks: {
        "01": [
          [-2, 0],
          [1, 0],
          [-2, 1],
          [1, -2]
        ],
        10: [
          [2, 0],
          [-1, 0],
          [2, -1],
          [-1, 2]
        ],
        12: [
          [-1, 0],
          [2, 0],
          [-1, -2],
          [2, 1]
        ],
        21: [
          [1, 0],
          [-2, 0],
          [1, 2],
          [-2, -1]
        ],
        23: [
          [2, 0],
          [-1, 0],
          [2, -1],
          [-1, 2]
        ],
        32: [
          [-2, 0],
          [1, 0],
          [-2, 1],
          [1, -2]
        ],
        30: [
          [1, 0],
          [-2, 0],
          [1, 2],
          [-2, -1]
        ],
        "03": [
          [-1, 0],
          [2, 0],
          [-1, -2],
          [2, 1]
        ],
        "02": [
          [-1, 0],
          [-2, 0],
          [1, 0],
          [2, 0],
          [0, 1]
        ],
        13: [
          [0, 1],
          [0, 2],
          [0, -1],
          [0, -2],
          [-1, 0]
        ],
        20: [
          [1, 0],
          [2, 0],
          [-1, 0],
          [-2, 0],
          [0, -1]
        ],
        31: [
          [0, 1],
          [0, 2],
          [0, -1],
          [0, -2],
          [1, 0]
        ]
      },
      i2_kicks: {
        "01": [
          [0, -1],
          [-1, 0],
          [-1, -1]
        ],
        10: [
          [0, 1],
          [1, 0],
          [1, 1]
        ],
        12: [
          [1, 0],
          [0, -1],
          [1, 0]
        ],
        21: [
          [-1, 0],
          [0, 1],
          [-1, 0]
        ],
        23: [
          [0, 1],
          [1, 0],
          [1, -1]
        ],
        32: [
          [0, -1],
          [-1, 0],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, 1],
          [-1, 2]
        ],
        "03": [
          [1, 0],
          [0, -1],
          [1, -2]
        ],
        "02": [
          [-1, 0],
          [-2, 0],
          [1, 0],
          [2, 0],
          [0, 1]
        ],
        13: [
          [0, 1],
          [0, 2],
          [0, -1],
          [0, -2],
          [-1, 0]
        ],
        20: [
          [1, 0],
          [2, 0],
          [-1, 0],
          [-2, 0],
          [0, -1]
        ],
        31: [
          [0, 1],
          [0, 2],
          [0, -1],
          [0, -2],
          [1, 0]
        ]
      },
      i3_kicks: {
        "01": [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1]
        ],
        10: [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1]
        ],
        12: [
          [1, 0],
          [-1, 0],
          [0, -2],
          [0, 2]
        ],
        21: [
          [-1, 0],
          [1, 0],
          [0, 2],
          [0, -2]
        ],
        23: [
          [-1, 0],
          [1, 0],
          [0, 1],
          [0, -1]
        ],
        32: [
          [1, 0],
          [-1, 0],
          [0, -1],
          [0, 1]
        ],
        30: [
          [-1, 0],
          [1, 0],
          [0, 0],
          [0, 0]
        ],
        "03": [
          [1, 0],
          [-1, 0],
          [0, 0],
          [0, 0]
        ],
        "02": [
          [1, 0],
          [2, 0],
          [1, 1],
          [2, 1],
          [-1, 0],
          [-2, 0],
          [-1, 1],
          [-2, 1],
          [0, -1],
          [3, 0],
          [-3, 0]
        ],
        13: [
          [0, 1],
          [0, 2],
          [-1, 1],
          [-1, 2],
          [0, -1],
          [0, -2],
          [-1, -1],
          [-1, -2],
          [1, 0],
          [0, 3],
          [0, -3]
        ],
        20: [
          [-1, 0],
          [-2, 0],
          [-1, -1],
          [-2, -1],
          [1, 0],
          [2, 0],
          [1, -1],
          [2, -1],
          [0, 1],
          [-3, 0],
          [3, 0]
        ],
        31: [
          [0, 1],
          [0, 2],
          [1, 1],
          [1, 2],
          [0, -1],
          [0, -2],
          [1, -1],
          [1, -2],
          [-1, 0],
          [0, 3],
          [0, -3]
        ]
      },
      l3_kicks: {
        "01": [
          [-1, 0],
          [1, 0]
        ],
        10: [
          [1, 0],
          [-1, 0]
        ],
        12: [
          [0, -1],
          [0, 1]
        ],
        21: [
          [0, 1],
          [0, -1]
        ],
        23: [
          [1, 0],
          [-1, 0]
        ],
        32: [
          [-1, 0],
          [1, 0]
        ],
        30: [
          [0, 1],
          [0, -1]
        ],
        "03": [
          [0, -1],
          [0, 1]
        ],
        "02": [
          [1, 0],
          [2, 0],
          [1, 1],
          [2, 1],
          [-1, 0],
          [-2, 0],
          [-1, 1],
          [-2, 1],
          [0, -1],
          [3, 0],
          [-3, 0]
        ],
        13: [
          [0, 1],
          [0, 2],
          [-1, 1],
          [-1, 2],
          [0, -1],
          [0, -2],
          [-1, -1],
          [-1, -2],
          [1, 0],
          [0, 3],
          [0, -3]
        ],
        20: [
          [-1, 0],
          [-2, 0],
          [-1, -1],
          [-2, -1],
          [1, 0],
          [2, 0],
          [1, -1],
          [2, -1],
          [0, 1],
          [-3, 0],
          [3, 0]
        ],
        31: [
          [0, 1],
          [0, 2],
          [1, 1],
          [1, 2],
          [0, -1],
          [0, -2],
          [1, -1],
          [1, -2],
          [-1, 0],
          [0, 3],
          [0, -3]
        ]
      },
      i5_kicks: {
        "01": [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        10: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        12: [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        21: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        23: [
          [2, 0],
          [-2, 0],
          [2, -1],
          [-2, 2]
        ],
        32: [
          [-2, 0],
          [2, 0],
          [-2, 1],
          [2, -2]
        ],
        30: [
          [2, 0],
          [-2, 0],
          [2, 2],
          [-2, -1]
        ],
        "03": [
          [-2, 0],
          [2, 0],
          [-2, -2],
          [2, 1]
        ],
        "02": [
          [1, 0],
          [2, 0],
          [1, 1],
          [2, 1],
          [-1, 0],
          [-2, 0],
          [-1, 1],
          [-2, 1],
          [0, -1],
          [3, 0],
          [-3, 0]
        ],
        13: [
          [0, 1],
          [0, 2],
          [-1, 1],
          [-1, 2],
          [0, -1],
          [0, -2],
          [-1, -1],
          [-1, -2],
          [1, 0],
          [0, 3],
          [0, -3]
        ],
        20: [
          [-1, 0],
          [-2, 0],
          [-1, -1],
          [-2, -1],
          [1, 0],
          [2, 0],
          [1, -1],
          [2, -1],
          [0, 1],
          [-3, 0],
          [3, 0]
        ],
        31: [
          [0, 1],
          [0, 2],
          [1, 1],
          [1, 2],
          [0, -1],
          [0, -2],
          [1, -1],
          [1, -2],
          [-1, 0],
          [0, 3],
          [0, -3]
        ]
      },
      oo_kicks: {
        "01": [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        10: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        12: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        21: [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        23: [
          [0, -1],
          [-1, -1],
          [0, 1],
          [-1, 1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        32: [
          [1, 0],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        30: [
          [-1, 0],
          [0, -1],
          [-1, 1],
          [-1, -1],
          [1, 0],
          [1, -1],
          [1, 1]
        ],
        "03": [
          [0, -1],
          [1, -1],
          [0, 1],
          [1, 1],
          [-1, 0],
          [-1, -1],
          [-1, 1]
        ],
        "02": [[0, -1]],
        13: [[1, 0]],
        20: [[0, 1]],
        31: [[-1, 0]]
      },
      additional_offsets: {},
      spawn_rotation: {},
      color_overrides: {},
      preview_overrides: {}
    },
    "TETRA-X": {
      kicks: {
        "01": [
          [0, 1],
          [-1, 0],
          [1, 0],
          [-1, 1],
          [1, 1],
          [0, -1],
          [-1, -1],
          [1, -1]
        ],
        10: [
          [0, 1],
          [1, 0],
          [-1, 0],
          [1, 1],
          [-1, 1],
          [0, -1],
          [1, -1],
          [-1, -1]
        ],
        12: [
          [0, 1],
          [-1, 0],
          [1, 0],
          [-1, 1],
          [1, 1],
          [0, -1],
          [-1, -1],
          [1, -1]
        ],
        21: [
          [0, 1],
          [1, 0],
          [-1, 0],
          [1, 1],
          [-1, 1],
          [0, -1],
          [1, -1],
          [-1, -1]
        ],
        23: [
          [0, 1],
          [-1, 0],
          [1, 0],
          [-1, 1],
          [1, 1],
          [0, -1],
          [-1, -1],
          [1, -1]
        ],
        32: [
          [0, 1],
          [1, 0],
          [-1, 0],
          [1, 1],
          [-1, 1],
          [0, -1],
          [1, -1],
          [-1, -1]
        ],
        30: [
          [0, 1],
          [-1, 0],
          [1, 0],
          [-1, 1],
          [1, 1],
          [0, -1],
          [-1, -1],
          [1, -1]
        ],
        "03": [
          [0, 1],
          [1, 0],
          [-1, 0],
          [1, 1],
          [-1, 1],
          [0, -1],
          [1, -1],
          [-1, -1]
        ],
        "02": [
          [0, 1],
          [0, -1],
          [-1, 0],
          [1, 0]
        ],
        13: [
          [0, 1],
          [0, -1],
          [-1, 0],
          [1, 0]
        ],
        20: [
          [0, 1],
          [0, -1],
          [-1, 0],
          [1, 0]
        ],
        31: [
          [0, 1],
          [0, -1],
          [-1, 0],
          [1, 0]
        ]
      },
      i_kicks: {
        "01": [
          [0, -1],
          [0, -2],
          [0, 1],
          [1, -1],
          [-1, -1],
          [1, -2],
          [-1, -2]
        ],
        10: [
          [0, -1],
          [0, -2],
          [0, 1],
          [-1, 0],
          [1, 0],
          [2, 0]
        ],
        12: [
          [0, -1],
          [0, -2],
          [0, 1],
          [-1, 0],
          [1, 0],
          [2, 0]
        ],
        21: [
          [0, 1],
          [0, 2],
          [0, -1],
          [-1, 1],
          [1, 1],
          [-1, 2],
          [1, 2]
        ],
        23: [
          [0, 1],
          [0, 2],
          [0, -1],
          [1, 1],
          [-1, 1],
          [1, 2],
          [-1, 2]
        ],
        32: [
          [0, -1],
          [0, -2],
          [0, 1],
          [1, 0],
          [-1, 0],
          [-2, 0]
        ],
        30: [
          [0, -1],
          [0, -2],
          [0, 1],
          [1, 0],
          [-1, 0],
          [-2, 0]
        ],
        "03": [
          [0, -1],
          [0, -2],
          [0, 1],
          [-1, -1],
          [1, -1],
          [-1, -2],
          [1, -2]
        ],
        "02": [
          [0, -1],
          [0, 1]
        ],
        13: [
          [0, -1],
          [0, 1]
        ],
        20: [
          [0, -1],
          [0, 1]
        ],
        31: [
          [0, -1],
          [0, 1]
        ]
      },
      additional_offsets: {},
      spawn_rotation: {},
      color_overrides: {
        i1: "l",
        i2: "l",
        i3: "l",
        l3: "o",
        i5: "l",
        l: "o",
        o: "s",
        s: "i",
        i: "l",
        oo: "s"
      },
      preview_overrides: {}
    },
    NRS: {
      kicks: {
        "01": [],
        10: [],
        12: [],
        21: [],
        23: [],
        32: [],
        30: [],
        "03": [],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      additional_offsets: {
        z: [
          [1, 1],
          [1, 0],
          [1, 0],
          [2, 0]
        ],
        l: [
          [1, 0],
          [1, 0],
          [1, 0],
          [1, 0]
        ],
        o: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        s: [
          [1, 1],
          [1, 0],
          [1, 0],
          [2, 0]
        ],
        i: [
          [0, 1],
          [0, 0],
          [0, 0],
          [1, 0]
        ],
        j: [
          [1, 0],
          [1, 0],
          [1, 0],
          [1, 0]
        ],
        t: [
          [1, 0],
          [1, 0],
          [1, 0],
          [1, 0]
        ]
      },
      spawn_rotation: { z: 0, l: 2, o: 0, s: 0, i: 0, j: 2, t: 2 },
      color_overrides: {},
      preview_overrides: {
        l: [
          [0, 0, 201],
          [1, 0, 68],
          [2, 0, 124],
          [0, 1, 31]
        ],
        j: [
          [0, 0, 199],
          [1, 0, 68],
          [2, 0, 114],
          [2, 1, 31]
        ],
        t: [
          [0, 0, 199],
          [1, 0, 74],
          [2, 0, 124],
          [1, 1, 31]
        ]
      }
    },
    ARS: {
      kicks: {
        "01": [
          [1, 0],
          [-1, 0]
        ],
        10: [
          [1, 0],
          [-1, 0]
        ],
        12: [
          [1, 0],
          [-1, 0]
        ],
        21: [
          [1, 0],
          [-1, 0]
        ],
        23: [
          [1, 0],
          [-1, 0]
        ],
        32: [
          [1, 0],
          [-1, 0]
        ],
        30: [
          [1, 0],
          [-1, 0]
        ],
        "03": [
          [1, 0],
          [-1, 0]
        ],
        "02": [
          [1, 0],
          [-1, 0]
        ],
        13: [
          [1, 0],
          [-1, 0]
        ],
        20: [
          [1, 0],
          [-1, 0]
        ],
        31: [
          [1, 0],
          [-1, 0]
        ]
      },
      i_kicks: {
        "01": [],
        10: [],
        12: [],
        21: [],
        23: [],
        32: [],
        30: [],
        "03": [],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      additional_offsets: {
        i1: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        z: [
          [0, 1],
          [0, 0],
          [0, 0],
          [1, 0]
        ],
        l: [
          [0, 1],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        o: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        s: [
          [0, 1],
          [-1, 0],
          [0, 0],
          [0, 0]
        ],
        i: [
          [0, 0],
          [0, 0],
          [0, -1],
          [1, 0]
        ],
        j: [
          [0, 1],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        t: [
          [0, 1],
          [0, 0],
          [0, 0],
          [0, 0]
        ]
      },
      spawn_rotation: { z: 0, l: 2, o: 0, s: 0, i: 0, j: 2, t: 2 },
      color_overrides: {
        i1: "z",
        i2: "z",
        i3: "z",
        i5: "z",
        z: "s",
        s: "t",
        i: "z",
        t: "i"
      },
      preview_overrides: {
        l: [
          [0, 0, 201],
          [1, 0, 68],
          [2, 0, 124],
          [0, 1, 31]
        ],
        j: [
          [0, 0, 199],
          [1, 0, 68],
          [2, 0, 114],
          [2, 1, 31]
        ],
        t: [
          [0, 0, 199],
          [1, 0, 74],
          [2, 0, 124],
          [1, 1, 31]
        ]
      },
      center_column: {
        pieces: ["l", "j", "t"],
        rules: [
          [-1, -1],
          [0, -1],
          [1, -1],
          [-1, 0],
          [0, 0],
          [1, 0],
          [-1, 1],
          [0, 1],
          [1, 1]
        ]
      }
    },
    ASC: {
      kicks: {
        "01": [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        10: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        12: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        21: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        23: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        32: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        30: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        "03": [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      i_kicks: {
        "01": [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        10: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        12: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        21: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        23: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        32: [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        30: [
          [-1, 0],
          [0, 1],
          [-1, 1],
          [0, 2],
          [-1, 2],
          [-2, 0],
          [-2, 1],
          [-2, 2],
          [1, 0],
          [1, 1],
          [0, -1],
          [-1, -1],
          [-2, -1],
          [1, 2],
          [2, 0],
          [0, -2],
          [-1, -2],
          [-2, -2],
          [2, 1],
          [2, 2],
          [1, -1]
        ],
        "03": [
          [1, 0],
          [0, 1],
          [1, 1],
          [0, 2],
          [1, 2],
          [2, 0],
          [2, 1],
          [2, 2],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [1, -1],
          [2, -1],
          [-1, 2],
          [-2, 0],
          [0, -2],
          [1, -2],
          [2, -2],
          [-2, 1],
          [-2, 2],
          [-1, -1]
        ],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      allow_o_kick: true,
      additional_offsets: {
        i1: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        z: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        l: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        o: [
          [0, 0],
          [0, 1],
          [-1, 1],
          [-1, 0]
        ],
        s: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        i: [
          [0, 0],
          [-1, 0],
          [-1, -1],
          [0, -1]
        ],
        j: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        t: [
          [0, 0],
          [0, 0],
          [0, 0],
          [0, 0]
        ]
      },
      color_overrides: {},
      spawn_rotation: {},
      preview_overrides: {}
    },
    none: {
      kicks: {
        "01": [],
        10: [],
        12: [],
        21: [],
        23: [],
        32: [],
        30: [],
        "03": [],
        "02": [],
        13: [],
        20: [],
        31: []
      },
      additional_offsets: {},
      color_overrides: {},
      spawn_rotation: {},
      preview_overrides: {}
    }
  },
  cornerTable: {
    z: [
      [
        [-2, -1],
        [1, -1],
        [2, 0],
        [-1, 0]
      ],
      [
        [0, -1],
        [1, -2],
        [0, 2],
        [1, 1]
      ],
      [
        [-2, 0],
        [1, 0],
        [2, 1],
        [-1, 1]
      ],
      [
        [-1, -1],
        [0, -2],
        [0, 1],
        [-1, 2]
      ]
    ],
    l: [
      [
        [-1, -1],
        [0, -1],
        [1, 1],
        [-1, 1]
      ],
      [
        [-1, -1],
        [1, -1],
        [1, 0],
        [-1, 1]
      ],
      [
        [-1, -1],
        [1, -1],
        [1, 1],
        [0, 1]
      ],
      [
        [-1, 0],
        [1, -1],
        [1, 1],
        [-1, 1]
      ]
    ],
    s: [
      [
        [-1, -1],
        [2, -1],
        [1, 0],
        [-2, 0]
      ],
      [
        [0, -2],
        [1, -1],
        [1, 2],
        [0, 1]
      ],
      [
        [-1, 0],
        [2, 0],
        [1, 1],
        [-2, 1]
      ],
      [
        [-1, -2],
        [0, -1],
        [-1, 1],
        [0, 2]
      ]
    ],
    j: [
      [
        [0, -1],
        [1, -1],
        [1, 1],
        [-1, 1]
      ],
      [
        [-1, -1],
        [1, 0],
        [1, 1],
        [-1, 1]
      ],
      [
        [-1, -1],
        [1, -1],
        [0, 1],
        [-1, 1]
      ],
      [
        [-1, -1],
        [1, -1],
        [1, 1],
        [-1, 0]
      ]
    ],
    t: [
      [
        [-1, -1, 3, 0],
        [1, -1, 0, 1],
        [1, 1, 1, 2],
        [-1, 1, 2, 3]
      ],
      [
        [-1, -1, 3, 0],
        [1, -1, 0, 1],
        [1, 1, 1, 2],
        [-1, 1, 2, 3]
      ],
      [
        [-1, -1, 3, 0],
        [1, -1, 0, 1],
        [1, 1, 1, 2],
        [-1, 1, 2, 3]
      ],
      [
        [-1, -1, 3, 0],
        [1, -1, 0, 1],
        [1, 1, 1, 2],
        [-1, 1, 2, 3]
      ]
    ]
  },
  scoring: {
    SINGLE: 100,
    DOUBLE: 300,
    TRIPLE: 500,
    QUAD: 800,
    PENTA: 1200,
    TSPIN_MINI: 100,
    TSPIN: 400,
    TSPIN_MINI_SINGLE: 200,
    TSPIN_SINGLE: 800,
    TSPIN_MINI_DOUBLE: 400,
    TSPIN_DOUBLE: 1200,
    TSPIN_MINI_TRIPLE: 800,
    TSPIN_TRIPLE: 1600,
    TSPIN_MINI_QUAD: 1600,
    TSPIN_QUAD: 2600,
    TSPIN_PENTA: 3200,
    BACKTOBACK_MULTIPLIER: 1.5,
    COMBO: 50,
    ALL_CLEAR: 3500,
    SOFTDROP: 1,
    HARDDROP: 2
  },
  garbage: {
    SINGLE: 0,
    DOUBLE: 1,
    TRIPLE: 2,
    QUAD: 4,
    PENTA: 5,
    TSPIN_MINI: 0,
    TSPIN: 0,
    TSPIN_MINI_SINGLE: 0,
    TSPIN_SINGLE: 2,
    TSPIN_MINI_DOUBLE: 1,
    TSPIN_DOUBLE: 4,
    TSPIN_MINI_TRIPLE: 2,
    TSPIN_TRIPLE: 6,
    TSPIN_MINI_QUAD: 4,
    TSPIN_QUAD: 10,
    TSPIN_PENTA: 12,
    BACKTOBACK_BONUS: 1,
    BACKTOBACK_BONUS_LOG: 0.8,
    COMBO_MINIFIER: 1,
    COMBO_MINIFIER_LOG: 1.25,
    COMBO_BONUS: 0.25,
    ALL_CLEAR: 10,
    combotable: {
      none: [0],
      "classic guideline": [0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5],
      "modern guideline": [0, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4]
    }
  },
  finesse: {
    z: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 2, 2, 2, 1, 1, 2, 3, 2, 2, 9],
      2: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      3: [9, 9, 2, 2, 2, 1, 1, 2, 3, 2, 2]
    },
    l: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 2, 2, 3, 2, 1, 2, 3, 3, 2, 9],
      2: [9, 9, 3, 4, 3, 2, 3, 4, 4, 3, 9],
      3: [9, 9, 2, 3, 2, 1, 2, 3, 3, 2, 2]
    },
    o: {
      0: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9],
      2: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9],
      3: [9, 1, 2, 2, 1, 0, 1, 2, 2, 1, 9]
    },
    s: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 2, 2, 2, 1, 1, 2, 3, 2, 2, 9],
      2: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      3: [9, 9, 2, 2, 2, 1, 1, 2, 3, 2, 2]
    },
    i: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 1, 9, 9],
      1: [2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 9],
      2: [9, 9, 1, 2, 1, 0, 1, 2, 1, 9, 9],
      3: [9, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2]
    },
    j: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 2, 2, 3, 2, 1, 2, 3, 3, 2, 9],
      2: [9, 9, 3, 4, 3, 2, 3, 4, 4, 3, 9],
      3: [9, 9, 2, 3, 2, 1, 2, 3, 3, 2, 2]
    },
    t: {
      0: [9, 9, 1, 2, 1, 0, 1, 2, 2, 1, 9],
      1: [9, 2, 2, 3, 2, 1, 2, 3, 3, 2, 9],
      2: [9, 9, 3, 4, 3, 2, 3, 4, 4, 3, 9],
      3: [9, 9, 2, 3, 2, 1, 2, 3, 3, 2, 2]
    }
  },
  zenithRevivePrompts: [
    ["F", "combo", 3, "Perform a 3-Combo", 2, []],
    ["F", "double", 2, "Clear 2 Doubles", 2, []],
    ["F", "quad", 1, "Clear a Quad", 1, []],
    ["F", "lines", 6, "Clear 6 Lines", 1, []],
    ["F", "osingle", 1, "Clear a Single\nusing an O-Piece", 3, []],
    ["F", "odouble", 1, "Clear a Double\nusing an O-Piece", 3, []],
    ["F", "szdouble", 1, "Clear a Double\nusing an S or Z-Piece", 3, []],
    ["F", "ljtriple", 1, "Clear a Triple\nusing an L or J-Piece", 3, []],
    [
      "F",
      "iholdlines",
      3,
      "Clear 3 lines\nwhile holding an I-Piece",
      3,
      ["nohold"]
    ],
    ["F", "hold", 8, "Use Hold 8 times", 2, ["nohold"]],
    ["F", "rotate", 20, "Rotate 20 times", 2, []],
    ["F", "singleconsecutive", 2, "Clear 2 Singles in a row", 3, []],
    ["E", "spin", 1, "Perform any Spin", 2, []],
    ["E", "tspinsingle", 1, "Clear a T-Spin Single", 2, []],
    ["E", "tspindouble", 1, "Clear a T-Spin Double", 2, []],
    ["E", "szspin", 1, "Clear an S/Z-Spin", 1, []],
    ["E", "ljspin", 1, "Clear an L/J-Spin", 1, []],
    ["E", "combo", 5, "Perform a 5-Combo", 2, []],
    ["E", "iflat", 2, "Clear 2 Lines using\nhorizontal I-Pieces", 3, []],
    ["E", "pieces", 20, "Place 20 pieces", 2, []],
    ["E", "attack", 6, "Send 6 Attack", 1, []],
    ["E", "placeoconsecutive", 2, "Place 2 O-Pieces\nin a row", 3, ["nohold"]],
    [
      "E",
      "norotateclockwise",
      12,
      "Place 12 pieces while only\nrotating counterclockwise",
      4,
      []
    ],
    [
      "E",
      "singlenocombo",
      6,
      "Clear 6 Singles without\nstarting a combo",
      3,
      []
    ],
    ["D", "double", 4, "Clear 4 Doubles", 2, []],
    [
      "D",
      "spam",
      3,
      "Place 3 pieces in a row\nwithout moving or rotating",
      4,
      []
    ],
    [
      "D",
      "noclear",
      14,
      "Place 14 pieces in a row\nwithout clearing any lines",
      4,
      []
    ],
    ["D", "szdouble", 2, "Clear 2 Doubles\nusing S or Z-Pieces", 3, []],
    ["D", "ljtriple", 2, "Clear 2 Triples\nusing L or J-Pieces", 3, []],
    ["D", "ispinclear", 1, "Clear an I-Spin", 1, []],
    [
      "D",
      "upperhalfquad",
      1,
      "Clear a Quad in the\nupper half of the board",
      4,
      []
    ],
    ["D", "rotate", 80, "Rotate 80 times", 2, []],
    ["D", "quadcombo", 1, "Clear a Quad\nwhile on a 2+-Combo", 4, []],
    [
      "D",
      "szsingle",
      2,
      "Clear 2 Singles in a row\nusing S or Z-Pieces",
      4,
      []
    ],
    ["D", "combonohold", 3, "Perform a 3-Combo\nwithout using Hold", 3, []],
    [
      "D",
      "noclearspin",
      3,
      "Perform 3 Spins\nthat don't clear any lines",
      4,
      []
    ],
    ["D", "szljspin", 2, "Perform 2\nS/Z/L/J-Spins", 3, []],
    ["C", "tspintriple", 1, "Clear a T-Spin Triple", 2, []],
    [
      "C",
      "nohold",
      25,
      "Place 25 pieces in a row\nwithout using Hold",
      4,
      ["nohold"]
    ],
    ["C", "triple", 3, "Clear 3 Triples", 2, []],
    ["C", "b2b", 4, "Reach B2B x4", 1, []],
    ["C", "quadbuckets", 2, "Clear a Quad in\n2 different columns", 3, []],
    [
      "C",
      "holdconsecutive",
      12,
      "Use Hold on\n12 pieces in a row",
      3,
      ["nohold"]
    ],
    [
      "C",
      "softdrop",
      10,
      "Place 10 pieces without\nreleasing Soft Drop",
      4,
      []
    ],
    [
      "C",
      "top3rows",
      3,
      "Have part of your stack in\nthe top 3 rows for 3 seconds",
      4,
      []
    ],
    [
      "C",
      "linesnoti",
      10,
      "Clear 10 Lines without\nclearing with T or I-pieces",
      4,
      []
    ],
    ["C", "szspintriple", 1, "Clear an S/Z-Spin Triple", 2, []],
    [
      "C",
      "odoubleconsecutive",
      2,
      "Clear 2 Doubles consecutively\nusing two O-Pieces",
      4,
      ["nohold"]
    ],
    ["C", "tspinminiclear", 4, "Clear 4 T-Spin Minis", 2, []],
    ["C", "attack", 14, "Send 14 Attack", 1, []],
    [
      "C",
      "doublespiece",
      3,
      "Clear 3 Doubles\nwith the same type of piece",
      4,
      []
    ],
    ["C", "ljgarbage", 1, "Clear Garbage\nusing a L/J-Spin", 3, []],
    ["C", "szgarbage", 1, "Clear Garbage\nusing a S/Z-Spin", 3, []],
    ["C", "columnopiece", 3, "Place 3 O-Pieces\nin column 1", 3, []],
    ["C", "spinclear", 2, "Clear 2 Spins\nin one combo", 3, []],
    [
      "C",
      "iclearspam",
      1,
      "Clear a Single with an I-Piece\nwithout moving or rotating",
      4,
      []
    ],
    ["C", "holddas", 6, "Place 6 Pieces\nwithout releasing DAS", 3, []],
    ["B", "oclear", 6, "Clear 6 Lines\nusing O-Pieces", 3, []],
    [
      "B",
      "spinbuckets",
      3,
      "Clear Spin-Clears\nwith 3 different pieces",
      3,
      []
    ],
    ["B", "quad", 4, "Clear 4 Quads", 1, []],
    [
      "B",
      "spam",
      5,
      "Place 5 pieces in a row\nwithout moving or rotating",
      4,
      []
    ],
    ["B", "ljspintriple", 1, "Clear an L/J-Spin Triple", 2, []],
    ["B", "quadconsecutive", 2, "Clear 2 Quads in a row", 2, []],
    [
      "B",
      "singlesonly",
      8,
      "Clear 8 Singles without doing\nother clears or using Hold",
      4,
      []
    ],
    [
      "B",
      "nogarbage",
      4,
      "Have no Garbage Lines on\nyour board for 4 seconds",
      4,
      []
    ],
    ["B", "rotate", 300, "Rotate 300 times", 2, []],
    ["B", "nocancel", 8, "Don't cancel any\ngarbage for 8 seconds", 3, []],
    [
      "B",
      "tspindoubleup",
      1,
      "Clear a T-Spin Double\nwith the Piece pointing up",
      4,
      []
    ],
    [
      "B",
      "oclearspam",
      1,
      "Clear a Double with an O-Piece\nwithout moving or rotating",
      4,
      []
    ],
    ["B", "tnorotate", 3, "Place 3 T-Pieces\nwithout rotating any", 3, []],
    ["B", "tspincombo", 1, "Clear a T-Spin Double\nwhile on a 2+-Combo", 3, []],
    ["A", "combo", 7, "Perform a 7-Combo", 2, []],
    ["A", "ispindouble", 1, "Clear an I-Spin Double", 2, []],
    [
      "A",
      "szspinconsecutive",
      2,
      "Clear two S/Z-Spin\nDoubles consecutively",
      3,
      []
    ],
    [
      "A",
      "ljspinconsecutive",
      2,
      "Clear two L/J-Spin\nDoubles consecutively",
      3,
      []
    ],
    ["A", "colorclear", 1, "Perform a Color Clear", 2, []],
    ["A", "lines", 40, "Clear 40 Lines", 1, []],
    ["A", "combospin", 4, "Clear 4 Spins\nin one Combo", 3, []],
    [
      "A",
      "tspindtcolumn",
      1,
      "Clear a T-Spin Double/Triple\ncentered in column 1 or 10",
      3,
      []
    ]
  ],
  zenithReviveDecks: [
    { F: 0, E: 0, D: 0, C: 0, B: 0, A: 0 },
    { F: 1, E: 0, D: 0, C: 0, B: 0, A: 0 },
    { F: 2, E: 0, D: 0, C: 0, B: 0, A: 0 },
    { F: 3, E: 0, D: 0, C: 0, B: 0, A: 0 },
    { F: 2, E: 1, D: 0, C: 0, B: 0, A: 0 },
    { F: 1, E: 2, D: 0, C: 0, B: 0, A: 0 },
    { F: 0, E: 3, D: 0, C: 0, B: 0, A: 0 },
    { F: 0, E: 2, D: 1, C: 0, B: 0, A: 0 },
    { F: 0, E: 1, D: 2, C: 0, B: 0, A: 0 },
    { F: 0, E: 0, D: 3, C: 0, B: 0, A: 0 },
    { F: 0, E: 0, D: 2, C: 1, B: 0, A: 0 },
    { F: 0, E: 0, D: 1, C: 2, B: 0, A: 0 },
    { F: 0, E: 0, D: 0, C: 3, B: 0, A: 0 },
    { F: 0, E: 0, D: 0, C: 2, B: 1, A: 0 },
    { F: 0, E: 0, D: 0, C: 1, B: 2, A: 0 },
    { F: 0, E: 0, D: 0, C: 0, B: 3, A: 0 },
    { F: 0, E: 0, D: 0, C: 0, B: 2, A: 1 },
    { F: 0, E: 0, D: 0, C: 0, B: 1, A: 2, order: ["A", "B", "A"] }
  ],
  zenithFatigue: [
    [28080, [["dim", 0.7]]],
    [28200, [["dim", 0.9]]],
    [28320, [["dim", 0.5]]],
    [28440, [["dim", 0.8]]],
    [28560, [["dim", 0.3]]],
    [28680, [["dim", 0.1]]],
    [
      28800,
      [
        ["color", 16518572],
        ["unclearable"],
        ["shake", 5],
        [
          "waterfall",
          {
            msg: 'FATIGUE SETS IN<br><span style="font-size: 0.8em;">+2 PERMANENT LINES</span>',
            fgcolor: "#FFFFFF",
            bgcolor: "#801346",
            timeout: 5e3
          }
        ]
      ]
    ],
    [28830, [["unclearable"], ["shake", 5]]],
    [28860, [["dim", 1]]],
    [31680, [["dim", 0.7]]],
    [31800, [["dim", 0.9]]],
    [31920, [["dim", 0.5]]],
    [32040, [["dim", 0.8]]],
    [32160, [["dim", 0.3]]],
    [32280, [["dim", 0.1]]],
    [
      32400,
      [
        ["color", 16518572],
        ["receivemultiplier", 0.25],
        [
          "waterfall",
          {
            msg: 'YOUR BODY GROWS WEAK<br><span style="font-size: 0.8em;">receive 25% more garbage</span>',
            fgcolor: "#FFFFFF",
            bgcolor: "#801346",
            timeout: 5e3
          }
        ]
      ]
    ],
    [32460, [["dim", 1]]],
    [35280, [["dim", 0.7]]],
    [35400, [["dim", 0.9]]],
    [35520, [["dim", 0.5]]],
    [35640, [["dim", 0.8]]],
    [35760, [["dim", 0.3]]],
    [35880, [["dim", 0.1]]],
    [
      36e3,
      [
        ["color", 16518572],
        ["unclearable"],
        ["shake", 5],
        [
          "waterfall",
          {
            msg: 'ALL SENSES BLUR TOGETHER<br><span style="font-size: 0.8em;">+3 PERMANENT LINES</span>',
            fgcolor: "#FFFFFF",
            bgcolor: "#801346",
            timeout: 5e3
          }
        ]
      ]
    ],
    [36030, [["unclearable"], ["shake", 5]]],
    [36060, [["unclearable"], ["shake", 5]]],
    [36120, [["dim", 1]]],
    [38880, [["dim", 0.7]]],
    [39e3, [["dim", 0.9]]],
    [39120, [["dim", 0.5]]],
    [39240, [["dim", 0.8]]],
    [39360, [["dim", 0.3]]],
    [39480, [["dim", 0.1]]],
    [
      39600,
      [
        ["color", 16518572],
        ["receivemultiplier", 0.25],
        [
          "waterfall",
          {
            msg: 'YOUR CONSCIOUSNESS FADES<br><span style="font-size: 0.8em;">receive 25% more garbage</span>',
            fgcolor: "#FFFFFF",
            bgcolor: "#801346",
            timeout: 5e3
          }
        ]
      ]
    ],
    [39660, [["dim", 1]]],
    [42480, [["dim", [0.7, 0.65, 0.65]]]],
    [42600, [["dim", 0.9]]],
    [42720, [["dim", [0.5, 0.45, 0.45]]]],
    [42840, [["dim", 0.8]]],
    [42960, [["dim", [0.3, 0.25, 0.25]]]],
    [43080, [["dim", [0.1, 0.05, 0.05]]]],
    [
      43200,
      [
        ["color", 16711705],
        ["unclearable"],
        ["shake", 5],
        [
          "waterfall",
          {
            msg: 'THIS IS THE END.<br><span style="font-size: 0.8em;">+5 PERMANENT LINES</span>',
            fgcolor: "#FFFFFF",
            bgcolor: "#870815",
            timeout: 1e4
          }
        ]
      ]
    ],
    [43230, [["unclearable"], ["shake", 5]]],
    [43260, [["unclearable"], ["shake", 5]]],
    [43310, [["unclearable"], ["shake", 5]]],
    [43360, [["unclearable"], ["shake", 5]]],
    [43500, [["dim", 1]]]
  ],
  zenithFatigueRevEx: [
    [20880, [["dim", [0.7, 0.6, 0.6]]]],
    [21e3, [["dim", 0.9]]],
    [21120, [["dim", [0.5, 0.4, 0.4]]]],
    [21240, [["dim", 0.8]]],
    [21360, [["dim", [0.3, 0.2, 0.2]]]],
    [21480, [["dim", [0.2, 0, 0]]]],
    [
      21600,
      [
        ["color", 16518753],
        ["gracestillmessy"],
        [
          "waterfall",
          {
            msg: 'YOUR POWER SLIPS<br><span style="font-size: 0.8em;">garbage received becomes messier</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [21660, [["dim", 1]]],
    [24480, [["dim", [0.7, 0.6, 0.6]]]],
    [24600, [["dim", 0.9]]],
    [24720, [["dim", [0.5, 0.4, 0.4]]]],
    [24840, [["dim", 0.8]]],
    [24960, [["dim", [0.3, 0.2, 0.2]]]],
    [25080, [["dim", [0.2, 0, 0]]]],
    [
      25200,
      [
        ["color", 16518753],
        ["receivemultiplier", 0.25],
        [
          "waterfall",
          {
            msg: 'WHISPERS OF DISCONTENT SPREAD<br><span style="font-size: 0.8em;">receive 25% more garbage</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [25260, [["dim", 1]]],
    [28080, [["dim", [0.7, 0.6, 0.6]]]],
    [28200, [["dim", 0.9]]],
    [28320, [["dim", [0.5, 0.4, 0.4]]]],
    [28440, [["dim", 0.8]]],
    [28560, [["dim", [0.3, 0.2, 0.2]]]],
    [28680, [["dim", [0.2, 0, 0]]]],
    [
      28800,
      [
        ["color", 16518753],
        ["unclearable"],
        ["shake", 5],
        [
          "waterfall",
          {
            msg: 'PROTESTERS LINE THE STREETS<br><span style="font-size: 0.8em;">+3 PERMANENT LINES</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [28830, [["unclearable"], ["shake", 5]]],
    [28860, [["unclearable"], ["shake", 5]]],
    [28920, [["dim", 1]]],
    [31680, [["dim", [0.7, 0.6, 0.6]]]],
    [31800, [["dim", 0.9]]],
    [31920, [["dim", [0.5, 0.4, 0.4]]]],
    [32040, [["dim", 0.8]]],
    [32160, [["dim", [0.3, 0.2, 0.2]]]],
    [32280, [["dim", [0.2, 0, 0]]]],
    [
      32400,
      [
        ["color", 16518753],
        ["receivemultiplier", 0.25],
        [
          "waterfall",
          {
            msg: 'YOUR CLOSEST ALLIES DEFECT<br><span style="font-size: 0.8em;">receive 25% more garbage</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [32460, [["dim", 1]]],
    [35280, [["dim", [0.7, 0.6, 0.6]]]],
    [35400, [["dim", 0.9]]],
    [35520, [["dim", [0.5, 0.4, 0.4]]]],
    [35640, [["dim", 0.8]]],
    [35760, [["dim", [0.3, 0.2, 0.2]]]],
    [35880, [["dim", [0.2, 0, 0]]]],
    [
      36e3,
      [
        ["color", 16518753],
        ["unclearable"],
        ["shake", 5],
        [
          "waterfall",
          {
            msg: 'PARANOIA CLOUDS YOUR JUDGEMENT<br><span style="font-size: 0.8em;">+5 PERMANENT LINES</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [36030, [["unclearable"], ["shake", 5]]],
    [36060, [["unclearable"], ["shake", 5]]],
    [36110, [["unclearable"], ["shake", 5]]],
    [36160, [["unclearable"], ["shake", 5]]],
    [36300, [["dim", 1]]],
    [38880, [["dim", [0.7, 0.6, 0.6]]]],
    [39e3, [["dim", 0.9]]],
    [39120, [["dim", [0.5, 0.4, 0.4]]]],
    [39240, [["dim", 0.8]]],
    [39360, [["dim", [0.3, 0.2, 0.2]]]],
    [39480, [["dim", [0.2, 0, 0]]]],
    [
      39600,
      [
        ["color", 16518753],
        ["maxmessy"],
        [
          "waterfall",
          {
            msg: 'THE REVOLUTION HAS BEGUN<br><span style="font-size: 0.8em;">garbage received becomes much messier</span>',
            fgcolor: "#ff006f",
            bgcolor: "#420a25",
            timeout: 5e3
          }
        ]
      ]
    ],
    [39660, [["dim", 1]]],
    [42e3, [["dim", [0.7, 0.6, 0.6]]]],
    [42120, [["dim", 0.9]]],
    [42240, [["dim", [0.7, 0.4, 0.4]]]],
    [42360, [["dim", 0.9]]],
    [42480, [["dim", [0.5, 0.4, 0.4]]]],
    [42600, [["dim", 0.8]]],
    [42720, [["dim", [0.5, 0.2, 0.2]]]],
    [42840, [["dim", 0.8]]],
    [42960, [["dim", [0.3, 0.1, 0.1]]]],
    [43080, [["dim", [0.2, 0, 0]]]],
    [43140, [["dim", [0, 0, 0]]]],
    [
      43200,
      [
        ["color", 16711680],
        ["unclearable"],
        ["shake", 10],
        [
          "waterfall",
          {
            msg: 'THE END OF AN ERA.<br><span style="font-size: 0.8em;">+12 PERMANENT LINES</span>',
            fgcolor: "#ff2600",
            bgcolor: "#000000",
            timeout: 15e3
          }
        ]
      ]
    ],
    [43230, [["unclearable"], ["shake", 10]]],
    [43260, [["unclearable"], ["shake", 10]]],
    [43310, [["unclearable"], ["shake", 10]]],
    [43360, [["unclearable"], ["shake", 10]]],
    [43420, [["unclearable"], ["shake", 10]]],
    [43480, [["unclearable"], ["shake", 10]]],
    [43550, [["unclearable"], ["shake", 10]]],
    [43620, [["unclearable"], ["shake", 10]]],
    [43700, [["unclearable"], ["shake", 10]]],
    [43780, [["unclearable"], ["shake", 10]]],
    [43850, [["unclearable"], ["shake", 10]]],
    [43920, [["dim", 1]]]
  ],
  majorShoutStyles: {
    globalbest: () => {
      Al.play("confetti", { gui: true, count: 30 });
    },
    personalbest: () => {
      Al.play("confetti", { gui: true, count: 15, hue: [30, 60] });
    },
    lg_victory: () => {
      setTimeout(() => {
        Al.play("confetti", { gui: false, count: 15, hue: [30, 60] });
      }, 1250);
    }
  },
  globalShoutStyles: {},
  gameModes: {
    "40l": {
      version: y,
      gameid: "X-PASSTHRU",
      seed_random: false,
      anchorseed: true,
      seed: "X-PASSTHRU",
      allow180: true,
      spinbonuses: "all-mini+",
      g: 0.02,
      objective_type: "lines",
      objective_count: 40,
      handling: "X-PASSTHRU",
      countdown: "X-PASSTHRU",
      countdown_interval: "X-PASSTHRU",
      precountdown: "X-PASSTHRU",
      prestart: "X-PASSTHRU",
      mission: "X-PASSTHRU",
      zoominto: "X-PASSTHRU",
      bgmnoreset: "X-PASSTHRU",
      slot_counter1: "X-PASSTHRU",
      slot_counter2: "X-PASSTHRU",
      slot_counter3: "X-PASSTHRU",
      slot_counter4: "X-PASSTHRU",
      slot_counter5: "X-PASSTHRU",
      slot_bar2: "progress",
      can_retry: true,
      nolockout: true,
      pro: "X-PASSTHRU",
      pro_alert: "X-PASSTHRU",
      pro_retry: "X-PASSTHRU",
      stride: "X-PASSTHRU",
      no_szo: "X-PASSTHRU",
      fromretry: "X-PASSTHRU"
    },
    blitz: {
      version: y,
      gameid: "X-PASSTHRU",
      seed_random: false,
      anchorseed: true,
      seed: "X-PASSTHRU",
      allow180: true,
      objective_type: "timed",
      objective_time: 12e4,
      levels: true,
      levelspeed: 0.42,
      levelgbase: 0.65,
      gravitymay20g: false,
      handling: "X-PASSTHRU",
      countdown: "X-PASSTHRU",
      countdown_interval: "X-PASSTHRU",
      precountdown: "X-PASSTHRU",
      prestart: "X-PASSTHRU",
      mission: "X-PASSTHRU",
      zoominto: "X-PASSTHRU",
      bgmnoreset: "X-PASSTHRU",
      slot_counter1: "X-PASSTHRU",
      slot_counter2: "X-PASSTHRU",
      slot_counter3: "X-PASSTHRU",
      slot_counter4: "X-PASSTHRU",
      slot_counter5: "X-PASSTHRU",
      slot_bar2: "progress",
      can_retry: true,
      nolockout: true,
      pro: "X-PASSTHRU",
      pro_alert: "X-PASSTHRU",
      pro_retry: "X-PASSTHRU",
      stride: "X-PASSTHRU",
      no_szo: "X-PASSTHRU",
      fromretry: "X-PASSTHRU"
    }
  },
  Strings: {
    cleartypes: [
      "VOID",
      "SINGLE",
      "DOUBLE",
      "TRIPLE",
      "QUAD",
      "PENTA",
      "HEXA",
      "HEPTA",
      "OCTA",
      "ENNEA",
      "DECA",
      "HENDECA",
      "DODECA",
      "TRIADECA",
      "TESSARADECA",
      "PENTEDECA",
      "HEXADECA",
      "HEPTADECA",
      "OCTADECA",
      "ENNEADECA",
      "EICOSA",
      "KAGARIS"
    ],
    tspins: { mini: "\fc3MINI\f5 %%PIECE%%-spin", normal: "%%PIECE%%-spin" },
    extra: {
      btb: "back-to-back",
      btb_short: "BACK-TO-BACK",
      clear: "ALL\nCLEAR",
      colorclear: "COLOR\nCLEAR",
      zenlevel: "LEVEL\nCOMPLETE"
    },
    longTypeNames: {
      "40l": "40 LINES",
      blitz: "BLITZ",
      "5mblast": "5,000,000 BLAST",
      zen: "ZEN",
      custom: "CUSTOM GAME",
      league: "TETRA LEAGUE",
      zenith: "QUICK PLAY",
      zenithex: "EXPERT QUICK PLAY"
    },
    gameMissions: {
      "40l": "CLEAR 40 LINES!",
      blitz: "TWO-MINUTE BLITZ",
      "5mblast": "5,000,000 BLAST!",
      zen: "ZEN",
      "40 LINES": "CLEAR 40 LINES!",
      BLITZ: "TWO-MINUTE BLITZ",
      "5,000,000 BLAST": "5,000,000 BLAST!",
      ZEN: "ZEN"
    },
    zenithMods: {
      invisible: "Invisible",
      messy: "Messier Garbage",
      volatile: "Volatile Garbage",
      nohold: "No Hold",
      doublehole: "Double Hole Garbage",
      allspin: "All-Spin",
      gravity: "Gravity",
      expert: "Expert Mode",
      duo: "Duo",
      snowman: "Snowball Board",
      snowman_reversed: "Permafrost Board",
      invisible_reversed: "The Exile",
      messy_reversed: "Loaded Dice",
      volatile_reversed: "Last Stand",
      nohold_reversed: "Asceticism",
      doublehole_reversed: "Damnation",
      allspin_reversed: "The Warlock",
      gravity_reversed: "Freefall",
      expert_reversed: "The Tyrant"
    },
    zenithModsShort: {
      invisible: "IN",
      messy: "MS",
      volatile: "VL",
      nohold: "NH",
      doublehole: "DH",
      allspin: "AS",
      gravity: "GV",
      expert: "EX",
      duo: "2P",
      snowman: "SNOWBALL",
      snowman_reversed: "SNOWBALL-R",
      invisible_reversed: "IN-R",
      messy_reversed: "MS-R",
      volatile_reversed: "VL-R",
      nohold_reversed: "NH-R",
      doublehole_reversed: "DH-R",
      allspin_reversed: "AS-R",
      gravity_reversed: "GV-R",
      expert_reversed: "EX-R"
    }
  },
  allowedReverseCards: [
    "expert",
    "nohold",
    "messy",
    "gravity",
    "volatile",
    "doublehole",
    "invisible",
    "allspin",
    "snowman"
  ]
};

class k {
  constructor(e) {
    this.self = e;
  }
  get S() {
    return this.self.gsm;
  }
  get W() {
    return this.S.setoptions.boardwidth;
  }
  get H() {
    return this.S.setoptions.boardheight;
  }
  get B() {
    return this.S.setoptions.boardbuffer;
  }
  get T() {
    return this.B + this.H;
  }
  get Wh() {
    return this.W / 2;
  }
  get Hh() {
    return this.H / 2;
  }
  get sfx() {
    return this.self.sfx;
  }
  get id() {
    return this.S.setoptions.gameid;
  }
  get socket() {
    return this.self.iom.socket;
  }
  get options() {
    return this.S.setoptions;
  }
  OnClient(e) {
    this.self.c.OnClient(e);
  }
  IsServer(...e) {
    return this.self.c.IsServer(...e);
  }
  emit(...e) {
    return this.self.elm.emit(...e);
  }
}

class R extends k {
  static init() {
    ((this.ROTATION_LEFT = 1),
      (this.ROTATION_RIGHT = 2),
      (this.ROTATION_180 = 4),
      (this.ROTATION_SPIN = 8),
      (this.ROTATION_MINI = 16),
      (this.ROTATION_SPIN_ALL = 32),
      (this.ROTATION_ALL =
        this.ROTATION_LEFT |
        this.ROTATION_RIGHT |
        this.ROTATION_180 |
        this.ROTATION_SPIN |
        this.ROTATION_MINI |
        this.ROTATION_SPIN_ALL),
      (this.STATE_WALL = 64),
      (this.STATE_SLEEP = 128),
      (this.STATE_FLOOR = 256),
      (this.STATE_NODRAW = 512),
      (this.STATE_ALL =
        this.STATE_WALL |
        this.STATE_SLEEP |
        this.STATE_FLOOR |
        this.STATE_NODRAW),
      (this.ACTION_IHS = 1024),
      (this.ACTION_FORCELOCK = 2048),
      (this.ACTION_SOFTDROP = 4096),
      (this.ACTION_MOVE = 8192),
      (this.ACTION_ROTATE = 16384),
      (this.FLAGS_COUNT = 15));
  }
}
R.init();

class me {
  static FloorDistance = [
    0,
    50,
    150,
    300,
    450,
    650,
    850,
    1100,
    1350,
    1650,
    1 / 0
  ];
  static GravityBumps = [0, 0.48, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3];
  static GLockDelay = [0, 30, 29, 28, 27, 26, 24, 22, 20, 18, 16];
  static GRLockDelay = [0, 24, 22, 20, 18, 16, 15, 14, 13, 12, 11];
  static SpeedrunReq = [7, 8, 8, 9, 9, 10, 0, 0, 0, 0, 0];
  static Mods = [
    "invisible",
    "messy",
    "volatile",
    "nohold",
    "doublehole",
    "allspin",
    "gravity",
    "expert",
    "duo",
    "snowman"
  ];
  static TargetingGraceRevEx = [
    0, 1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1
  ];
  static RevNoHoldHoleSideChangeChance = [
    0.1, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55
  ];
  static ReviveLevelIncrease = [1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3];
  static CancelingFatigueBumpCap = [
    4,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    1 / 0,
    1 / 0,
    1 / 0
  ];
}

class O {
  static DisplayCounters = {
    timer: "time",
    stopwatch: "time",
    level: "level",
    lines: "lines",
    allclears: "all clears",
    hold: "hold",
    pieces: "pieces",
    pieces_duo: "pieces",
    finesse_l: "finesse",
    finesse: "finesse",
    keys: "inputs",
    score: "score",
    spp: "score",
    garbage: "garbage",
    attack: "attack",
    attack_duo: "attack",
    vs: "VS score",
    kills: "KO's",
    kills_duo: "KO's",
    placement: "placement"
  };
  static DisplayCountersList = Object.keys(this.DisplayCounters);
}

class ge {
  static OptionsList = {
    version: { default: x, static: true },
    gameid: { default: 0, min: 0, max: 8192, strict: true },
    seed: { default: 0 },
    seed_random: { default: false },
    score: { default: 0 },
    are: { default: 0 },
    lineclear_are: { default: 0 },
    g: { default: 0.02 },
    gincrease: { default: 0 },
    gmargin: { default: 0 },
    gravitymay20g: { default: true },
    shielded: { default: 0 },
    hasgarbage: { default: false },
    usebombs: { default: false },
    garbagespeed: { default: 20, integer: true, min: 1 },
    garbagefavor: { default: 0 },
    garbagemultiplier: { default: 1 },
    receivemultiplier: { default: 1 },
    cancelmultiplier: { default: 1 },
    garbagemargin: { default: 0 },
    garbageincrease: { default: 0 },
    garbageholesize: { default: 1 },
    garbagephase: { default: 0 },
    garbagequeue: { default: false },
    garbageentry: {
      default: "instant",
      allowed: ["instant", "continuous", "delayed"]
    },
    garbageare: { default: 5, integer: true, min: 1 },
    garbagearebump: { default: 12, integer: true, min: 0 },
    garbagecap: { default: 8 },
    garbagecapincrease: { default: 0 },
    garbagecapmargin: { default: 0 },
    garbagecapmax: { default: 40 },
    garbageabsolutecap: { default: 0 },
    garbageattackcap: { default: 0 },
    garbagetargetbonus: {
      default: "none",
      allowed: ["none", "defensive", "offensive"]
    },
    garbageblocking: {
      default: "combo blocking",
      allowed: ["none", "combo blocking", "limited blocking"]
    },
    passthrough: {
      default: "zero",
      allowed: ["zero", "limited", "consistent", "full"]
    },
    openerphase: { default: 0 },
    roundmode: { default: "down", allowed: ["down", "rng"] },
    garbagespecialbonus: { default: false },
    spinbonuses: { default: "T-spins", allowed: se.SpinRules },
    combotable: {
      default: "multiplier",
      allowed: ["none", "multiplier", "classic guideline", "modern guideline"]
    },
    kickset: {
      default: "SRS+",
      possibles: ["none", "SRS", "SRS+", "TETRA-X", "NRS", "ARS", "ASC"]
    },
    bagtype: { default: "7-bag", allowed: I.BagList },
    messiness_change: { default: 1 },
    messiness_inner: { default: 0 },
    messiness_nosame: { default: false },
    messiness_center: { default: false },
    messiness_timeout: { default: 0 },
    b2bchaining: { default: false },
    b2bcharging: { default: false },
    b2bextras: { default: false },
    b2bcharge_at: { default: 4, integer: true, min: 0, max: 10 },
    b2bcharge_base: { default: 0, integer: true, min: 0, max: 10 },
    allclears: { default: true },
    allclear_garbage: { default: 10, integer: true, min: 0 },
    allclear_b2b: { default: 0, integer: true, min: 0 },
    allclear_b2b_sends: { default: false },
    allclear_b2b_dupes: { default: true },
    allclear_charges: { default: false },
    allow_harddrop: { default: true },
    allow180: { default: false },
    infinite_hold: { default: false },
    infinite_movement: { default: false },
    nextcount: { default: 5, integer: true, min: 1, max: 6 },
    clutch: { default: true },
    no_szo: { default: false },
    nolockout: { default: false },
    manual_allowed: { default: true },
    new_payback: { default: false },
    can_undo: { default: false },
    boardwidth: { default: 10, min: 4, max: 100 },
    boardheight: { default: 20, min: 1, max: 100 },
    boardbuffer: { default: 20, min: 0, max: 100 },
    stock: { default: 0, min: 0, max: 10 },
    infinite_stock: { default: false },
    locktime: { default: 30 },
    lockresets: { default: 15, min: 0, max: 30 },
    prestart: { default: 0 },
    precountdown: { default: 0 },
    countdown: { default: false },
    countdown_count: { default: 3 },
    countdown_interval: { default: 1e3 },
    inverted: { default: false },
    mission: { default: "" },
    mission_type: {
      default: "mission",
      allowed: ["mission", "mission_free", "mission_versus", "mission_league"]
    },
    no_mission_sound: { default: false },
    objective_type: { default: "none", allowed: ["none", "lines", "timed"] },
    objective_count: { default: 0 },
    objective_time: { default: 0 },
    objective_result: { default: "", allowed: ["", "score", "time", "lines"] },
    zoominto: {
      default: "none",
      allowed: ["none", "slow", "fast", "cinematic", "fade", "zenithduoleft"]
    },
    noextrawidth: { default: false },
    stride: { default: false },
    pro: { default: false },
    pro_alert: { default: false },
    pro_retry: { default: false },
    can_retry: { default: false },
    slot_counter1: { default: "", allowed: ["", ...O.DisplayCountersList] },
    slot_counter2: { default: "", allowed: ["", ...O.DisplayCountersList] },
    slot_counter3: { default: "", allowed: ["", ...O.DisplayCountersList] },
    slot_counter4: { default: "", allowed: ["", ...O.DisplayCountersList] },
    slot_counter5: { default: "", allowed: ["", ...O.DisplayCountersList] },
    slot_bar1: { default: "", allowed: ["", "impending", "progress"] },
    slot_bar2: { default: "", allowed: ["", "impending", "progress"] },
    absolute_lines: { default: false },
    display_zen: { default: false },
    display_username: { default: false },
    display_fire: { default: false },
    display_replay: { default: false },
    display_next: { default: true },
    display_hold: { default: true },
    display_shadow: { default: true },
    levels: { default: false },
    masterlevels: { default: false },
    startinglevel: { default: 1 },
    levelspeed: { default: 1 },
    levelstatic: { default: false },
    levelstaticspeed: { default: 10 },
    levelgbase: { default: 0.8 },
    levelgspeed: { default: 0.007 },
    minoskin: {
      default: {
        z: "tetrio",
        l: "tetrio",
        o: "tetrio",
        s: "tetrio",
        i: "tetrio",
        j: "tetrio",
        t: "tetrio",
        other: "tetrio",
        ghost: "tetrio"
      }
    },
    boardskin: { default: "generic", possibles: ["generic", "tetrio"] },
    map: { default: "" },
    handling: { default: {} },
    room_handling: { default: false },
    room_handling_arr: { default: 2 },
    room_handling_das: { default: 10 },
    room_handling_sdf: { default: 6 },
    noreplay: { default: false },
    nosound: { default: false },
    bgmnoreset: { default: false },
    neverstopbgm: { default: false },
    song: {
      default: "RANDOMcalm",
      possibles: ["none", "RANDOM", "RANDOMcalm", "RANDOMbattle"]
    },
    survivalmode: { default: "none", allowed: ["none", "layer", "timer"] },
    survival_messiness: { default: 0 },
    survival_layer_amt: { default: 10 },
    survival_layer_non: { default: false },
    survival_layer_min: { default: 0 },
    survival_timer_itv: { default: 1 },
    survival_cap: { default: 0 },
    invisible: { default: false },
    master_invisible: { default: false },
    void_holes: { default: 0, integer: true, min: 0, max: 15 },
    void_holes_hungryness: { default: 12, integer: true, min: 1 },
    tutorial: { default: false },
    usezenconfig: { default: false },
    zenlevels: { default: false },
    zenlevel: { default: 1 },
    zenprogress: { default: 0 },
    nosiren: { default: false },
    anchorseed: { default: false },
    forfeit_time: { default: 60 },
    username: { default: "" },
    latencymode: {
      default: "medium",
      allowed: ["zero", "low", "medium", "high", "xhigh"]
    },
    fulloffset: { default: 300 },
    fullinterval: { default: 300 },
    fromretry: { default: false },
    retryisclear: { default: false },
    topoutisclear: { default: false },
    zenith: { default: false },
    zenith_expert: { default: false },
    zenith_doublehole: { default: false },
    zenith_volatile: { default: false },
    zenith_gravity: { default: false },
    zenith_messy: { default: false },
    zenith_allspin: { default: false },
    zenith_duo: { default: false },
    zenith_mods: { default: [], allowed: me.Mods },
    zenith_ally: { default: [] },
    zenith_allyexpert: { default: false },
    TEMP_zenith_rng: { default: false },
    TEMP_zenith_grace: { default: "" }
  };
  static DeprecatedOptions = [
    "garbagequadbonus",
    "garbagespinbonus",
    "garbageaspinbonus"
  ];
  static localGameID = 0;
  static init() {
    this.OptionsTemplate = {};
    for (const [e, t] of Object.entries(this.OptionsList)) {
      this.OptionsTemplate[e] = t.default;
      const s = b(t.default);
      switch (s) {
        case "boolean":
        case "number":
        case "array":
        case "object":
          t.type = s;
          break;
        case "string":
          t.type = t.allowed || t.possibles ? "table" : "string";
          break;
        default:
          throw new TypeError(
            `Error while templating ${e}: typeof ${s} is not supported as default values`
          );
      }
    }
  }
  static *ValidateOptions(e) {
    const { OptionsList: s } = this;
    let n = 0;
    for (let [i, o] of Object.entries(e)) {
      if (!(i in s)) {
        if (ge.DeprecatedOptions.includes(i)) continue;
        const e = `Unknown game option received | key: ${i} -> value: ${o} | Please report this message to the developers!`;
        if ((n++, "production" === _.mode)) {
          console.warn(e);
          continue;
        }
        throw new ReferenceError(e);
      }
      if (typeof o != typeof s[i].default)
        throw new TypeError(
          `Options "${i}" type mismatch | actual: ${typeof o} -> expected: ${typeof s[i].default} | Please report this message to the developers!`
        );
      const { integer: e, min: a, max: r, strict: l } = s[i];
      if (l && (o < a || o > r))
        throw new RangeError(
          `Options "${i}" out of range | actual: ${o} -> expected: ${a} .. ${r} | Please report this message to the developers!`
        );
      ((a || r) && (o = Math.min(r ?? 1 / 0, Math.max(a ?? -1 / 0, o))),
        e && (o = Math.floor(o)),
        (s[i].static ||
          (s[i].default !== o && !strictShallowEqual(s[i].default, o))) &&
          (yield [i, o]));
    }
    n > 0 &&
      Zt({
        msg: `this replay contains one or more unknown options ${n}`,
        color: "#FFD800",
        icon: "warning",
        timeout: 7500
      });
  }
}
ge.init();
export class Bits {
  static MAX_BITS = Number.MAX_SAFE_INTEGER.toString(2).length;

  constructor(input) {
    if (typeof input === "number") {
      this.buffer = Buffer.alloc(Math.ceil(input / 8));
    } else {
      if (!(input instanceof Buffer)) {
        throw new TypeError(
          "Initialize by specifying a bit-length or referencing a Buffer"
        );
      }
      this.buffer = input;
    }
    this._length = 8 * this.buffer.length;
    this._offset = 0;
  }

  static alloc(size, fill, encoding) {
    return new Bits(Buffer.alloc(size, fill, encoding));
  }

  static from(data, encoding, length) {
    return new Bits(Buffer.from(data, encoding, length));
  }

  get eof() {
    return this._offset === this._length;
  }

  get length() {
    return this._length;
  }

  get offset() {
    return this._offset;
  }

  set offset(val) {
    if (val < 0) throw new RangeError("Cannot set offset below 0");
    if (val > this._length) {
      throw new RangeError(
        `Cannot set offset to ${val}, buffer length is ${this._length}`
      );
    }
    this._offset = Math.floor(val);
    return this;
  }

  get remaining() {
    return this._length - this._offset;
  }

  clear(fill = 0) {
    this.buffer.fill(fill);
    this._offset = 0;
    return this;
  }

  clearBit(pos) {
    this.insert(0, 1, pos);
    return this;
  }

  flipBit(pos) {
    const bit = 1 ^ this.peek(1, pos);
    this.modifyBit(bit, pos);
    return bit;
  }

  getBit(pos) {
    return this.peek(1, pos);
  }

  insert(value, size = 1, offset) {
    let r = typeof offset === "number" ? offset | 0 : this._offset;
    if (r + size > this._length) {
      throw new RangeError(
        `Cannot write ${size} bits, only ${this.remaining} bit(s) left`
      );
    }
    if (size > Bits.MAX_BITS) {
      throw new RangeError(
        `Cannot write ${size} bits, max is ${Bits.MAX_BITS}`
      );
    }

    let remaining = size;
    while (remaining > 0) {
      const byteIndex = r >> 3;
      const bitIndex = r & 7;
      const chunkSize = Math.min(8 - bitIndex, remaining);
      const mask = (1 << chunkSize) - 1;
      const shift = 8 - chunkSize - bitIndex;
      const chunk = ((value >>> (remaining - chunkSize)) & mask) << shift;

      this.buffer[byteIndex] =
        (this.buffer[byteIndex] & ~(mask << shift)) | chunk;

      r += chunkSize;
      remaining -= chunkSize;
    }
    return r;
  }

  modifyBit(value, pos) {
    this.insert(value, 1, pos);
    return this;
  }

  peek(size = 1, offset) {
    let r = typeof offset === "number" ? offset | 0 : this._offset;
    if (r + size > this._length) {
      throw new RangeError(
        `Cannot read ${size} bits, only ${this.remaining} bit(s) left`
      );
    }
    if (size > Bits.MAX_BITS) {
      throw new RangeError(
        `Reading ${size} bits would overflow result, max is ${Bits.MAX_BITS}`
      );
    }

    const bitIndex = r & 7;
    const firstSize = Math.min(8 - bitIndex, size);
    const mask = (1 << firstSize) - 1;

    let result = (this.buffer[r >> 3] >> (8 - firstSize - bitIndex)) & mask;
    r += firstSize;

    let remaining = size - firstSize;
    while (remaining >= 8) {
      result = (result << 8) | this.buffer[r >> 3];
      r += 8;
      remaining -= 8;
    }

    if (remaining > 0) {
      const shift = 8 - remaining;
      result =
        (result << remaining) |
        ((this.buffer[r >> 3] >> shift) & (255 >> shift));
    }

    return result;
  }

  read(size = 1) {
    const value = this.peek(size, this._offset);
    this._offset += size;
    return value;
  }

  seek(val, whence = 1) {
    switch (whence) {
      case 2: // relative
        this.offset += val;
        break;
      case 3: // from end
        this.offset = this.length - val;
        break;
      default: // absolute
        this.offset = val;
    }
    return this;
  }

  setBit(pos) {
    this.insert(1, 1, pos);
    return this;
  }

  skip(size) {
    return this.seek(size, 2);
  }

  testBit(pos) {
    return !!this.peek(1, pos);
  }

  toString(encoding = "utf8") {
    return this.buffer.toString(encoding);
  }

  write(value, size = 1) {
    this._offset = this.insert(value, size, this._offset);
    return this;
  }
}

const n = Bits;
ge.init();
const Ce = {
  int64AsType: "number",
  bundleStrings: false,
  sequential: false
};
const ke = new (class {
  _commands = new Map();
  _codes = new Map();
  _PACK = null;
  _UNPACK = null;
  SymCmd = Symbol("cmd");
  FLAG = {
    F_ALLOC: 1,
    F_HOOK: 2,
    F_ID: 128
  };
  SetMsgpackr(e, t) {
    this._PACK = e.pack.bind(e);
    this._UNPACK = t.unpack.bind(t);
  }
  GetHandlers() {
    const It = [];
    for (const e of this._commands.values()) {
      if (e.flags & this.FLAG.F_HOOK) {
        It.push(e.name);
      }
    }
    const Ft = this._commands.get("__pack__")?.table;
    if (Ft) {
      It.push.apply(It, Object.keys(Ft));
    }
    return It;
  }
  Add(t, s) {
    this._commands.set(t, s);
    this._codes.set(s.code, s);
    s.name = t;
    if (s.flags & this.FLAG.F_ALLOC) {
      s.buffer = Buffer.from([s.code]);
    }
    if (s.table) {
      s._kv = new Map();
      s._vk = new Map();
      s.getkv = (e) => s._kv.get(e);
      s.getvk = (e) => s._vk.get(e);
      for (const [e, t] of Object.entries(s.table))
        (s._kv.set(e, t), s._vk.set(t, e));
    }
  }
  Encode(t, s, n = {}) {
    const i = this._commands.get(t) ?? this._commands.get("__pack__");
    let o = i.code,
      a = 1;
    if (i.flags & this.FLAG.F_ALLOC) return i.buffer;
    if (!n.batched && (i.flags & this.FLAG.F_ID || n.id)) {
      a += 3;
      o |= this.FLAG.F_ID;
    }
    const r = i.encode(s, this._PACK, t),
      l = Buffer.allocUnsafe(a + r.byteLength);
    l.writeUInt8(o, 0);
    l.set(r, a);
    return l;
  }
  Decode(e) {
    const t = new n(e),
      s = t.peek(6, 2),
      i = this._codes.get(s),
      o = {
        command: i?.name
      };
    let a = 1;
    if (!i)
      throw new ReferenceError(
        `received an unknown code [0x${s.toString(16).padStart(2, "0")}]`
      );
    if (i.flags & this.FLAG.F_ALLOC) return o;
    if (e[0] & this.FLAG.F_ID) {
      o.id = t.peek(24, 8);
      a += 3;
    }
    e = e.subarray(a);
    try {
      o.data = i.decode(e, this._UNPACK);
    } catch (t) {
      console.error(`Failed to decode command ${i.name}: ${e.toString()}`);
      throw t;
    }
    if (this.SymCmd in o.data) {
      o.command = o.data[this.SymCmd];
      o.data = o.data.data;
    }
    return o;
  }
})();
{
  const { F_ALLOC: t, F_HOOK: s, F_ID: n } = ke.FLAG,
    i = {
      code: 25
    };
  i.flags = t;
  ke.Add("new", i);
  const o = {
    code: 63
  };
  o.flags = t;
  ke.Add("die", o);
  const a = {
    code: 19
  };
  a.flags = s | t;
  ke.Add("rejected", a);
  const r = {
    code: 33
  };
  r.flags = s | t;
  ke.Add("reload", r);
  ke.Add("ping", {
    code: 9,
    flags: s,
    encode({ recvid: t }) {
      const s = Buffer.allocUnsafe(4);
      s.writeUInt32BE(t, 0);
      return s;
    },
    decode(e) {
      return {
        recvid: e.readUInt32BE(0)
      };
    }
  });
  ke.Add("session", {
    code: 44,
    encode({ ribbonid: t, tokenid: s }) {
      const n = Buffer.allocUnsafe(16);
      n.write(t, 0, 8, "hex");
      n.write(s, 8, 8, "hex");
      return n;
    },
    decode: (e) => ({
      ribbonid: e.toString("hex", 0, 8),
      tokenid: e.toString("hex", 8, 16)
    })
  });
  ke.Add("packets", {
    code: 7,
    encode({ packets: t }) {
      const s = t.reduce((e, t) => e + t.length, 0),
        n = Buffer.allocUnsafe(s + 4 * t.length);
      for (let e = 0, s = 0; e < t.length; e++) {
        const i = t[e];
        n.writeUInt32BE(i.length, s);
        n.set(i, s + 4);
        s += i.length + 4;
      }
      return n;
    },
    decode(e) {
      const t = [];
      for (let s = 0; s < e.length; ) {
        const n = e.readUInt32BE(s);
        s += 4;
        const i = e.subarray(s, s + n);
        t.push(i);
        s += n;
      }
      return {
        packets: t
      };
    }
  });
  ke.Add("kick", {
    table: {
      outdated: 1,
      kick: 2,
      restrict: 3,
      block: 4,
      anticheat: 5,
      manual: 6,
      rename: 7
    },
    flags: s,
    code: 4,
    encode({ reason: t }) {
      let s = Buffer.allocUnsafe(1);
      const n = this.getkv(t);
      s.writeUInt8(n, 0);
      if (!n) {
        s = Buffer.concat([s, Buffer.from(t)]);
      }
      return s;
    },
    decode(e) {
      const t = e.readUInt8(0);
      let s = this.getvk(t);
      if (!s) {
        s = e.toString("utf8", 1);
      }
      return {
        reason: s
      };
    }
  });
  ke.Add("nope", {
    table: {
      "protocol violation": 0,
      "ribbon expired": 1
    },
    code: 42,
    encode({ reason: t }) {
      return Buffer.from([this.getkv(t)]);
    },
    decode(e) {
      const t = e.readUInt8(0);
      return {
        reason: this.getvk(t)
      };
    }
  });
  ke.Add("pni", {
    table: {
      background: 0,
      split: 1,
      load: 2
    },
    code: 51,
    flags: s,
    encode({ type: t, timeout: s }) {
      const n = Buffer.allocUnsafe(3);
      n.writeUInt8(this.getkv(t), 0);
      n.writeUInt16BE(s, 1);
      return n;
    },
    decode(e) {
      return {
        type: this.getvk(e.readUInt8(0)),
        timeout: e.readUInt16BE(1)
      };
    }
  });
  ke.Add("notify", {
    table: {
      deny: 1,
      warm: 2,
      ok: 3,
      error: 4,
      announce: 5
    },
    code: 49,
    flags: s | n,
    encode(t, s) {
      const n = this.getkv(t.type),
        i = Buffer.from([n]);
      switch (n) {
        case 1: {
          const s = Buffer.allocUnsafe(2 + t.msg.length);
          s.writeUInt16BE(t.timeout);
          s.write(t.msg, 2);
          return Buffer.concat([i, s]);
        }
        case 2:
        case 3:
        case 4:
        case 5:
          return Buffer.concat([i, Buffer.from(t.msg)]);
        default:
          return Buffer.concat([i, s(t)]);
      }
    },
    decode(e, t) {
      const s = e.readUInt8(0),
        n = this.getvk(s);
      switch (s) {
        case 1:
          return {
            type: n,
            timeout: e.readUInt16BE(1),
            msg: e.toString("utf8", 3)
          };
        case 2:
        case 3:
        case 4:
        case 5:
          return {
            type: n,
            msg: e.toString("utf8", 1)
          };
        default:
          return t(e.subarray(1));
      }
    }
  });
  ke.Add("__pack__", {
    table: {
      "config.handling": 1,
      "channel.subscribe": 2,
      "channel.unsubscribe": 3,
      "social.presence": 16,
      "social.invite": 17,
      "social.link": 18,
      "social.online": 19,
      "social.notification": 20,
      "social.notification.ack": 21,
      "social.dm": 22,
      "social.dm.fail": 23,
      "social.relation.ack": 24,
      "social.relation.add": 25,
      "social.relation.remove": 26,
      "social.relation.update": 27,
      "social.relation.clear": 28,
      "social.party.invite": 29,
      "social.party.invite.accept": 30,
      "game.enter": 48,
      "game.replace": 49,
      "game.forfeit": 50,
      "game.ready": 51,
      "game.start": 52,
      "game.spectate": 53,
      "game.submit": 54,
      "game.advance": 55,
      "game.abort": 56,
      "game.end": 57,
      "game.score": 58,
      "game.waitstate": 59,
      "game.match": 60,
      "game.match.score": 61,
      "game.replay": 62,
      "game.replay.enter": 63,
      "game.replay.ige": 64,
      "game.replay.state": 65,
      "game.replay.board": 66,
      "game.replay.end": 67,
      "game.scope.start": 68,
      "game.scope.end": 69,
      "game.setspec": 70,
      "game.records.revolved": 71,
      "party.ready": 80,
      "party.leave": 81,
      "party.members": 83,
      "party.sync": 82,
      "staff.chat": 96,
      "staff.spam": 97,
      "staff.warn": 98,
      "staff.silence": 99,
      "staff.lift": 100,
      "staff.kickfail": 101,
      "staff.shout": 102,
      "staff.waterfall": 103,
      "staff.game.event": 104,
      "staff.xrc": 105,
      "room.create": 128,
      "room.join": 129,
      "room.leave": 130,
      "room.abort": 131,
      "room.start": 132,
      "room.kick": 133,
      "room.unban": 134,
      "room.banlist": 135,
      "room.setid": 136,
      "room.setconfig": 137,
      "room.update": 138,
      "room.update.bracket": 139,
      "room.update.host": 140,
      "room.update.auto": 141,
      "room.update.supporter": 142,
      "room.player.add": 143,
      "room.player.remove": 144,
      "room.bracket.switch": 145,
      "room.bracket.move": 146,
      "room.owner.transfer": 147,
      "room.owner.revoke": 148,
      "room.chat": 149,
      "room.chat.send": 150,
      "room.chat.clear": 151,
      "room.chat.delete": 152,
      "room.chat.gift": 153,
      "room.chat.game": 154,
      "room.call": 155,
      "league.enter": 177,
      "league.leave": 178,
      "league.match": 179,
      "league.counts": 180,
      "league.ready": 181,
      "server.maintenance": 208,
      "server.announcement": 209,
      "server.authorize": 210,
      "server.migrate": 211,
      "server.migrated": 212,
      "xrc.relog": 255
    },
    flags: n,
    code: 43,
    encode(t, s, n) {
      const i = s(t),
        o = Buffer.allocUnsafe(1 + i.length),
        a = this.getkv(n);
      o.writeUInt8(a, 0);
      o.set(i, 1);
      return o;
    },
    decode(e, t) {
      const s = e.readUInt8(0),
        n = this.getvk(s),
        i = t(e.subarray(1));
      return {
        [ke.SymCmd]: n,
        data: i
      };
    }
  });
}
class Ie {
  static TYPES = {
    Table: 0,
    Array: 1,
    Struct: 2,
    String: 3,
    Buffer: 4,
    Boolean: 5,
    Int: 6,
    UInt: 7,
    DInt: 8,
    Float: 9,
    UFloat: 10,
    Double: 11,
    Number: 12,
    Any: 13
  };
  static TYPES_INDEX = Array.from(Object.keys(this.TYPES));
  static SUPPORTED_TYPES = new Set([
    "undefined",
    "null",
    "boolean",
    "number",
    "string",
    "array"
  ]);
  static cla32(e) {
    return e >>> 0 === e
      ? Math.max(32 - Math.clz32(e), 1)
      : Math.max(32 - Math.clz32(~e) + 1, 2);
  }
  static GetIntSize(e) {
    return Math.ceil(this.cla32(e) / 4);
  }
  static DInt = class {
    constructor({ min: e, max: t }) {
      this._minBits = e;
      this._maxBits = t;
      this._minSize = Math.pow(2, e);
      this._maxSize = Math.pow(2, t);
    }
    get minSize() {
      return this._minSize;
    }
    get maxSize() {
      return this._maxSize;
    }
    readSize(e) {
      return e ? this._maxBits : this._minBits;
    }
    writeSize(e) {
      let t;
      switch (e) {
        case e >>> 0:
          t = this._minSize <= e;
          break;
        case e | 0:
          t = -this._minSize / 2 > e;
          break;
        default:
          throw new RangeError(
            `Float/Double is not supported for DInt: got ${e}`
          );
      }
      return {
        bit: t,
        size: t ? this._maxBits : this._minBits
      };
    }
  };
  static Number = new (class {
    TYPES = {
      NaN: 0,
      Infinity: 1,
      UInt: 2,
      Int: 3,
      Double: 4
    };
    encode(e, t) {
      const { TYPES: s } = this;
      if ("number" != typeof t)
        throw new TypeError(`Attempted to encode ${typeof t} as a number`);
      if (Number.isNaN(t)) return e.writeUInt(s.NaN, 3);
      if (!Number.isFinite(t)) {
        e.writeUInt(s.Infinity, 3);
        return e.writeBoolean(t === Number.POSITIVE_INFINITY);
      }
      switch (t) {
        case t >>> 0: {
          const n = Ie.GetIntSize(t);
          e.writeUInt(s.UInt, 3);
          e.writeUInt(n - 1, 3);
          e.writeUInt(t, 4 * n);
          break;
        }
        case t | 0: {
          const n = Ie.GetIntSize(t);
          e.writeUInt(s.Int, 3);
          e.writeUInt(n - 1, 3);
          e.writeInt(t, 4 * n);
          break;
        }
        default:
          e.writeUInt(s.Double, 3);
          e.writeDouble(t);
      }
    }
    decode(e) {
      switch (e.readUInt(3)) {
        case 0:
          return NaN;
        case 1:
          return e.readBoolean()
            ? Number.POSITIVE_INFINITY
            : Number.NEGATIVE_INFINITY;
        case 2: {
          const t = e.readUInt(3) + 1;
          return e.readUInt(4 * t);
        }
        case 3: {
          const t = e.readUInt(3) + 1;
          return e.readInt(4 * t);
        }
        case 4:
          return e.readDouble();
      }
    }
  })();
  static Table = class {
    constructor(e, t = "strict") {
      this._kv = new Map();
      this._vk = new Map();
      for (const [t, s] of e.entries())
        (this._kv.set(s, t + 1), this._vk.set(t + 1, s));
      this._mode = t;
      this._size = Math.floor(Math.log2(this._kv.size)) + 1;
      this.has = this._kv.has.bind(this._kv);
    }
    get mode() {
      return this._mode;
    }
    get size() {
      return this._size;
    }
    get struct() {
      const z = {};
      for (const [e, t] of this._kv.entries()) {
        z[e] = "0x" + t.toString(16).padStart(2, "0");
      }
      return z;
    }
    getkv(e) {
      return this._kv.get(e);
    }
    getvk(e) {
      return this._vk.get(e);
    }
  };
  static Array = class {
    constructor(e = "default", { list: t, min: s, max: n } = {}) {
      this._mode = e;
      switch (e) {
        case "strict":
          this._table = new Ie.Table(t);
          break;
        case "flexible":
          throw new Error("Flexible mode is not implemented yet");
        case "default":
      }
      s = s ?? 7;
      n = n ?? 15;
      const Re = {};
      Re.min = s;
      Re.max = n;
      this._prop = new Ie.DInt(Re);
    }
    get mode() {
      return this._mode;
    }
    encode(e, t) {
      e.writeDInt(t.length, this._prop);
      switch (this._mode) {
        case "strict":
          for (const s of t) e.writeTable(s, this._table);
          break;
        case "flexible":
          throw new Error("Flexible mode is not implemented yet");
        default:
          for (const s of t) e.writeAny(s, this);
      }
    }
    decode(e) {
      const t = e.readDInt(this._prop),
        s = [];
      if ("strict" === this._mode)
        for (let n = 0; n < t; n++) s.push(e.readTable(this._table));
      else for (let n = 0; n < t; n++) s.push(e.readAny(this));
      return s;
    }
  };
  static init() {
    this.SUPPORTED_TYPES_TABLE = new this.Table(
      Array.from(this.SUPPORTED_TYPES.keys())
    );
    this.DEFAULT_ARRAY = new this.Array();
    this.DEFAULT_PROP = new this.DInt({
      min: 8,
      max: 32
    });
  }
  constructor() {
    this.ref = new Map();
    this.refid = 0;
  }
  static Encoder = class t extends this {
    static TYPES = {
      BUFFER: 1,
      DOUBLE: 2,
      QWORD: 3,
      HEX: 4
    };
    constructor(e = null, t = null) {
      super();
      this._buffer = [];
      this._size = 0;
      this._packr = e;
      this._packBuffer = t;
    }
    get buffer() {
      return this._buffer;
    }
    get size() {
      return this._size;
    }
    get byteLength() {
      return Math.ceil(this._size / 8);
    }
    realign() {
      return (this._size += (8 - (this._size % 8)) % 8);
    }
    _insert(e, t, s = null) {
      if (s) {
        this.realign();
      }
      this._size += t;
      return this._buffer.push({
        val: e,
        size: t,
        type: s
      });
    }
    writeTable(e, t) {
      if ("strict" === t.mode) return this._insert(t.getkv(e), t.size);
      const s = t.getkv(e);
      return undefined === s
        ? (this._insert(null, t.size), this.writeAny(e))
        : this._insert(s, t.size);
    }
    writeArray(e, t = Ie.DEFAULT_ARRAY) {
      return "strict" === t.mode
        ? t.encode(this, e)
        : this.ref.has(e)
          ? (this._insert(true, 1),
            this.writeDInt(this.ref.get(e), Ie.DEFAULT_PROP))
          : (this._insert(false, 1),
            this.ref.set(e, this.refid++),
            t.encode(this, e));
    }
    writeStruct(e, t) {
      return t.encode(this, e);
    }
    writeString(s, n = true) {
      s = Buffer.from(n ? `${s}\0` : s);
      return this._insert(s, 8 * s.byteLength, t.TYPES.BUFFER);
    }
    writeBuffer(e) {
      return this._insert(e, 8 * e.byteLength, t.TYPES.BUFFER);
    }
    writeBoolean(e) {
      return this._insert(!!e, 1);
    }
    writeInt(e, t) {
      return this._insert(e, t);
    }
    writeUInt(e, t) {
      return this._insert(e, t);
    }
    writeUInt64(e) {
      return this._insert(e, 64, t.TYPES.QWORD);
    }
    writeDInt(e, t) {
      const s = t.writeSize(e);
      this._insert(s.bit, 1);
      return this._insert(e, s.size);
    }
    writeFloat(e, t, s) {
      this._insert(e < 0, 1);
      return this._insert(Math.round(e * s), t);
    }
    writeUFloat(e, t, s) {
      return this._insert(Math.round(e * s), t);
    }
    writeDouble(e) {
      return this._insert(e, 64, t.TYPES.DOUBLE);
    }
    writeNumber(e) {
      return Ie.Number.encode(this, e);
    }
    writeHex(e, s) {
      return this._insert(e, s * 8, t.TYPES.HEX);
    }
    writeAny(e, t) {
      const s = b(e);
      if (!Ie.SUPPORTED_TYPES.has(s))
        throw new TypeError(
          `Type ${s} is not implemented for NetCodec.TYPES.Any`
        );
      this.writeTable(s, Ie.SUPPORTED_TYPES_TABLE);
      switch (s) {
        case "boolean":
          this.writeBoolean(e);
          break;
        case "null":
        case "undefined":
          break;
        case "number":
          Ie.Number.encode(this, e);
          break;
        case "string":
          this.writeString(e);
          break;
        case "array":
          this.writeArray(e, t);
      }
    }
    writeByType(e, t, ...s) {
      return this[`write${Ie.TYPES_INDEX[e]}`](t, ...s);
    }
    pack(e) {
      this._packr.useBuffer(this._packBuffer);
      const s = this._packr.pack(e);
      return this._insert(s, 8 * s.byteLength, t.TYPES.BUFFER);
    }
    finalize(s = null) {
      const i = s ?? Buffer.allocUnsafe(this.byteLength),
        o = new n(i);
      for (const { val: e, size: s, type: n } of this._buffer)
        switch (n) {
          case t.TYPES.BUFFER:
            o.offset += (8 - (o.offset % 8)) % 8;
            i.set(e, o.offset / 8);
            o.seek(8 * e.byteLength, 2);
            break;
          case t.TYPES.DOUBLE:
            o.offset += (8 - (o.offset % 8)) % 8;
            i.writeDoubleBE(e, o.offset / 8);
            o.seek(64, 2);
            break;
          case t.TYPES.QWORD:
            o.offset += (8 - (o.offset % 8)) % 8;
            i.writeBigUInt64BE(e, o.offset / 8);
            o.seek(64, 2);
            break;
          case t.TYPES.HEX:
            o.offset += (8 - (o.offset % 8)) % 8;
            i.write(e, o.offset / 8, "hex");
            o.seek(s, 2);
            break;
          default:
            o.write(e, s);
        }
      return i;
    }
  };
  static Decoder = class e extends this {
    static _MAX_BITS = Math.log2(Number.MAX_SAFE_INTEGER);
    static _MAX_BITS_SIGNED = 32;
    constructor(e, t = null) {
      super();
      this._bits = new n(e);
      this._unpack = t;
    }
    get length() {
      return this._bits.length;
    }
    get offset() {
      return this._bits.offset;
    }
    set offset(e) {
      this._bits.offset = e;
    }
    get buffer() {
      return this._bits.buffer;
    }
    get byteOffset() {
      return Math.ceil(this.offset / 8);
    }
    realign() {
      this.offset = 8 * this.byteOffset;
    }
    _read_signed(t) {
      const s = e._MAX_BITS_SIGNED - t;
      return (this._read(t) << s) >> s;
    }
    _read(e) {
      return this._bits.read(e);
    }
    readTable(e) {
      const t = e.size;
      return 0 !== this.peek(t)
        ? e.getvk(this._read(t))
        : (this.seek(t, 2), this.readAny());
    }
    readArray(e = Ie.DEFAULT_ARRAY) {
      if ("strict" === e.mode) return e.decode(this);
      if (this._read(1)) return this.ref.get(this.readDInt(Ie.DEFAULT_PROP));
      const t = [];
      this.ref.set(this.refid++, t);
      t.push.apply(t, e.decode(this));
      return t;
    }
    readStruct(e) {
      return e.decode(this);
    }
    readString(e) {
      const t = this.byteOffset;
      let s;
      "number" == typeof e
        ? ((s = t + e), this.seek(8 * s))
        : ((s = this.buffer.indexOf(0, t)), this.seek(8 * (s + 1)));
      return this.buffer.toString("utf8", t, s);
    }
    readBuffer(e) {
      const t = this.byteOffset,
        s = t + e;
      this.seek(8 * s);
      return this.buffer.subarray(t, s);
    }
    readBoolean() {
      return !!this._read(1);
    }
    readInt(t) {
      if (t > e._MAX_BITS_SIGNED)
        throw new RangeError(
          `${t} of bits is not supported for signed values, max is ${e._MAX_BITS_SIGNED}`
        );
      return this._read_signed(t);
    }
    readUInt(t) {
      if (t > e._MAX_BITS)
        throw new RangeError(
          `${t} of bits is not supported, max is ${e._MAX_BITS}`
        );
      return this._read(t);
    }
    readUInt64() {
      const e = this.byteOffset;
      this.seek(8 * e + 64);
      return this.buffer.readBigUInt64BE(e);
    }
    readDInt(e, t = false) {
      const s = e.readSize(this._read(1));
      return t ? this._read_signed(s) : this._read(s);
    }
    readFloat(e, t) {
      return this.peek(1)
        ? this._read_signed(e + 1) / t
        : (this.seek(1, 2), this._read(e) / t);
    }
    readUFloat(e, t) {
      return this._read(e) / t;
    }
    readDouble() {
      const e = this.byteOffset;
      this.seek(8 * e + 64);
      return this.buffer.readDoubleBE(e);
    }
    readNumber() {
      return Ie.Number.decode(this);
    }
    readHex(e) {
      const t = this.byteOffset,
        s = t + e;
      this.seek(8 * s);
      return this.buffer.toString("hex", t, s);
    }
    readAny(e) {
      switch (this.readTable(Ie.SUPPORTED_TYPES_TABLE)) {
        case "boolean":
          return this.readBoolean();
        case "null":
          return null;
        case "undefined":
          return;
        case "number":
          return Ie.Number.decode(this);
        case "string":
          return this.readString();
        case "array":
          return this.readArray(e);
      }
    }
    readByType(e, ...t) {
      return this[`read${Ie.TYPES_INDEX[e]}`](...t);
    }
    peek(e, t) {
      return this._bits.peek(e, t);
    }
    peekTable(e, t = this.offset) {
      return e.getvk(this.peek(e.size, t));
    }
    peekDInt(e, t = this.offset) {
      return this.peek(e.readSize(this.peek(1, t)), t + 1);
    }
    seek(e, t) {
      this._bits.seek(e, t);
    }
    unpack() {
      this.realign();
      return this._unpack(this.byteOffset);
    }
  };
}
class Fe {
  static _MAX_BUFFER = 65536;
  static BUFFER = Buffer.alloc(this._MAX_BUFFER);
  static _LIST = {};
  static get LIST() {
    return this._LIST;
  }
  static AddExtension(t, s = {}) {
    this._LIST[t.name] = t;
    if ("ownBuffer" in s) {
      t.BUFFER = Buffer.alloc(this._MAX_BUFFER);
    }
  }
  static AddTable(e, t, s) {
    this["$$" + e] = new Ie.Table(t, s);
  }
  static AddProperty(e, t) {
    this["$" + e] = new Ie.DInt(t);
  }
  static LoadExtensions(e) {
    let q = 10;
    function j(e) {
      return e.encode.call(e, new Ie.Encoder(this, e.constructor.BUFFER));
    }
    function K(e, t, s, n) {
      return e.decode(new Ie.Decoder(t, (e) => s(n + e)));
    }
    for (const t of Object.values(this._LIST)) {
      t.ext_code = q++;
      e.addExtension({
        Class: t,
        type: t.ext_code,
        pack: j,
        unpack: K.bind(null, t)
      });
    }
  }
}
class Te extends Fe {
  static AddStructure(e) {
    this._cstFields = new Map();
    this._fixFields = new Map();
    this._optFields = new Map();
    for (const [t, { mode: s, type: n, size: i, value: o }] of Object.entries(
      e
    )) {
      switch (s) {
        case "static":
          this._cstFields.set(t, o);
          break;
        case "fixed":
          this._fixFields.set(t, {
            type: n,
            size: i
          });
          break;
        case "optional":
          this._optFields.set(t, {
            type: n,
            size: i
          });
      }
    }
    super.AddTable("prop", Array.from(this._optFields.keys()));
  }
  static encode(e, t) {
    for (const [s, { type: n, size: i }] of this._fixFields.entries())
      e.writeByType(n, t[s], i);
    for (const [s, { type: n, size: i }] of this._optFields.entries())
      if (undefined !== t[s] && !(n === Ie.TYPES.DInt && null === t[s])) {
        e.writeTable(s, this.$$prop);
        e.writeByType(n, t[s], i);
      }
    e.writeUInt(null, this.$$prop.size);
  }
  static decode(e) {
    const t = {},
      s = this.$$prop.size;
    for (const [s, { type: n, size: i }] of this._fixFields.entries())
      t[s] = e.readByType(n, i);
    for (let n = e.peek(s); 0 !== n; n = e.peek(s)) {
      const s = e.readTable(this.$$prop),
        { type: n, size: i } = this._optFields.get(s),
        o = e.readByType(n, i);
      t[s] = o;
    }
    for (const [e, s] of this._cstFields.entries()) t[e] = s;
    return t;
  }
}
class Ee extends Fe {
  static init() {
    super.AddExtension(this);
    super.AddProperty("prov", {
      min: 18,
      max: 26
    });
  }
  static decode(e) {
    return new this(e.readUInt(13), e.readDInt(this.$prov), e.unpack());
  }
  constructor(e, t, s) {
    super();
    this.gameid = e;
    this.provisioned = t;
    this.frames = s.map((e) => new Oe(e));
  }
  encode(e) {
    const t = this.constructor,
      s = this.provisioned;
    e.writeUInt(this.gameid, 13);
    e.writeDInt(s, t.$prov);
    e.pack(this.frames);
    return e.finalize();
  }
}
class Me extends Fe {
  static init() {
    super.AddExtension(this);
    super.AddProperty("long", {
      min: 16,
      max: 32
    });
  }
  static decode(e) {
    const t = [],
      s = e.readUInt(13);
    for (let n = 0; n < s; n++) {
      const s = {
        board: {}
      };
      s.gameid = e.readUInt(13);
      s.board.f = e.readUInt(10);
      s.board.g = e.readDInt(this.$long);
      s.board.w = e.readUInt(We.MAX_WIDTH);
      s.board.h = e.readUInt(We.MAX_HEIGHT);
      s.board.b = e.readStruct(We);
      t[n] = s;
    }
    return new this(t);
  }
  constructor(e) {
    super();
    this.boards = e;
  }
  encode(e) {
    const t = this.constructor;
    e.writeUInt(this.boards.length, 13);
    for (const {
      gameid: s,
      board: { b: n, f: i, g: o, w: a, h: r }
    } of this.boards)
      (e.writeUInt(s, 13),
        e.writeUInt(i, 10),
        e.writeDInt(o, t.$long),
        e.writeUInt(a, We.MAX_WIDTH),
        e.writeUInt(r, We.MAX_HEIGHT),
        e.writeStruct(n, We));
    return e.finalize();
  }
}
class De extends Fe {
  static init() {
    super.AddExtension(this);
    super.AddTable("extraStat", [
      "none",
      "revives",
      "escapeartist",
      "blockrationing_app",
      "blockrationing_final",
      "talentless"
    ]);
  }
  static decode(e) {
    const t = [],
      s = e.readUInt(13);
    for (let n = 0; n < s; n++) {
      const s = {
        stats: {},
        allies: []
      };
      t[n] = s;
      s.gameid = e.readUInt(13);
      s.stats.rank = e.readUInt(6);
      s.stats.altitude = e.readFloat(18, 10);
      s.stats.btb = e.readUInt(13);
      s.specCount = e.readUInt(10);
      s.speedrun = e.readBoolean();
      s.nearWR = e.readBoolean();
      const i = e.readUInt(3);
      for (let t = 0; t < i; t++) s.allies.push(e.readUInt(13));
      s.stats.revives = 0;
      s.stats.escapeartist = 0;
      s.stats.blockrationing_app = 0;
      s.stats.blockrationing_final = 0;
      switch (e.readTable(this.$$extraStat)) {
        case "none":
          break;
        case "revives":
          s.stats.revives = e.readUInt(8);
          break;
        case "escapeartist":
          s.stats.escapeartist = e.readUInt(9);
          break;
        case "blockrationing_app":
          s.stats.blockrationing_app = e.readFloat(10, 100);
          break;
        case "blockrationing_final":
          s.stats.blockrationing_final = e.readUInt(11);
          break;
        case "talentless":
          s.talentless = true;
      }
    }
    return new this(t);
  }
  constructor(e) {
    super();
    this.sb = e;
  }
  encode(e) {
    const t = this.constructor;
    e.writeUInt(this.sb.length, 13);
    for (const {
      gameid: s,
      stats: n,
      allies: i,
      specCount: o,
      speedrun: a,
      nearWR: r,
      talentless: l
    } of this.sb) {
      e.writeUInt(s, 13);
      e.writeUInt(Math.floor(n.rank), 6);
      e.writeFloat(n.altitude.toFixed(2), 18, 10);
      e.writeUInt(n.btb, 13);
      e.writeUInt(o, 10);
      e.writeBoolean(a);
      e.writeBoolean(r);
      if (i) {
        e.writeUInt(i.length, 3);
        for (const t of i) e.writeUInt(t, 13);
      } else e.writeUInt(0, 3);
      let c = "none";
      if (n.revives) {
        c = "revives";
      }
      if (n.escapeartist) {
        c = "escapeartist";
      }
      if (n.blockrationing_app) {
        c = "blockrationing_app";
      }
      if (n.blockrationing_final) {
        c = "blockrationing_final";
      }
      if (l) {
        c = "talentless";
      }
      e.writeTable(c, t.$$extraStat);
      switch (c) {
        case "none":
        case "talentless":
          break;
        case "revives":
          e.writeUInt(n.revives, 8);
          break;
        case "escapeartist":
          e.writeUInt(n.escapeartist, 9);
          break;
        case "blockrationing_app":
          e.writeFloat(n.blockrationing_app.toFixed(3), 10, 100);
          break;
        case "blockrationing_final":
          e.writeUInt(n.blockrationing_final, 11);
      }
    }
    return e.finalize();
  }
}
class Oe extends Fe {
  static init() {
    super.AddExtension(this, {
      ownBuffer: true
    });
    super.AddProperty("frame", {
      min: 18,
      max: 26
    });
    super.AddTable("type", [
      "keydown",
      "keyup",
      "start",
      "full",
      "end",
      "ige",
      "strategy",
      "manual_target"
    ]);
    super.AddTable("key", [
      "moveLeft",
      "moveRight",
      "rotate180",
      "rotateCCW",
      "rotateCW",
      "softDrop",
      "hardDrop",
      "undo",
      "redo",
      "hold",
      "retry",
      "exit"
    ]);
  }
  static decode(e) {
    const t = {};
    t.type = e.readTable(this.$$type);
    t.frame = e.readDInt(this.$frame);
    switch (t.type) {
      case "keydown":
      case "keyup": {
        const s = e.readTable(this.$$key),
          n = e.readBoolean(),
          i = {
            key: s,
            subframe: e.readFloat(4, 10)
          };
        if (n) {
          i.hoisted = true;
        }
        t.data = i;
        break;
      }
      case "start":
        t.data = {};
        break;
      case "full":
        t.data = e.readStruct(Re);
        break;
      case "end":
        t.data = e.readStruct(et);
        break;
      case "ige":
        t.data = e.readStruct(Ue);
        break;
      case "strategy":
        t.data = e.readUInt(3);
        break;
      case "manual_target":
        t.data = e.readUInt(13);
        break;
      default:
        t.data = e.unpack();
    }
    return new this(t);
  }
  constructor(e) {
    super();
    this.type = e.type;
    this.frame = e.frame;
    this.data = e.data;
  }
  encode(e) {
    const t = this.constructor;
    e.writeTable(this.type, t.$$type);
    e.writeDInt(this.frame, t.$frame);
    switch (this.type) {
      case "keydown":
      case "keyup": {
        const s = this.data.hoisted,
          n = this.data.subframe;
        e.writeTable(this.data.key, t.$$key);
        e.writeBoolean(s);
        e.writeFloat(n, 4, 10);
        return e.finalize();
      }
      case "start":
        return e.finalize();
      case "full": {
        e.writeStruct(this.data, Re);
        return e.finalize();
      }
      case "end": {
        e.writeStruct(this.data, et);
        return e.finalize();
      }
      case "ige": {
        e.writeStruct(this.data, Ue);
        return e.finalize();
      }
      case "strategy": {
        e.writeUInt(this.data, 3);
        return e.finalize();
      }
      case "manual_target": {
        e.writeUInt(this.data, 13);
        return e.finalize();
      }
      default: {
        console.warn(
          `Fallback to packer ${this.type} -> ${JSON.stringify(this.data)}`
        );
        e.pack(this.data);
        return e.finalize();
      }
    }
  }
}
class He extends Fe {
  static init() {
    super.AddExtension(this);
  }
  static decode(e) {
    const t = [],
      s = e.readUInt(13);
    for (let n = 0; n < s; n++) {
      const s = {};
      s.userid = e.readHex(12);
      s.gameid = e.readUInt(13);
      s.alive = e.readBoolean();
      s.naturalorder = e.readUInt(13);
      s.options = e.readStruct(Ze);
      t.push(s);
    }
    return t;
  }
  constructor(e) {
    super();
    this.players = e;
  }
  encode(e) {
    e.writeUInt(this.players.length, 13);
    for (const {
      gameid: t,
      userid: s,
      alive: n,
      naturalorder: i,
      options: o
    } of this.players)
      (e.writeHex(s, 12),
        e.writeUInt(t, 13),
        e.writeBoolean(n),
        e.writeUInt(i, 13),
        e.writeStruct(o, Ze));
    return e.finalize();
  }
}
class Re extends Fe {
  static init() {
    super.AddTable("piece", [null, ...Object.keys(w.tetrominoes)], "flexible");
    super.AddTable("ixs", ["off", "hold", "tap"]);
  }
  static encode(e, t) {
    const s = t.game.board,
      n = t.game.bag,
      i = t.game.hold,
      o = t.game.g,
      a = t.game.controlling,
      r = t.game.falling,
      l = t.game.handling;
    e.writeUInt(n.length, 12);
    for (const t of n) e.writeTable(t, this.$$piece);
    e.writeStruct(s, We);
    e.writeBoolean(i.locked);
    e.writeTable(i.piece, this.$$piece);
    e.writeDouble(o);
    e.writeBoolean(a.inputSoftdrop);
    e.writeBoolean(-1 === a.lastshift);
    e.writeBoolean(a.lShift.held);
    e.writeBoolean(a.rShift.held);
    e.writeUInt(t.diyusi, 4);
    e.writeDouble(a.lShift.arr);
    e.writeDouble(a.rShift.arr);
    e.writeDouble(a.lShift.das);
    e.writeDouble(a.rShift.das);
    e.writeStruct(r, Ne);
    e.writeFloat(l.arr, 6, 10);
    e.writeUInt(l.sdf, 6);
    e.writeBoolean(l.safelock);
    e.writeBoolean(l.cancel);
    e.writeBoolean(l.may20g);
    e.writeBoolean(t.game.playing);
    e.writeFloat(l.das, 8, 10);
    e.writeFloat(l.dcd, 8, 10);
    e.writeTable(l.irs, this.$$ixs);
    e.writeTable(l.ihs, this.$$ixs);
    e.writeStruct(t.stats, $e);
  }
  static decode(e) {
    const t = {},
      s = {
        bag: [],
        controlling: {
          lShift: {
            dir: -1
          },
          rShift: {
            dir: 1
          }
        },
        handling: {}
      },
      n = s.controlling,
      i = s.handling,
      o = e.readUInt(12);
    for (let t = 0; t < o; t++) s.bag.push(e.readTable(this.$$piece));
    s.board = e.readStruct(We);
    s.hold = {
      locked: e.readBoolean(),
      piece: e.readTable(this.$$piece)
    };
    s.g = e.readDouble();
    n.inputSoftdrop = e.readBoolean();
    n.lastshift = e.readBoolean() ? -1 : 1;
    n.lShift.held = e.readBoolean();
    n.rShift.held = e.readBoolean();
    t.diyusi = e.readUInt(4);
    n.lShift.arr = e.readDouble();
    n.rShift.arr = e.readDouble();
    n.lShift.das = e.readDouble();
    n.rShift.das = e.readDouble();
    s.falling = e.readStruct(Ne);
    i.arr = e.readFloat(6, 10);
    i.sdf = e.readUInt(6);
    i.safelock = e.readBoolean();
    i.cancel = e.readBoolean();
    i.may20g = e.readBoolean();
    s.playing = e.readBoolean();
    i.das = e.readFloat(8, 10);
    i.dcd = e.readFloat(8, 10);
    i.irs = e.readTable(this.$$ixs);
    i.ihs = e.readTable(this.$$ixs);
    t.stats = e.readStruct($e);
    t.game = s;
    return t;
  }
}
class We extends Fe {
  static MAX_WIDTH = Math.log2(512);
  static MAX_HEIGHT = Math.log2(512);
  static init() {
    super.AddTable("blk", [false, null, ...w.minocolors]);
  }
  static encode(e, t) {
    const s = t[0]?.length ?? 0,
      n = t.length;
    if (!s) return e.writeUInt(0, this.MAX_WIDTH);
    e.writeUInt(s, this.MAX_WIDTH);
    e.writeUInt(n, this.MAX_HEIGHT);
    for (const s of t)
      if (s.some((e) => null !== e))
        for (const t of s) e.writeTable(t, this.$$blk);
      else e.writeTable(false, this.$$blk);
  }
  static decode(e) {
    const t = [],
      s = e.readUInt(this.MAX_WIDTH);
    if (!s) return t;
    const n = e.readUInt(this.MAX_HEIGHT);
    for (let i = 0; i < n; i++)
      if (false !== e.peekTable(this.$$blk)) {
        t[i] = [];
        for (let n = 0; n < s; n++) t[i][n] = e.readTable(this.$$blk);
      } else (e.seek(4, 2), (t[i] = new Array(s).fill(null)));
    return t;
  }
}
class Ne extends Fe {
  static init() {
    super.AddTable("piece", [null, ...Object.keys(w.tetrominoes)], "flexible");
  }
  static encode(e, t) {
    e.writeTable(t.type, this.$$piece);
    e.writeInt(t.x, We.MAX_WIDTH);
    e.writeUInt(t.r, 2);
    e.writeUInt(t.hy, We.MAX_HEIGHT);
    e.writeUInt(t.irs, 2);
    e.writeUInt(t.kick, 5);
    e.writeUInt(t.keys, 16);
    e.writeUInt(t.flags, R.FLAGS_COUNT);
    e.writeUInt(t.safelock, 3);
    e.writeUInt(t.lockresets, 5);
    e.writeUInt(t.rotresets, 6);
    e.writeBoolean(t.skip.length);
    if (t.skip.length) {
      for (const s of t.skip) e.writeUInt(s + 1, 7);
      e.writeUInt(0, 7);
    }
    e.writeDouble(t.y);
    e.writeDouble(t.locking);
  }
  static decode(e) {
    const t = {
      skip: []
    };
    t.type = e.readTable(this.$$piece);
    t.x = e.readInt(We.MAX_WIDTH);
    t.r = e.readUInt(2);
    t.hy = e.readUInt(We.MAX_HEIGHT);
    t.irs = e.readUInt(2);
    t.kick = e.readUInt(5);
    t.keys = e.readUInt(16);
    t.flags = e.readUInt(R.FLAGS_COUNT);
    t.safelock = e.readUInt(3);
    t.lockresets = e.readUInt(5);
    t.rotresets = e.readUInt(6);
    if (e.readBoolean()) {
      const s = 7;
      for (let n = e.peek(s); 0 !== n; n = e.peek(s))
        t.skip.push(e.readUInt(s) - 1);
      e.seek(s, 2);
    }
    t.y = e.readDouble();
    t.locking = e.readDouble();
    return t;
  }
}
class $e extends Fe {
  static init() {
    super.AddTable("piece", [...Object.keys(w.tetrominoes)], "flexible");
    super.AddProperty("short", {
      min: 8,
      max: 16
    });
    super.AddProperty("long", {
      min: 16,
      max: 32
    });
    this._clears = [
      "singles",
      "doubles",
      "triples",
      "quads",
      "pentas",
      "realtspins",
      "minitspins",
      "minitspinsingles",
      "tspinsingles",
      "minitspindoubles",
      "tspindoubles",
      "minitspintriples",
      "tspintriples",
      "minitspinquads",
      "tspinquads",
      "tspinpentas",
      "allclear"
    ];
  }
  static encode(e, t) {
    const s = t.garbage,
      n = t.clears,
      i = t.finesse;
    e.writeDInt(t.lines, this.$short);
    e.writeDInt(t.level_lines, this.$short);
    e.writeDInt(t.level_lines_needed, this.$short);
    e.writeDInt(t.inputs, this.$long);
    e.writeDInt(t.holds, this.$long);
    e.writeDInt(t.score, this.$long);
    e.writeUInt(t.level, 8);
    e.writeDInt(t.combo, this.$long);
    e.writeDInt(t.topcombo, this.$long);
    e.writeUInt(t.combopower, 3);
    e.writeDInt(t.btb, this.$short);
    e.writeDInt(t.topbtb, this.$short);
    e.writeUInt(t.btbpower, 8);
    e.writeDInt(t.tspins, this.$long);
    e.writeDInt(t.piecesplaced, this.$long);
    for (const t of this._clears) e.writeDInt(n[t], this.$short);
    e.writeDInt(s.sent, this.$long);
    e.writeDInt(s.sent_nomult, this.$long);
    e.writeDInt(s.maxspike, this.$long);
    e.writeDInt(s.maxspike_nomult, this.$long);
    e.writeDInt(s.received, this.$long);
    e.writeDInt(s.attack, this.$long);
    e.writeDInt(s.cleared, this.$long);
    e.writeDInt(t.kills, this.$short);
    e.writeDInt(i.combo, this.$long);
    e.writeDInt(i.faults, this.$long);
    e.writeDInt(i.perfectpieces, this.$long);
    e.writeStruct(t.zenith, Ge);
  }
  static decode(e) {
    const t = {
      zenlevel: 1,
      zenprogress: 0,
      clears: {},
      garbage: {},
      finesse: {}
    };
    t.lines = e.readDInt(this.$short);
    t.level_lines = e.readDInt(this.$short);
    t.level_lines_needed = e.readDInt(this.$short);
    t.inputs = e.readDInt(this.$long);
    t.holds = e.readDInt(this.$long);
    t.score = e.readDInt(this.$long);
    t.level = e.readUInt(8);
    t.combo = e.readDInt(this.$long);
    t.topcombo = e.readDInt(this.$long);
    t.combopower = e.readUInt(3);
    t.btb = e.readDInt(this.$short);
    t.topbtb = e.readDInt(this.$short);
    t.btbpower = e.readUInt(8);
    t.tspins = e.readDInt(this.$long);
    t.piecesplaced = e.readDInt(this.$long);
    for (const s of this._clears) t.clears[s] = e.readDInt(this.$short);
    t.garbage.sent = e.readDInt(this.$long);
    t.garbage.sent_nomult = e.readDInt(this.$long);
    t.garbage.maxspike = e.readDInt(this.$long);
    t.garbage.maxspike_nomult = e.readDInt(this.$long);
    t.garbage.received = e.readDInt(this.$long);
    t.garbage.attack = e.readDInt(this.$long);
    t.garbage.cleared = e.readDInt(this.$long);
    t.kills = e.readDInt(this.$short);
    t.finesse.combo = e.readDInt(this.$long);
    t.finesse.faults = e.readDInt(this.$long);
    t.finesse.perfectpieces = e.readDInt(this.$long);
    t.zenith = e.readStruct(Ge);
    return t;
  }
}
class Ge extends Fe {
  static init() {
    super.AddProperty("long", {
      min: 16,
      max: 32
    });
  }
  static encode(e, t) {
    e.writeDouble(t.altitude);
    e.writeDouble(t.rank);
    e.writeDouble(t.peakrank);
    e.writeDouble(t.avgrankpts);
    e.writeDouble(t.totalbonus);
    e.writeFloat(t.targetingfactor, 16, 100);
    e.writeFloat(t.targetinggrace, 16, 100);
    e.writeUInt(t.floor, 4);
    e.writeUInt(t.revives, 8);
    e.writeUInt(t.revivesTotal, 8);
    e.writeBoolean(t.speedrun);
    e.writeBoolean(t.speedrun_seen);
    for (let s = 0; s < 9; s++) e.writeDInt(t.splits[s], this.$long);
  }
  static decode(e) {
    const t = {
      splits: []
    };
    t.altitude = e.readDouble();
    t.rank = e.readDouble();
    t.peakrank = e.readDouble();
    t.avgrankpts = e.readDouble();
    t.totalbonus = e.readDouble();
    t.targetingfactor = e.readFloat(16, 100);
    t.targetinggrace = e.readFloat(16, 100);
    t.floor = e.readUInt(4);
    t.revives = e.readUInt(8);
    t.revivesTotal = e.readUInt(8);
    t.revivesMaxOfBoth = Math.max(t.revives, t.revivesTotal - t.revives);
    t.speedrun = e.readBoolean();
    t.speedrun_seen = e.readBoolean();
    for (let s = 0; s < 9; s++) t.splits[s] = e.readDInt(this.$long);
    return t;
  }
}
class Ue extends Fe {
  static init() {
    super.AddProperty("byte", {
      min: 8,
      max: 24
    });
    super.AddTable("type", [
      "interaction",
      "interaction_confirm",
      "target",
      "targeted",
      "allow_targeting",
      "kev",
      "custom"
    ]);
    super.AddTable("int_type", [
      "garbage",
      "zenith.climb_pts",
      "zenith.bonus",
      "zenith.incapacitated",
      "zenith.revive"
    ]);
  }
  static encode(e, t) {
    const s = t.frame,
      n = t.type,
      i = t.data;
    e.writeDInt(t.id, this.$byte);
    e.writeDInt(s, this.$byte);
    e.writeTable(n, this.$$type);
    switch (n) {
      case "interaction":
        return e.writeStruct(i, qe);
      case "interaction_confirm": {
        e.writeTable(i.type, this.$$int_type);
        switch (i.type) {
          case "garbage":
            return e.writeStruct(i, qe);
          case "zenith.climb_pts":
          case "zenith.bonus": {
            e.writeUInt(i.gameid, 13);
            e.writeDInt(i.frame, this.$byte);
            return e.writeDouble(i.amt);
          }
          case "zenith.incapacitated":
          case "zenith.revive": {
            e.writeUInt(i.gameid, 13);
            return e.writeDInt(i.frame, this.$byte);
          }
          default:
            throw new Error(`Unknown interaction type received: ${i.type}`);
        }
      }
      case "target":
        e.writeUInt(i.targets.length, 13);
        for (const t of i.targets) e.writeUInt(t, 13);
        break;
      case "targeted":
        e.writeBoolean(i.value);
        e.writeUInt(i.gameid, 13);
        e.writeDInt(i.frame, this.$byte);
        break;
      case "allow_targeting":
        e.writeBoolean(i.value);
        break;
      case "kev":
        e.writeUInt(i.victim.gameid, 13);
        e.writeUInt(i.killer.gameid, 13);
        e.writeDInt(i.frame, this.$byte);
        e.writeUInt(i.fire, 10);
        e.writeBoolean(i.wasSnowball);
        break;
      case "custom":
        return e.writeStruct(i, Ke);
    }
  }
  static decode(e) {
    const t = {};
    t.id = e.readDInt(this.$byte);
    t.frame = e.readDInt(this.$byte);
    t.type = e.readTable(this.$$type);
    e: switch (t.type) {
      case "interaction":
        t.data = e.readStruct(qe);
        break;
      case "interaction_confirm": {
        const s = e.readTable(this.$$int_type);
        switch (s) {
          case "garbage":
            t.data = e.readStruct(qe);
            break e;
          case "zenith.climb_pts":
          case "zenith.bonus":
            t.data = {
              type: s,
              gameid: e.readUInt(13),
              frame: e.readDInt(this.$byte),
              amt: e.readDouble()
            };
            break e;
          case "zenith.incapacitated":
          case "zenith.revive":
            t.data = {
              type: s,
              gameid: e.readUInt(13),
              frame: e.readDInt(this.$byte)
            };
            break e;
        }
        break;
      }
      case "target": {
        const s = [],
          n = e.readUInt(13);
        for (let t = 0; t < n; t++) s.push(e.readUInt(13));
        t.data = {
          targets: s
        };
        break;
      }
      case "targeted":
        t.data = {
          value: e.readBoolean(),
          gameid: e.readUInt(13),
          frame: e.readDInt(this.$byte)
        };
        break;
      case "allow_targeting":
        t.data = {
          value: e.readBoolean()
        };
        break;
      case "kev":
        t.data = {
          victim: {
            gameid: e.readUInt(13)
          },
          killer: {
            gameid: e.readUInt(13)
          },
          frame: e.readDInt(this.$byte),
          fire: e.readUInt(10),
          wasSnowball: e.readBoolean()
        };
        break;
      case "custom":
        t.data = e.readStruct(Ke);
    }
    return t;
  }
}
class qe extends Te {
  static init() {
    super.AddProperty("byte", {
      min: 8,
      max: 24
    });
    super.AddTable("type", ["garbage", "corruption"]);
    super.AddTable("actorType", ["none", "clears", "time", "line"]);
    super.AddTable("blk", [null, ...w.minocolors]);
    super.AddTable("position", [
      "aboveStack",
      "aboveUnclearable",
      "abovePerma",
      "bottom"
    ]);
    super.AddStructure({
      type: {
        mode: "fixed",
        type: Ie.TYPES.Table,
        size: this.$$type
      },
      amt: {
        mode: "fixed",
        type: Ie.TYPES.DInt,
        size: this.$byte
      },
      username: {
        mode: "optional",
        type: Ie.TYPES.String,
        size: true
      },
      gameid: {
        mode: "optional",
        type: Ie.TYPES.UInt,
        size: 13
      },
      position: {
        mode: "optional",
        type: Ie.TYPES.Table,
        size: this.$$position
      },
      frame: {
        mode: "optional",
        type: Ie.TYPES.DInt,
        size: this.$byte
      },
      cid: {
        mode: "optional",
        type: Ie.TYPES.DInt,
        size: this.$byte
      },
      iid: {
        mode: "optional",
        type: Ie.TYPES.DInt,
        size: this.$byte
      },
      ackiid: {
        mode: "optional",
        type: Ie.TYPES.DInt,
        size: this.$byte
      },
      x: {
        mode: "optional",
        type: Ie.TYPES.Int,
        size: We.MAX_WIDTH
      },
      y: {
        mode: "optional",
        type: Ie.TYPES.UInt,
        size: We.MAX_HEIGHT
      },
      pos: {
        mode: "optional",
        type: Ie.TYPES.Table,
        size: this.$$blk
      },
      neg: {
        mode: "optional",
        type: Ie.TYPES.Table,
        size: this.$$blk
      },
      color: {
        mode: "optional",
        type: Ie.TYPES.UInt,
        size: 24
      },
      column: {
        mode: "optional",
        type: Ie.TYPES.UInt,
        size: We.MAX_WIDTH
      },
      delay: {
        mode: "optional",
        type: Ie.TYPES.UInt,
        size: 16
      },
      queued: {
        mode: "optional",
        type: Ie.TYPES.Boolean
      },
      hardened: {
        mode: "optional",
        type: Ie.TYPES.Boolean
      },
      size: {
        mode: "optional",
        type: Ie.TYPES.UInt,
        size: We.MAX_WIDTH
      },
      zthalt: {
        mode: "optional",
        type: Ie.TYPES.Double
      },
      boardsize: {
        mode: "optional",
        type: Ie.TYPES.DInt,
        size: this.$byte
      },
      actor_neg: {
        mode: "optional",
        type: Ie.TYPES.String
      },
      actor_pos: {
        mode: "optional",
        type: Ie.TYPES.String
      },
      anchor: {
        mode: "optional",
        type: Ie.TYPES.String
      },
      actor_neg_data_type: {
        mode: "optional",
        type: Ie.TYPES.Table,
        size: this.$$actorType
      },
      actor_neg_data_amt: {
        mode: "optional",
        type: Ie.TYPES.Any
      },
      actor_pos_data_type: {
        mode: "optional",
        type: Ie.TYPES.Table,
        size: this.$$actorType
      },
      actor_pos_data_amt: {
        mode: "optional",
        type: Ie.TYPES.Any
      }
    });
  }
}
class Ve extends Te {
  static init() {
    super.AddTable("action", ["add", "remove"]);
    super.AddTable("position", [
      "aboveStack",
      "aboveUnclearable",
      "abovePerma",
      "bottom"
    ]);
    super.AddTable("actorType", ["none", "clears", "time", "line"]);
    super.AddTable("blk", [null, ...w.minocolors]);
    super.AddProperty("byte", {
      min: 8,
      max: 32
    });
    super.AddStructure({
      action: {
        mode: "fixed",
        type: Ie.TYPES.Table,
        size: this.$$action
      },
      amt: {
        mode: "fixed",
        type: Ie.TYPES.DInt,
        size: this.$byte
      },
      size: {
        mode: "fixed",
        type: Ie.TYPES.UInt,
        size: We.MAX_WIDTH
      },
      pos: {
        mode: "optional",
        type: Ie.TYPES.Table,
        size: this.$$blk
      },
      neg: {
        mode: "optional",
        type: Ie.TYPES.Table,
        size: this.$$blk
      },
      position: {
        mode: "optional",
        type: Ie.TYPES.Table,
        size: this.$$position
      },
      column: {
        mode: "optional",
        type: Ie.TYPES.UInt,
        size: We.MAX_WIDTH
      },
      slow: {
        mode: "optional",
        type: Ie.TYPES.UInt,
        size: 16
      },
      effect: {
        mode: "optional",
        type: Ie.TYPES.String
      },
      actor_neg: {
        mode: "optional",
        type: Ie.TYPES.String
      },
      actor_pos: {
        mode: "optional",
        type: Ie.TYPES.String
      },
      anchor: {
        mode: "optional",
        type: Ie.TYPES.String
      },
      actor_neg_data_type: {
        mode: "optional",
        type: Ie.TYPES.Table,
        size: this.$$actorType
      },
      actor_neg_data_amt: {
        mode: "optional",
        type: Ie.TYPES.Any
      },
      actor_pos_data_type: {
        mode: "optional",
        type: Ie.TYPES.Table,
        size: this.$$actorType
      },
      actor_pos_data_amt: {
        mode: "optional",
        type: Ie.TYPES.Any
      }
    });
  }
}
class Ke extends Fe {
  static init() {
    super.AddTable("type", [
      "garbage",
      "map",
      "queue",
      "piece",
      "lines",
      "boardsize",
      "boardresize",
      "holderstate",
      "setoptions",
      "constants",
      "tetrominoes"
    ]);
  }
  static encode(e, { type: t, data: s }) {
    e.writeTable(t, this.$$type);
    switch (t) {
      case "garbage":
        return e.writeStruct(s, qe);
      case "map": {
        e.writeStruct(s.map, Ye);
        e.writeUInt(s.w, We.MAX_WIDTH);
        return e.writeUInt(s.h, We.MAX_HEIGHT);
      }
      case "queue": {
        e.writeBoolean(s.start);
        return e.writeString(s.queue.toString());
      }
      case "piece":
        return e.writeString(s.piece);
      case "lines":
        return e.writeStruct(s, Ve);
      case "boardsize":
      case "boardresize": {
        e.writeUInt(s.w, We.MAX_WIDTH);
        return e.writeUInt(s.h, We.MAX_HEIGHT);
      }
      case "holderstate":
      case "constants":
        return e.pack(s);
      case "setoptions":
        return e.writeStruct(s.options, Ze);
      case "tetrominoes":
        return e.writeStruct(s, Qe);
    }
  }
  static decode(e) {
    const t = {
      data: {}
    };
    t.type = e.readTable(this.$$type);
    switch (t.type) {
      case "garbage":
        t.data = e.readStruct(qe);
        break;
      case "map":
        t.data.map = e.readStruct(Ye);
        t.data.w = e.readUInt(We.MAX_WIDTH);
        t.data.h = e.readUInt(We.MAX_HEIGHT);
        break;
      case "queue":
        t.data.start = e.readBoolean();
        t.data.queue = e.readString().split(",");
        break;
      case "piece":
        t.data.piece = e.readString();
        break;
      case "lines":
        t.data = e.readStruct(Ve);
        break;
      case "boardsize":
      case "boardresize":
        t.data.w = e.readUInt(We.MAX_WIDTH);
        t.data.h = e.readUInt(We.MAX_HEIGHT);
        break;
      case "holderstate":
      case "constants":
        t.data = e.unpack();
        break;
      case "setoptions":
        t.data.options = e.readStruct(Ze);
        break;
      case "tetrominoes":
        t.data = e.readStruct(Qe);
    }
    return t;
  }
}
class Ye extends Fe {
  static init() {
    super.AddTable(
      "letters",
      ["?", ",", "_", "#", "@", "z", "l", "o", "s", "i", "j", "t", "g", "d"],
      "flexible"
    );
    super.AddProperty("word", {
      min: 16,
      max: 32
    });
  }
  static encode(e, t) {
    const s = t.split("");
    e.writeDInt(s.length, this.$word);
    for (const t of s) e.writeTable(t, this.$$letters);
  }
  static decode(e) {
    let t = "";
    const s = e.readDInt(this.$word);
    for (let n = 0; n < s; n++) {
      t += e.readTable(this.$$letters);
    }
    return t;
  }
}
class Qe extends Fe {
  static init() {
    super.AddProperty("tiny", {
      min: 3,
      max: 7
    });
    super.AddTable(
      "spinbonus",
      [...Object.keys(w.spinbonuses_rules)],
      "flexible"
    );
    super.AddTable("colors", [...w.minocolors]);
    super.AddTable("kicksets", [...Object.keys(w.kicksets)], "flexible");
    super.AddTable("special", ["i", "i2", "i3", "l3", "i5", "oo"]);
  }
  static encode(e, t) {
    const s = t.tetrominoes,
      n = t.minotypes,
      i = t.tetrominoes_color,
      o = Object.keys(s);
    e.writeUInt(o.length, 8);
    for (const t of o) e.writeString(t);
    for (const [t, o] of Object.entries(s)) {
      const { matrix: s, preview: a } = o;
      e.writeDInt(s.w, this.$tiny);
      e.writeDInt(s.h, this.$tiny);
      e.writeUInt(s.dx, 5);
      e.writeUInt(s.dy, 5);
      e.writeDInt(s.data[0].length, this.$tiny);
      const [r, l] = [Ie.cla32(s.w - 1), Ie.cla32(s.h - 1)];
      for (const t of s.data)
        for (const [s, n] of t) (e.writeUInt(s, r), e.writeUInt(n, l));
      e.writeDInt(a.w, this.$tiny);
      e.writeDInt(a.h, this.$tiny);
      for (const [t, s] of a.data) (e.writeUInt(t, r), e.writeUInt(s, l));
      e.writeBoolean(undefined !== o.weight);
      e.writeBoolean(o.spinbonus_override);
      e.writeBoolean(o.kickset_override);
      e.writeBoolean(o.kickset_special);
      e.writeBoolean(n.includes(t));
      e.writeTable(i[t], this.$$colors);
      if (undefined !== o.weight) {
        e.writeDInt(o.weight, this.$tiny);
      }
      if (o.spinbonus_override) {
        e.writeTable(o.spinbonus_override.rule, this.$$spinbonus);
        e.writeBoolean(o.spinbonus_override.mini);
      }
      if (o.kickset_override) {
        e.writeTable(o.kickset_override, this.$$kicksets);
      }
      if (o.kickset_special) {
        e.writeTable(o.kickset_special, this.$$special);
      }
    }
  }
  static decode(e) {
    const t = {},
      s = [],
      n = {},
      i = e.readUInt(8),
      o = [];
    for (let s = 0; s < i; s++) {
      const s = e.readString();
      t[s] = {
        matrix: {},
        preview: {}
      };
      o.push(s);
    }
    for (const i of o) {
      const o = t[i],
        { matrix: a, preview: r } = o;
      a.w = e.readDInt(this.$tiny);
      a.h = e.readDInt(this.$tiny);
      a.dx = e.readUInt(5);
      a.dy = e.readUInt(5);
      const l = e.readDInt(this.$tiny),
        [c, p] = [Ie.cla32(a.w - 1), Ie.cla32(a.h - 1)];
      a.data = [];
      for (let t = 0; t < 4; t++) {
        a.data[t] = [];
        for (let s = 0; s < l; s++) {
          const [n, i] = [e.readUInt(c), e.readUInt(p)];
          a.data[t][s] = [n, i];
        }
      }
      r.w = e.readDInt(this.$tiny);
      r.h = e.readDInt(this.$tiny);
      r.data = [];
      for (let t = 0; t < l; t++) {
        const [s, n] = [e.readUInt(c), e.readUInt(p)];
        r.data[t] = [s, n];
      }
      const h = e.readBoolean(),
        d = e.readBoolean(),
        u = e.readBoolean(),
        _ = e.readBoolean(),
        m = e.readBoolean();
      n[i] = e.readTable(this.$$colors);
      if (h) {
        o.weight = e.readDInt(this.$tiny);
      }
      if (d) {
        o.spinbonus_override = {
          rule: e.readTable(this.$$spinbonus),
          mini: e.readBoolean()
        };
      }
      if (u) {
        o.kickset_override = e.readTable(this.$$kicksets);
      }
      if (_) {
        o.kickset_special = e.readTable(this.$$special);
      }
      if (m) {
        s.push(i);
      }
    }
    return {
      minotypes: s,
      tetrominoes: t,
      tetrominoes_color: n
    };
  }
}
class Ze extends Fe {
  static TypeOrders = [
    "boolean",
    "number",
    "table",
    "object",
    "array",
    "string"
  ];
  static OptsBook = ge.OptionsList;
  static init() {
    super.AddTable("options", Object.keys(this.OptsBook));
    super.AddTable(
      "minoskin",
      ["i", "j", "l", "o", "s", "t", "z", "ghost", "other"],
      "flexible"
    );
    super.AddTable("skins", ["tetrio", "_bombs", "connected_test"], "flexible");
    super.AddTable("ixs", ["off", "hold", "tap"]);
    for (const [e, t] of Object.entries(this.OptsBook))
      if (t.allowed) super.AddTable("_" + e, t.allowed);
      else if (t.possibles) {
        super.AddTable("_" + e, t.possibles, "flexible");
      }
  }
  static *ParseOptions(e) {
    const { TypeOrders: t, OptsBook: s } = this,
      n = Object.keys(e);
    for (const i of t)
      for (const t of n) {
        const n = s[t];
        if (n.type !== i) continue;
        const o = e[t];
        yield [t, o, n];
      }
  }
  static encode(e, t) {
    for (const [s, n, i] of this.ParseOptions(t)) {
      e.writeTable(s, this.$$options);
      switch (i.type) {
        case "object":
          if ("handling" === s)
            (e.writeFloat(n.arr, 6, 10),
              e.writeUInt(n.sdf, 6),
              e.writeBoolean(n.safelock),
              e.writeBoolean(n.cancel),
              e.writeBoolean(n.may20g),
              e.writeFloat(n.das, 8, 10),
              e.writeFloat(n.dcd, 8, 10),
              e.writeTable(n.irs, this.$$ixs),
              e.writeTable(n.ihs, this.$$ixs));
          else if ("minoskin" === s) {
            e.writeUInt(Object.keys(n).length, 8);
            for (const [t, s] of Object.entries(n))
              (e.writeTable(t, this.$$minoskin), e.writeTable(s, this.$$skins));
          }
          break;
        case "array":
          e.writeArray(n);
          break;
        case "boolean":
          e.writeBoolean(n);
          break;
        case "table":
          e.writeTable(n, this[`$$_${s}`], i.mode);
          break;
        case "number":
          e.writeNumber(n);
          break;
        case "string":
          e.writeString(n);
          break;
        default:
          throw new TypeError(
            `Unknown type for key: ${s} value: ${n} | got -> ${i.type}`
          );
      }
    }
    e.writeTable(null, this.$$options);
  }
  static decode(e) {
    const t = this.$$options.size,
      s = this.OptsBook,
      n = {};
    let i = null,
      o = null;
    for (let a = e.peek(t); 0 !== a; a = e.peek(t)) {
      const t = e.readTable(this.$$options),
        a = s[t]?.type;
      switch (a) {
        case "object":
          if ("handling" === t) {
            const s = {};
            s.arr = e.readFloat(6, 10);
            s.sdf = e.readUInt(6);
            s.safelock = e.readBoolean();
            s.cancel = e.readBoolean();
            s.may20g = e.readBoolean();
            s.das = e.readFloat(8, 10);
            s.dcd = e.readFloat(8, 10);
            s.irs = e.readTable(this.$$ixs);
            s.ihs = e.readTable(this.$$ixs);
            n[t] = s;
          } else if ("minoskin" === t) {
            const s = {},
              i = e.readUInt(8);
            n[t] = s;
            for (let t = 0; t < i; t++) {
              const t = e.readTable(this.$$minoskin),
                n = e.readTable(this.$$skins);
              s[t] = n;
            }
          }
          break;
        case "array":
          n[t] = e.readArray();
          break;
        case "boolean":
          n[t] = e.readBoolean();
          break;
        case "table":
          n[t] = e.readTable(this[`$$_${t}`]);
          break;
        case "number":
          n[t] = e.readNumber();
          break;
        case "string":
          n[t] = e.readString();
          break;
        default: {
          console.error("Options dump: ", n);
          throw new TypeError(
            `Unknown type for key: ${t} | got -> ${a}\nLast Key: ${i}\nLast Value: ${o}\n`
          );
        }
      }
      i = t;
      o = n[t];
    }
    e.seek(t, 2);
    return n;
  }
}
class Je extends Ze {
  static *ParseOptions(e) {
    for (const [s, n, i] of super.ParseOptions(e))
      if (
        i.default !== n &&
        !("object" === i.type && strictShallowEqual(i.default, n))
      ) {
        yield [s, n, i];
      }
  }
}
class et extends Fe {
  static init() {
    super.AddExtension(this, {
      ownBuffer: true
    });
    super.AddTable("gor", [
      null,
      "topout",
      "garbagesmash",
      "zenith",
      "clear",
      "topout_clear",
      "winner",
      "forfeit",
      "retry",
      "drop",
      "dropnow",
      "disconnect"
    ]);
  }
  static encode(e, t) {
    const s = t.successful,
      n = t.gameoverreason,
      i = t.killer.gameid,
      o = "spark" === t.killer.type,
      a = t.killer.username ?? "",
      { apm: r, pps: l, vsscore: c } = t.aggregatestats,
      { game: p, stats: h, diyusi: d } = t;
    e.writeBoolean(s);
    e.writeTable(n, this.$$gor);
    e.writeUInt(i, 13);
    e.writeBoolean(o, 1);
    e.writeString(a);
    e.writeStruct(t.options, Je);
    e.writeDouble(r);
    e.writeDouble(l);
    e.writeDouble(c);
    e.writeStruct(
      {
        game: p,
        stats: h,
        diyusi: d
      },
      Re
    );
  }
  static decode(e) {
    const t = {
      killer: {},
      aggregatestats: {}
    };
    t.successful = e.readBoolean();
    t.gameoverreason = e.readTable(this.$$gor);
    t.killer.gameid = e.readUInt(13);
    t.killer.type = e.readBoolean() ? "spark" : "sizzle";
    t.killer.username = e.readString();
    t.options = e.readStruct(Je);
    t.aggregatestats.apm = e.readDouble();
    t.aggregatestats.pps = e.readDouble();
    t.aggregatestats.vsscore = e.readDouble();
    Object.assign(t, e.readStruct(Re));
    return t;
  }
}
Ie.init();
Ee.init();
Me.init();
De.init();
Oe.init();
He.init();
Re.init();
We.init();
Ne.init();
$e.init();
Ge.init();
Ue.init();
qe.init();
Ve.init();
Ke.init();
Qe.init();
Ye.init();
Ze.init();
et.init();
Fe.LoadExtensions(r);
ke.SetMsgpackr(new r.Packr(Ce), new r.Unpackr(Ce));
export { ke as Codec };
